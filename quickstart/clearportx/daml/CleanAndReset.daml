module CleanAndReset where

import Daml.Script
import qualified AMM.Pool as P
import qualified Token.Token as T
import qualified LPToken.LPToken as LP
import DA.Time

-- Clean up all old contracts and create fresh v1.0.1 setup
-- This script will be run against the Canton ledger with v1.0.1 package

cleanAndResetClearportX : Script ()
cleanAndResetClearportX = script do
  -- Use the actual app-provider party from Canton (already exists)
  appProvider <- allocatePartyWithHint "app_provider_quickstart-root-1" (PartyIdHint "app_provider_quickstart-root-1")

  debug "Starting clean and reset..."

  -- Step 1: Note - we can't directly archive old pools
  -- They will remain on ledger but we'll create new ones with different IDs (V2 suffix)
  debug "Creating new v1.0.1 contracts (old v1.0.0 contracts will remain but unused)"

  -- Step 2: Create fresh tokens with v1.0.1
  debug "Creating fresh tokens with v1.0.1..."

  usdcCid <- submit appProvider $ createCmd T.Token with
    issuer = appProvider
    owner = appProvider
    symbol = "USDC"
    amount = 1000000.0000000000

  ethCid <- submit appProvider $ createCmd T.Token with
    issuer = appProvider
    owner = appProvider
    symbol = "ETH"
    amount = 1000.0000000000

  btcCid <- submit appProvider $ createCmd T.Token with
    issuer = appProvider
    owner = appProvider
    symbol = "BTC"
    amount = 50.0000000000

  usdtCid <- submit appProvider $ createCmd T.Token with
    issuer = appProvider
    owner = appProvider
    symbol = "USDT"
    amount = 1000000.0000000000

  debug "✅ Created 4 fresh tokens"

  -- Step 3: Create fresh pools with v1.0.1 (use different pool IDs to avoid conflicts)
  debug "Creating fresh pools with v1.0.1..."

  ethUsdcPool <- submit appProvider $ createCmd P.Pool with
    poolOperator = appProvider
    poolParty = appProvider
    lpIssuer = appProvider
    issuerA = appProvider
    issuerB = appProvider
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC-V2"  -- New ID to avoid conflicts
    maxTTL = hours 2
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = appProvider
    maxInBps = 1000
    maxOutBps = 1000

  btcUsdcPool <- submit appProvider $ createCmd P.Pool with
    poolOperator = appProvider
    poolParty = appProvider
    lpIssuer = appProvider
    issuerA = appProvider
    issuerB = appProvider
    symbolA = "BTC"
    symbolB = "USDC"
    feeBps = 30
    poolId = "BTC-USDC-V2"
    maxTTL = hours 2
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = appProvider
    maxInBps = 1000
    maxOutBps = 1000

  ethUsdtPool <- submit appProvider $ createCmd P.Pool with
    poolOperator = appProvider
    poolParty = appProvider
    lpIssuer = appProvider
    issuerA = appProvider
    issuerB = appProvider
    symbolA = "ETH"
    symbolB = "USDT"
    feeBps = 30
    poolId = "ETH-USDT-V2"
    maxTTL = hours 2
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = appProvider
    maxInBps = 1000
    maxOutBps = 1000

  debug "✅ Created 3 fresh pools with v1.0.1"

  -- Step 4: Test adding liquidity to one pool to verify it works
  debug "Testing AddLiquidity with v1.0.1..."

  now <- getTime
  (lpTokenCid, newPoolCid) <- submit appProvider $ exerciseCmd ethUsdcPool P.AddLiquidity with
    provider = appProvider
    tokenACid = ethCid
    tokenBCid = usdcCid
    amountA = 10.0
    amountB = 20000.0
    minLPTokens = 0.0
    deadline = addRelTime now (hours 1)

  debug "✅ SUCCESS! AddLiquidity worked with v1.0.1 (provider == poolParty)"
  debug "✅ Fresh v1.0.1 setup complete!"

  return ()
