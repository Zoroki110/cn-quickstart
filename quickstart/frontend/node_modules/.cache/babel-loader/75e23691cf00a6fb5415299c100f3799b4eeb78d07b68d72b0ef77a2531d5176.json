{"ast":null,"code":"import _objectSpread from \"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar __create = Object.create;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __toESM = (mod, isNodeMode, target) => {\n  target = mod != null ? __create(__getProtoOf(mod)) : {};\n  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n    value: mod,\n    enumerable: true\n  }) : target;\n  for (let key of __getOwnPropNames(mod)) if (!__hasOwnProp.call(to, key)) __defProp(to, key, {\n    get: () => mod[key],\n    enumerable: true\n  });\n  return to;\n};\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = {\n  exports: {}\n}).exports, mod), mod.exports);\n\n// node_modules/qrcode/lib/can-promise.js\nvar require_can_promise = __commonJS((exports, module) => {\n  module.exports = function () {\n    return typeof Promise === \"function\" && Promise.prototype && Promise.prototype.then;\n  };\n});\n\n// node_modules/qrcode/lib/core/utils.js\nvar require_utils = __commonJS(exports => {\n  var toSJISFunction;\n  var CODEWORDS_COUNT = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];\n  exports.getSymbolSize = function getSymbolSize(version) {\n    if (!version) throw new Error('\"version\" cannot be null or undefined');\n    if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40');\n    return version * 4 + 17;\n  };\n  exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {\n    return CODEWORDS_COUNT[version];\n  };\n  exports.getBCHDigit = function (data) {\n    let digit = 0;\n    while (data !== 0) {\n      digit++;\n      data >>>= 1;\n    }\n    return digit;\n  };\n  exports.setToSJISFunction = function setToSJISFunction(f) {\n    if (typeof f !== \"function\") {\n      throw new Error('\"toSJISFunc\" is not a valid function.');\n    }\n    toSJISFunction = f;\n  };\n  exports.isKanjiModeEnabled = function () {\n    return typeof toSJISFunction !== \"undefined\";\n  };\n  exports.toSJIS = function toSJIS(kanji) {\n    return toSJISFunction(kanji);\n  };\n});\n\n// node_modules/qrcode/lib/core/error-correction-level.js\nvar require_error_correction_level = __commonJS(exports => {\n  exports.L = {\n    bit: 1\n  };\n  exports.M = {\n    bit: 0\n  };\n  exports.Q = {\n    bit: 3\n  };\n  exports.H = {\n    bit: 2\n  };\n  function fromString(string) {\n    if (typeof string !== \"string\") {\n      throw new Error(\"Param is not a string\");\n    }\n    const lcStr = string.toLowerCase();\n    switch (lcStr) {\n      case \"l\":\n      case \"low\":\n        return exports.L;\n      case \"m\":\n      case \"medium\":\n        return exports.M;\n      case \"q\":\n      case \"quartile\":\n        return exports.Q;\n      case \"h\":\n      case \"high\":\n        return exports.H;\n      default:\n        throw new Error(\"Unknown EC Level: \" + string);\n    }\n  }\n  exports.isValid = function isValid(level) {\n    return level && typeof level.bit !== \"undefined\" && level.bit >= 0 && level.bit < 4;\n  };\n  exports.from = function from(value, defaultValue) {\n    if (exports.isValid(value)) {\n      return value;\n    }\n    try {\n      return fromString(value);\n    } catch (e) {\n      return defaultValue;\n    }\n  };\n});\n\n// node_modules/qrcode/lib/core/bit-buffer.js\nvar require_bit_buffer = __commonJS((exports, module) => {\n  function BitBuffer() {\n    this.buffer = [];\n    this.length = 0;\n  }\n  BitBuffer.prototype = {\n    get: function (index) {\n      const bufIndex = Math.floor(index / 8);\n      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;\n    },\n    put: function (num, length) {\n      for (let i = 0; i < length; i++) {\n        this.putBit((num >>> length - i - 1 & 1) === 1);\n      }\n    },\n    getLengthInBits: function () {\n      return this.length;\n    },\n    putBit: function (bit) {\n      const bufIndex = Math.floor(this.length / 8);\n      if (this.buffer.length <= bufIndex) {\n        this.buffer.push(0);\n      }\n      if (bit) {\n        this.buffer[bufIndex] |= 128 >>> this.length % 8;\n      }\n      this.length++;\n    }\n  };\n  module.exports = BitBuffer;\n});\n\n// node_modules/qrcode/lib/core/bit-matrix.js\nvar require_bit_matrix = __commonJS((exports, module) => {\n  function BitMatrix(size) {\n    if (!size || size < 1) {\n      throw new Error(\"BitMatrix size must be defined and greater than 0\");\n    }\n    this.size = size;\n    this.data = new Uint8Array(size * size);\n    this.reservedBit = new Uint8Array(size * size);\n  }\n  BitMatrix.prototype.set = function (row, col, value, reserved) {\n    const index = row * this.size + col;\n    this.data[index] = value;\n    if (reserved) this.reservedBit[index] = true;\n  };\n  BitMatrix.prototype.get = function (row, col) {\n    return this.data[row * this.size + col];\n  };\n  BitMatrix.prototype.xor = function (row, col, value) {\n    this.data[row * this.size + col] ^= value;\n  };\n  BitMatrix.prototype.isReserved = function (row, col) {\n    return this.reservedBit[row * this.size + col];\n  };\n  module.exports = BitMatrix;\n});\n\n// node_modules/qrcode/lib/core/alignment-pattern.js\nvar require_alignment_pattern = __commonJS(exports => {\n  var getSymbolSize = require_utils().getSymbolSize;\n  exports.getRowColCoords = function getRowColCoords(version) {\n    if (version === 1) return [];\n    const posCount = Math.floor(version / 7) + 2;\n    const size = getSymbolSize(version);\n    const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;\n    const positions = [size - 7];\n    for (let i = 1; i < posCount - 1; i++) {\n      positions[i] = positions[i - 1] - intervals;\n    }\n    positions.push(6);\n    return positions.reverse();\n  };\n  exports.getPositions = function getPositions(version) {\n    const coords = [];\n    const pos = exports.getRowColCoords(version);\n    const posLength = pos.length;\n    for (let i = 0; i < posLength; i++) {\n      for (let j = 0; j < posLength; j++) {\n        if (i === 0 && j === 0 || i === 0 && j === posLength - 1 || i === posLength - 1 && j === 0) {\n          continue;\n        }\n        coords.push([pos[i], pos[j]]);\n      }\n    }\n    return coords;\n  };\n});\n\n// node_modules/qrcode/lib/core/finder-pattern.js\nvar require_finder_pattern = __commonJS(exports => {\n  var getSymbolSize = require_utils().getSymbolSize;\n  var FINDER_PATTERN_SIZE = 7;\n  exports.getPositions = function getPositions(version) {\n    const size = getSymbolSize(version);\n    return [[0, 0], [size - FINDER_PATTERN_SIZE, 0], [0, size - FINDER_PATTERN_SIZE]];\n  };\n});\n\n// node_modules/qrcode/lib/core/mask-pattern.js\nvar require_mask_pattern = __commonJS(exports => {\n  exports.Patterns = {\n    PATTERN000: 0,\n    PATTERN001: 1,\n    PATTERN010: 2,\n    PATTERN011: 3,\n    PATTERN100: 4,\n    PATTERN101: 5,\n    PATTERN110: 6,\n    PATTERN111: 7\n  };\n  var PenaltyScores = {\n    N1: 3,\n    N2: 3,\n    N3: 40,\n    N4: 10\n  };\n  exports.isValid = function isValid(mask) {\n    return mask != null && mask !== \"\" && !isNaN(mask) && mask >= 0 && mask <= 7;\n  };\n  exports.from = function from(value) {\n    return exports.isValid(value) ? parseInt(value, 10) : undefined;\n  };\n  exports.getPenaltyN1 = function getPenaltyN1(data) {\n    const size = data.size;\n    let points = 0;\n    let sameCountCol = 0;\n    let sameCountRow = 0;\n    let lastCol = null;\n    let lastRow = null;\n    for (let row = 0; row < size; row++) {\n      sameCountCol = sameCountRow = 0;\n      lastCol = lastRow = null;\n      for (let col = 0; col < size; col++) {\n        let module2 = data.get(row, col);\n        if (module2 === lastCol) {\n          sameCountCol++;\n        } else {\n          if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n          lastCol = module2;\n          sameCountCol = 1;\n        }\n        module2 = data.get(col, row);\n        if (module2 === lastRow) {\n          sameCountRow++;\n        } else {\n          if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n          lastRow = module2;\n          sameCountRow = 1;\n        }\n      }\n      if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n      if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n    }\n    return points;\n  };\n  exports.getPenaltyN2 = function getPenaltyN2(data) {\n    const size = data.size;\n    let points = 0;\n    for (let row = 0; row < size - 1; row++) {\n      for (let col = 0; col < size - 1; col++) {\n        const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);\n        if (last === 4 || last === 0) points++;\n      }\n    }\n    return points * PenaltyScores.N2;\n  };\n  exports.getPenaltyN3 = function getPenaltyN3(data) {\n    const size = data.size;\n    let points = 0;\n    let bitsCol = 0;\n    let bitsRow = 0;\n    for (let row = 0; row < size; row++) {\n      bitsCol = bitsRow = 0;\n      for (let col = 0; col < size; col++) {\n        bitsCol = bitsCol << 1 & 2047 | data.get(row, col);\n        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;\n        bitsRow = bitsRow << 1 & 2047 | data.get(col, row);\n        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;\n      }\n    }\n    return points * PenaltyScores.N3;\n  };\n  exports.getPenaltyN4 = function getPenaltyN4(data) {\n    let darkCount = 0;\n    const modulesCount = data.data.length;\n    for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];\n    const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);\n    return k * PenaltyScores.N4;\n  };\n  function getMaskAt(maskPattern, i, j) {\n    switch (maskPattern) {\n      case exports.Patterns.PATTERN000:\n        return (i + j) % 2 === 0;\n      case exports.Patterns.PATTERN001:\n        return i % 2 === 0;\n      case exports.Patterns.PATTERN010:\n        return j % 3 === 0;\n      case exports.Patterns.PATTERN011:\n        return (i + j) % 3 === 0;\n      case exports.Patterns.PATTERN100:\n        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\n      case exports.Patterns.PATTERN101:\n        return i * j % 2 + i * j % 3 === 0;\n      case exports.Patterns.PATTERN110:\n        return (i * j % 2 + i * j % 3) % 2 === 0;\n      case exports.Patterns.PATTERN111:\n        return (i * j % 3 + (i + j) % 2) % 2 === 0;\n      default:\n        throw new Error(\"bad maskPattern:\" + maskPattern);\n    }\n  }\n  exports.applyMask = function applyMask(pattern, data) {\n    const size = data.size;\n    for (let col = 0; col < size; col++) {\n      for (let row = 0; row < size; row++) {\n        if (data.isReserved(row, col)) continue;\n        data.xor(row, col, getMaskAt(pattern, row, col));\n      }\n    }\n  };\n  exports.getBestMask = function getBestMask(data, setupFormatFunc) {\n    const numPatterns = Object.keys(exports.Patterns).length;\n    let bestPattern = 0;\n    let lowerPenalty = Infinity;\n    for (let p = 0; p < numPatterns; p++) {\n      setupFormatFunc(p);\n      exports.applyMask(p, data);\n      const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);\n      exports.applyMask(p, data);\n      if (penalty < lowerPenalty) {\n        lowerPenalty = penalty;\n        bestPattern = p;\n      }\n    }\n    return bestPattern;\n  };\n});\n\n// node_modules/qrcode/lib/core/error-correction-code.js\nvar require_error_correction_code = __commonJS(exports => {\n  var ECLevel = require_error_correction_level();\n  var EC_BLOCKS_TABLE = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81];\n  var EC_CODEWORDS_TABLE = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];\n  exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {\n    switch (errorCorrectionLevel) {\n      case ECLevel.L:\n        return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];\n      case ECLevel.M:\n        return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];\n      case ECLevel.Q:\n        return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];\n      case ECLevel.H:\n        return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];\n      default:\n        return;\n    }\n  };\n  exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {\n    switch (errorCorrectionLevel) {\n      case ECLevel.L:\n        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];\n      case ECLevel.M:\n        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];\n      case ECLevel.Q:\n        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];\n      case ECLevel.H:\n        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];\n      default:\n        return;\n    }\n  };\n});\n\n// node_modules/qrcode/lib/core/galois-field.js\nvar require_galois_field = __commonJS(exports => {\n  var EXP_TABLE = new Uint8Array(512);\n  var LOG_TABLE = new Uint8Array(256);\n  (function initTables() {\n    let x = 1;\n    for (let i = 0; i < 255; i++) {\n      EXP_TABLE[i] = x;\n      LOG_TABLE[x] = i;\n      x <<= 1;\n      if (x & 256) {\n        x ^= 285;\n      }\n    }\n    for (let i = 255; i < 512; i++) {\n      EXP_TABLE[i] = EXP_TABLE[i - 255];\n    }\n  })();\n  exports.log = function log(n) {\n    if (n < 1) throw new Error(\"log(\" + n + \")\");\n    return LOG_TABLE[n];\n  };\n  exports.exp = function exp(n) {\n    return EXP_TABLE[n];\n  };\n  exports.mul = function mul(x, y) {\n    if (x === 0 || y === 0) return 0;\n    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];\n  };\n});\n\n// node_modules/qrcode/lib/core/polynomial.js\nvar require_polynomial = __commonJS(exports => {\n  var GF = require_galois_field();\n  exports.mul = function mul(p1, p2) {\n    const coeff = new Uint8Array(p1.length + p2.length - 1);\n    for (let i = 0; i < p1.length; i++) {\n      for (let j = 0; j < p2.length; j++) {\n        coeff[i + j] ^= GF.mul(p1[i], p2[j]);\n      }\n    }\n    return coeff;\n  };\n  exports.mod = function mod(divident, divisor) {\n    let result = new Uint8Array(divident);\n    while (result.length - divisor.length >= 0) {\n      const coeff = result[0];\n      for (let i = 0; i < divisor.length; i++) {\n        result[i] ^= GF.mul(divisor[i], coeff);\n      }\n      let offset = 0;\n      while (offset < result.length && result[offset] === 0) offset++;\n      result = result.slice(offset);\n    }\n    return result;\n  };\n  exports.generateECPolynomial = function generateECPolynomial(degree) {\n    let poly = new Uint8Array([1]);\n    for (let i = 0; i < degree; i++) {\n      poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));\n    }\n    return poly;\n  };\n});\n\n// node_modules/qrcode/lib/core/reed-solomon-encoder.js\nvar require_reed_solomon_encoder = __commonJS((exports, module) => {\n  var Polynomial = require_polynomial();\n  function ReedSolomonEncoder(degree) {\n    this.genPoly = undefined;\n    this.degree = degree;\n    if (this.degree) this.initialize(this.degree);\n  }\n  ReedSolomonEncoder.prototype.initialize = function initialize(degree) {\n    this.degree = degree;\n    this.genPoly = Polynomial.generateECPolynomial(this.degree);\n  };\n  ReedSolomonEncoder.prototype.encode = function encode(data) {\n    if (!this.genPoly) {\n      throw new Error(\"Encoder not initialized\");\n    }\n    const paddedData = new Uint8Array(data.length + this.degree);\n    paddedData.set(data);\n    const remainder = Polynomial.mod(paddedData, this.genPoly);\n    const start = this.degree - remainder.length;\n    if (start > 0) {\n      const buff = new Uint8Array(this.degree);\n      buff.set(remainder, start);\n      return buff;\n    }\n    return remainder;\n  };\n  module.exports = ReedSolomonEncoder;\n});\n\n// node_modules/qrcode/lib/core/version-check.js\nvar require_version_check = __commonJS(exports => {\n  exports.isValid = function isValid(version) {\n    return !isNaN(version) && version >= 1 && version <= 40;\n  };\n});\n\n// node_modules/qrcode/lib/core/regex.js\nvar require_regex = __commonJS(exports => {\n  var numeric = \"[0-9]+\";\n  var alphanumeric = \"[A-Z $%*+\\\\-./:]+\";\n  var kanji = \"(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|\" + \"[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|\" + \"[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|\" + \"[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+\";\n  kanji = kanji.replace(/u/g, \"\\\\u\");\n  var byte = \"(?:(?![A-Z0-9 $%*+\\\\-./:]|\" + kanji + \")(?:.|[\\r\\n]))+\";\n  exports.KANJI = new RegExp(kanji, \"g\");\n  exports.BYTE_KANJI = new RegExp(\"[^A-Z0-9 $%*+\\\\-./:]+\", \"g\");\n  exports.BYTE = new RegExp(byte, \"g\");\n  exports.NUMERIC = new RegExp(numeric, \"g\");\n  exports.ALPHANUMERIC = new RegExp(alphanumeric, \"g\");\n  var TEST_KANJI = new RegExp(\"^\" + kanji + \"$\");\n  var TEST_NUMERIC = new RegExp(\"^\" + numeric + \"$\");\n  var TEST_ALPHANUMERIC = new RegExp(\"^[A-Z0-9 $%*+\\\\-./:]+$\");\n  exports.testKanji = function testKanji(str) {\n    return TEST_KANJI.test(str);\n  };\n  exports.testNumeric = function testNumeric(str) {\n    return TEST_NUMERIC.test(str);\n  };\n  exports.testAlphanumeric = function testAlphanumeric(str) {\n    return TEST_ALPHANUMERIC.test(str);\n  };\n});\n\n// node_modules/qrcode/lib/core/mode.js\nvar require_mode = __commonJS(exports => {\n  var VersionCheck = require_version_check();\n  var Regex = require_regex();\n  exports.NUMERIC = {\n    id: \"Numeric\",\n    bit: 1 << 0,\n    ccBits: [10, 12, 14]\n  };\n  exports.ALPHANUMERIC = {\n    id: \"Alphanumeric\",\n    bit: 1 << 1,\n    ccBits: [9, 11, 13]\n  };\n  exports.BYTE = {\n    id: \"Byte\",\n    bit: 1 << 2,\n    ccBits: [8, 16, 16]\n  };\n  exports.KANJI = {\n    id: \"Kanji\",\n    bit: 1 << 3,\n    ccBits: [8, 10, 12]\n  };\n  exports.MIXED = {\n    bit: -1\n  };\n  exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n    if (!mode.ccBits) throw new Error(\"Invalid mode: \" + mode);\n    if (!VersionCheck.isValid(version)) {\n      throw new Error(\"Invalid version: \" + version);\n    }\n    if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];\n    return mode.ccBits[2];\n  };\n  exports.getBestModeForData = function getBestModeForData(dataStr) {\n    if (Regex.testNumeric(dataStr)) return exports.NUMERIC;else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (Regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;\n  };\n  exports.toString = function toString(mode) {\n    if (mode && mode.id) return mode.id;\n    throw new Error(\"Invalid mode\");\n  };\n  exports.isValid = function isValid(mode) {\n    return mode && mode.bit && mode.ccBits;\n  };\n  function fromString(string) {\n    if (typeof string !== \"string\") {\n      throw new Error(\"Param is not a string\");\n    }\n    const lcStr = string.toLowerCase();\n    switch (lcStr) {\n      case \"numeric\":\n        return exports.NUMERIC;\n      case \"alphanumeric\":\n        return exports.ALPHANUMERIC;\n      case \"kanji\":\n        return exports.KANJI;\n      case \"byte\":\n        return exports.BYTE;\n      default:\n        throw new Error(\"Unknown mode: \" + string);\n    }\n  }\n  exports.from = function from(value, defaultValue) {\n    if (exports.isValid(value)) {\n      return value;\n    }\n    try {\n      return fromString(value);\n    } catch (e) {\n      return defaultValue;\n    }\n  };\n});\n\n// node_modules/qrcode/lib/core/version.js\nvar require_version = __commonJS(exports => {\n  var Utils = require_utils();\n  var ECCode = require_error_correction_code();\n  var ECLevel = require_error_correction_level();\n  var Mode = require_mode();\n  var VersionCheck = require_version_check();\n  var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n  var G18_BCH = Utils.getBCHDigit(G18);\n  function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {\n    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n        return currentVersion;\n      }\n    }\n    return;\n  }\n  function getReservedBitsCount(mode, version) {\n    return Mode.getCharCountIndicator(mode, version) + 4;\n  }\n  function getTotalBitsFromDataArray(segments, version) {\n    let totalBits = 0;\n    segments.forEach(function (data) {\n      const reservedBits = getReservedBitsCount(data.mode, version);\n      totalBits += reservedBits + data.getBitsLength();\n    });\n    return totalBits;\n  }\n  function getBestVersionForMixedData(segments, errorCorrectionLevel) {\n    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n      const length = getTotalBitsFromDataArray(segments, currentVersion);\n      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n        return currentVersion;\n      }\n    }\n    return;\n  }\n  exports.from = function from(value, defaultValue) {\n    if (VersionCheck.isValid(value)) {\n      return parseInt(value, 10);\n    }\n    return defaultValue;\n  };\n  exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {\n    if (!VersionCheck.isValid(version)) {\n      throw new Error(\"Invalid QR Code version\");\n    }\n    if (typeof mode === \"undefined\") mode = Mode.BYTE;\n    const totalCodewords = Utils.getSymbolTotalCodewords(version);\n    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n    if (mode === Mode.MIXED) return dataTotalCodewordsBits;\n    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);\n    switch (mode) {\n      case Mode.NUMERIC:\n        return Math.floor(usableBits / 10 * 3);\n      case Mode.ALPHANUMERIC:\n        return Math.floor(usableBits / 11 * 2);\n      case Mode.KANJI:\n        return Math.floor(usableBits / 13);\n      case Mode.BYTE:\n      default:\n        return Math.floor(usableBits / 8);\n    }\n  };\n  exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {\n    let seg;\n    const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);\n    if (Array.isArray(data)) {\n      if (data.length > 1) {\n        return getBestVersionForMixedData(data, ecl);\n      }\n      if (data.length === 0) {\n        return 1;\n      }\n      seg = data[0];\n    } else {\n      seg = data;\n    }\n    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);\n  };\n  exports.getEncodedBits = function getEncodedBits(version) {\n    if (!VersionCheck.isValid(version) || version < 7) {\n      throw new Error(\"Invalid QR Code version\");\n    }\n    let d = version << 12;\n    while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n      d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;\n    }\n    return version << 12 | d;\n  };\n});\n\n// node_modules/qrcode/lib/core/format-info.js\nvar require_format_info = __commonJS(exports => {\n  var Utils = require_utils();\n  var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\n  var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\n  var G15_BCH = Utils.getBCHDigit(G15);\n  exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {\n    const data = errorCorrectionLevel.bit << 3 | mask;\n    let d = data << 10;\n    while (Utils.getBCHDigit(d) - G15_BCH >= 0) {\n      d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;\n    }\n    return (data << 10 | d) ^ G15_MASK;\n  };\n});\n\n// node_modules/qrcode/lib/core/numeric-data.js\nvar require_numeric_data = __commonJS((exports, module) => {\n  var Mode = require_mode();\n  function NumericData(data) {\n    this.mode = Mode.NUMERIC;\n    this.data = data.toString();\n  }\n  NumericData.getBitsLength = function getBitsLength(length) {\n    return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);\n  };\n  NumericData.prototype.getLength = function getLength() {\n    return this.data.length;\n  };\n  NumericData.prototype.getBitsLength = function getBitsLength() {\n    return NumericData.getBitsLength(this.data.length);\n  };\n  NumericData.prototype.write = function write(bitBuffer) {\n    let i, group, value;\n    for (i = 0; i + 3 <= this.data.length; i += 3) {\n      group = this.data.substr(i, 3);\n      value = parseInt(group, 10);\n      bitBuffer.put(value, 10);\n    }\n    const remainingNum = this.data.length - i;\n    if (remainingNum > 0) {\n      group = this.data.substr(i);\n      value = parseInt(group, 10);\n      bitBuffer.put(value, remainingNum * 3 + 1);\n    }\n  };\n  module.exports = NumericData;\n});\n\n// node_modules/qrcode/lib/core/alphanumeric-data.js\nvar require_alphanumeric_data = __commonJS((exports, module) => {\n  var Mode = require_mode();\n  var ALPHA_NUM_CHARS = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \" \", \"$\", \"%\", \"*\", \"+\", \"-\", \".\", \"/\", \":\"];\n  function AlphanumericData(data) {\n    this.mode = Mode.ALPHANUMERIC;\n    this.data = data;\n  }\n  AlphanumericData.getBitsLength = function getBitsLength(length) {\n    return 11 * Math.floor(length / 2) + 6 * (length % 2);\n  };\n  AlphanumericData.prototype.getLength = function getLength() {\n    return this.data.length;\n  };\n  AlphanumericData.prototype.getBitsLength = function getBitsLength() {\n    return AlphanumericData.getBitsLength(this.data.length);\n  };\n  AlphanumericData.prototype.write = function write(bitBuffer) {\n    let i;\n    for (i = 0; i + 2 <= this.data.length; i += 2) {\n      let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;\n      value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);\n      bitBuffer.put(value, 11);\n    }\n    if (this.data.length % 2) {\n      bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);\n    }\n  };\n  module.exports = AlphanumericData;\n});\n\n// node_modules/qrcode/lib/core/byte-data.js\nvar require_byte_data = __commonJS((exports, module) => {\n  var Mode = require_mode();\n  function ByteData(data) {\n    this.mode = Mode.BYTE;\n    if (typeof data === \"string\") {\n      this.data = new TextEncoder().encode(data);\n    } else {\n      this.data = new Uint8Array(data);\n    }\n  }\n  ByteData.getBitsLength = function getBitsLength(length) {\n    return length * 8;\n  };\n  ByteData.prototype.getLength = function getLength() {\n    return this.data.length;\n  };\n  ByteData.prototype.getBitsLength = function getBitsLength() {\n    return ByteData.getBitsLength(this.data.length);\n  };\n  ByteData.prototype.write = function (bitBuffer) {\n    for (let i = 0, l = this.data.length; i < l; i++) {\n      bitBuffer.put(this.data[i], 8);\n    }\n  };\n  module.exports = ByteData;\n});\n\n// node_modules/qrcode/lib/core/kanji-data.js\nvar require_kanji_data = __commonJS((exports, module) => {\n  var Mode = require_mode();\n  var Utils = require_utils();\n  function KanjiData(data) {\n    this.mode = Mode.KANJI;\n    this.data = data;\n  }\n  KanjiData.getBitsLength = function getBitsLength(length) {\n    return length * 13;\n  };\n  KanjiData.prototype.getLength = function getLength() {\n    return this.data.length;\n  };\n  KanjiData.prototype.getBitsLength = function getBitsLength() {\n    return KanjiData.getBitsLength(this.data.length);\n  };\n  KanjiData.prototype.write = function (bitBuffer) {\n    let i;\n    for (i = 0; i < this.data.length; i++) {\n      let value = Utils.toSJIS(this.data[i]);\n      if (value >= 33088 && value <= 40956) {\n        value -= 33088;\n      } else if (value >= 57408 && value <= 60351) {\n        value -= 49472;\n      } else {\n        throw new Error(\"Invalid SJIS character: \" + this.data[i] + \"\\n\" + \"Make sure your charset is UTF-8\");\n      }\n      value = (value >>> 8 & 255) * 192 + (value & 255);\n      bitBuffer.put(value, 13);\n    }\n  };\n  module.exports = KanjiData;\n});\n\n// node_modules/dijkstrajs/dijkstra.js\nvar require_dijkstra = __commonJS((exports, module) => {\n  var dijkstra = {\n    single_source_shortest_paths: function (graph, s, d) {\n      var predecessors = {};\n      var costs = {};\n      costs[s] = 0;\n      var open = dijkstra.PriorityQueue.make();\n      open.push(s, 0);\n      var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n      while (!open.empty()) {\n        closest = open.pop();\n        u = closest.value;\n        cost_of_s_to_u = closest.cost;\n        adjacent_nodes = graph[u] || {};\n        for (v in adjacent_nodes) {\n          if (adjacent_nodes.hasOwnProperty(v)) {\n            cost_of_e = adjacent_nodes[v];\n            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n            cost_of_s_to_v = costs[v];\n            first_visit = typeof costs[v] === \"undefined\";\n            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n              costs[v] = cost_of_s_to_u_plus_cost_of_e;\n              open.push(v, cost_of_s_to_u_plus_cost_of_e);\n              predecessors[v] = u;\n            }\n          }\n        }\n      }\n      if (typeof d !== \"undefined\" && typeof costs[d] === \"undefined\") {\n        var msg = [\"Could not find a path from \", s, \" to \", d, \".\"].join(\"\");\n        throw new Error(msg);\n      }\n      return predecessors;\n    },\n    extract_shortest_path_from_predecessor_list: function (predecessors, d) {\n      var nodes = [];\n      var u = d;\n      var predecessor;\n      while (u) {\n        nodes.push(u);\n        predecessor = predecessors[u];\n        u = predecessors[u];\n      }\n      nodes.reverse();\n      return nodes;\n    },\n    find_path: function (graph, s, d) {\n      var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n      return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n    },\n    PriorityQueue: {\n      make: function (opts) {\n        var T = dijkstra.PriorityQueue,\n          t = {},\n          key;\n        opts = opts || {};\n        for (key in T) {\n          if (T.hasOwnProperty(key)) {\n            t[key] = T[key];\n          }\n        }\n        t.queue = [];\n        t.sorter = opts.sorter || T.default_sorter;\n        return t;\n      },\n      default_sorter: function (a, b) {\n        return a.cost - b.cost;\n      },\n      push: function (value, cost) {\n        var item = {\n          value,\n          cost\n        };\n        this.queue.push(item);\n        this.queue.sort(this.sorter);\n      },\n      pop: function () {\n        return this.queue.shift();\n      },\n      empty: function () {\n        return this.queue.length === 0;\n      }\n    }\n  };\n  if (typeof module !== \"undefined\") {\n    module.exports = dijkstra;\n  }\n});\n\n// node_modules/qrcode/lib/core/segments.js\nvar require_segments = __commonJS(exports => {\n  var Mode = require_mode();\n  var NumericData = require_numeric_data();\n  var AlphanumericData = require_alphanumeric_data();\n  var ByteData = require_byte_data();\n  var KanjiData = require_kanji_data();\n  var Regex = require_regex();\n  var Utils = require_utils();\n  var dijkstra = require_dijkstra();\n  function getStringByteLength(str) {\n    return unescape(encodeURIComponent(str)).length;\n  }\n  function getSegments(regex, mode, str) {\n    const segments = [];\n    let result;\n    while ((result = regex.exec(str)) !== null) {\n      segments.push({\n        data: result[0],\n        index: result.index,\n        mode,\n        length: result[0].length\n      });\n    }\n    return segments;\n  }\n  function getSegmentsFromString(dataStr) {\n    const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);\n    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);\n    let byteSegs;\n    let kanjiSegs;\n    if (Utils.isKanjiModeEnabled()) {\n      byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);\n      kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);\n    } else {\n      byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);\n      kanjiSegs = [];\n    }\n    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n    return segs.sort(function (s1, s2) {\n      return s1.index - s2.index;\n    }).map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      };\n    });\n  }\n  function getSegmentBitsLength(length, mode) {\n    switch (mode) {\n      case Mode.NUMERIC:\n        return NumericData.getBitsLength(length);\n      case Mode.ALPHANUMERIC:\n        return AlphanumericData.getBitsLength(length);\n      case Mode.KANJI:\n        return KanjiData.getBitsLength(length);\n      case Mode.BYTE:\n        return ByteData.getBitsLength(length);\n    }\n  }\n  function mergeSegments(segs) {\n    return segs.reduce(function (acc, curr) {\n      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n      if (prevSeg && prevSeg.mode === curr.mode) {\n        acc[acc.length - 1].data += curr.data;\n        return acc;\n      }\n      acc.push(curr);\n      return acc;\n    }, []);\n  }\n  function buildNodes(segs) {\n    const nodes = [];\n    for (let i = 0; i < segs.length; i++) {\n      const seg = segs[i];\n      switch (seg.mode) {\n        case Mode.NUMERIC:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: Mode.ALPHANUMERIC,\n            length: seg.length\n          }, {\n            data: seg.data,\n            mode: Mode.BYTE,\n            length: seg.length\n          }]);\n          break;\n        case Mode.ALPHANUMERIC:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: Mode.BYTE,\n            length: seg.length\n          }]);\n          break;\n        case Mode.KANJI:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: Mode.BYTE,\n            length: getStringByteLength(seg.data)\n          }]);\n          break;\n        case Mode.BYTE:\n          nodes.push([{\n            data: seg.data,\n            mode: Mode.BYTE,\n            length: getStringByteLength(seg.data)\n          }]);\n      }\n    }\n    return nodes;\n  }\n  function buildGraph(nodes, version) {\n    const table = {};\n    const graph = {\n      start: {}\n    };\n    let prevNodeIds = [\"start\"];\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeGroup = nodes[i];\n      const currentNodeIds = [];\n      for (let j = 0; j < nodeGroup.length; j++) {\n        const node = nodeGroup[j];\n        const key = \"\" + i + j;\n        currentNodeIds.push(key);\n        table[key] = {\n          node,\n          lastCount: 0\n        };\n        graph[key] = {};\n        for (let n = 0; n < prevNodeIds.length; n++) {\n          const prevNodeId = prevNodeIds[n];\n          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n            graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n            table[prevNodeId].lastCount += node.length;\n          } else {\n            if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;\n            graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);\n          }\n        }\n      }\n      prevNodeIds = currentNodeIds;\n    }\n    for (let n = 0; n < prevNodeIds.length; n++) {\n      graph[prevNodeIds[n]].end = 0;\n    }\n    return {\n      map: graph,\n      table\n    };\n  }\n  function buildSingleSegment(data, modesHint) {\n    let mode;\n    const bestMode = Mode.getBestModeForData(data);\n    mode = Mode.from(modesHint, bestMode);\n    if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n      throw new Error('\"' + data + '\"' + \" cannot be encoded with mode \" + Mode.toString(mode) + \".\\n Suggested mode is: \" + Mode.toString(bestMode));\n    }\n    if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n      mode = Mode.BYTE;\n    }\n    switch (mode) {\n      case Mode.NUMERIC:\n        return new NumericData(data);\n      case Mode.ALPHANUMERIC:\n        return new AlphanumericData(data);\n      case Mode.KANJI:\n        return new KanjiData(data);\n      case Mode.BYTE:\n        return new ByteData(data);\n    }\n  }\n  exports.fromArray = function fromArray(array) {\n    return array.reduce(function (acc, seg) {\n      if (typeof seg === \"string\") {\n        acc.push(buildSingleSegment(seg, null));\n      } else if (seg.data) {\n        acc.push(buildSingleSegment(seg.data, seg.mode));\n      }\n      return acc;\n    }, []);\n  };\n  exports.fromString = function fromString(data, version) {\n    const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());\n    const nodes = buildNodes(segs);\n    const graph = buildGraph(nodes, version);\n    const path = dijkstra.find_path(graph.map, \"start\", \"end\");\n    const optimizedSegs = [];\n    for (let i = 1; i < path.length - 1; i++) {\n      optimizedSegs.push(graph.table[path[i]].node);\n    }\n    return exports.fromArray(mergeSegments(optimizedSegs));\n  };\n  exports.rawSplit = function rawSplit(data) {\n    return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));\n  };\n});\n\n// node_modules/qrcode/lib/core/qrcode.js\nvar require_qrcode = __commonJS(exports => {\n  var Utils = require_utils();\n  var ECLevel = require_error_correction_level();\n  var BitBuffer = require_bit_buffer();\n  var BitMatrix = require_bit_matrix();\n  var AlignmentPattern = require_alignment_pattern();\n  var FinderPattern = require_finder_pattern();\n  var MaskPattern = require_mask_pattern();\n  var ECCode = require_error_correction_code();\n  var ReedSolomonEncoder = require_reed_solomon_encoder();\n  var Version = require_version();\n  var FormatInfo = require_format_info();\n  var Mode = require_mode();\n  var Segments = require_segments();\n  function setupFinderPattern(matrix, version) {\n    const size = matrix.size;\n    const pos = FinderPattern.getPositions(version);\n    for (let i = 0; i < pos.length; i++) {\n      const row = pos[i][0];\n      const col = pos[i][1];\n      for (let r = -1; r <= 7; r++) {\n        if (row + r <= -1 || size <= row + r) continue;\n        for (let c = -1; c <= 7; c++) {\n          if (col + c <= -1 || size <= col + c) continue;\n          if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {\n            matrix.set(row + r, col + c, true, true);\n          } else {\n            matrix.set(row + r, col + c, false, true);\n          }\n        }\n      }\n    }\n  }\n  function setupTimingPattern(matrix) {\n    const size = matrix.size;\n    for (let r = 8; r < size - 8; r++) {\n      const value = r % 2 === 0;\n      matrix.set(r, 6, value, true);\n      matrix.set(6, r, value, true);\n    }\n  }\n  function setupAlignmentPattern(matrix, version) {\n    const pos = AlignmentPattern.getPositions(version);\n    for (let i = 0; i < pos.length; i++) {\n      const row = pos[i][0];\n      const col = pos[i][1];\n      for (let r = -2; r <= 2; r++) {\n        for (let c = -2; c <= 2; c++) {\n          if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {\n            matrix.set(row + r, col + c, true, true);\n          } else {\n            matrix.set(row + r, col + c, false, true);\n          }\n        }\n      }\n    }\n  }\n  function setupVersionInfo(matrix, version) {\n    const size = matrix.size;\n    const bits = Version.getEncodedBits(version);\n    let row, col, mod;\n    for (let i = 0; i < 18; i++) {\n      row = Math.floor(i / 3);\n      col = i % 3 + size - 8 - 3;\n      mod = (bits >> i & 1) === 1;\n      matrix.set(row, col, mod, true);\n      matrix.set(col, row, mod, true);\n    }\n  }\n  function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {\n    const size = matrix.size;\n    const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);\n    let i, mod;\n    for (i = 0; i < 15; i++) {\n      mod = (bits >> i & 1) === 1;\n      if (i < 6) {\n        matrix.set(i, 8, mod, true);\n      } else if (i < 8) {\n        matrix.set(i + 1, 8, mod, true);\n      } else {\n        matrix.set(size - 15 + i, 8, mod, true);\n      }\n      if (i < 8) {\n        matrix.set(8, size - i - 1, mod, true);\n      } else if (i < 9) {\n        matrix.set(8, 15 - i - 1 + 1, mod, true);\n      } else {\n        matrix.set(8, 15 - i - 1, mod, true);\n      }\n    }\n    matrix.set(size - 8, 8, 1, true);\n  }\n  function setupData(matrix, data) {\n    const size = matrix.size;\n    let inc = -1;\n    let row = size - 1;\n    let bitIndex = 7;\n    let byteIndex = 0;\n    for (let col = size - 1; col > 0; col -= 2) {\n      if (col === 6) col--;\n      while (true) {\n        for (let c = 0; c < 2; c++) {\n          if (!matrix.isReserved(row, col - c)) {\n            let dark = false;\n            if (byteIndex < data.length) {\n              dark = (data[byteIndex] >>> bitIndex & 1) === 1;\n            }\n            matrix.set(row, col - c, dark);\n            bitIndex--;\n            if (bitIndex === -1) {\n              byteIndex++;\n              bitIndex = 7;\n            }\n          }\n        }\n        row += inc;\n        if (row < 0 || size <= row) {\n          row -= inc;\n          inc = -inc;\n          break;\n        }\n      }\n    }\n  }\n  function createData(version, errorCorrectionLevel, segments) {\n    const buffer = new BitBuffer();\n    segments.forEach(function (data) {\n      buffer.put(data.mode.bit, 4);\n      buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));\n      data.write(buffer);\n    });\n    const totalCodewords = Utils.getSymbolTotalCodewords(version);\n    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n      buffer.put(0, 4);\n    }\n    while (buffer.getLengthInBits() % 8 !== 0) {\n      buffer.putBit(0);\n    }\n    const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;\n    for (let i = 0; i < remainingByte; i++) {\n      buffer.put(i % 2 ? 17 : 236, 8);\n    }\n    return createCodewords(buffer, version, errorCorrectionLevel);\n  }\n  function createCodewords(bitBuffer, version, errorCorrectionLevel) {\n    const totalCodewords = Utils.getSymbolTotalCodewords(version);\n    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    const dataTotalCodewords = totalCodewords - ecTotalCodewords;\n    const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);\n    const blocksInGroup2 = totalCodewords % ecTotalBlocks;\n    const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;\n    const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);\n    const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);\n    const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;\n    const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;\n    const rs = new ReedSolomonEncoder(ecCount);\n    let offset = 0;\n    const dcData = new Array(ecTotalBlocks);\n    const ecData = new Array(ecTotalBlocks);\n    let maxDataSize = 0;\n    const buffer = new Uint8Array(bitBuffer.buffer);\n    for (let b = 0; b < ecTotalBlocks; b++) {\n      const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;\n      dcData[b] = buffer.slice(offset, offset + dataSize);\n      ecData[b] = rs.encode(dcData[b]);\n      offset += dataSize;\n      maxDataSize = Math.max(maxDataSize, dataSize);\n    }\n    const data = new Uint8Array(totalCodewords);\n    let index = 0;\n    let i, r;\n    for (i = 0; i < maxDataSize; i++) {\n      for (r = 0; r < ecTotalBlocks; r++) {\n        if (i < dcData[r].length) {\n          data[index++] = dcData[r][i];\n        }\n      }\n    }\n    for (i = 0; i < ecCount; i++) {\n      for (r = 0; r < ecTotalBlocks; r++) {\n        data[index++] = ecData[r][i];\n      }\n    }\n    return data;\n  }\n  function createSymbol(data, version, errorCorrectionLevel, maskPattern) {\n    let segments;\n    if (Array.isArray(data)) {\n      segments = Segments.fromArray(data);\n    } else if (typeof data === \"string\") {\n      let estimatedVersion = version;\n      if (!estimatedVersion) {\n        const rawSegments = Segments.rawSplit(data);\n        estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);\n      }\n      segments = Segments.fromString(data, estimatedVersion || 40);\n    } else {\n      throw new Error(\"Invalid data\");\n    }\n    const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);\n    if (!bestVersion) {\n      throw new Error(\"The amount of data is too big to be stored in a QR Code\");\n    }\n    if (!version) {\n      version = bestVersion;\n    } else if (version < bestVersion) {\n      throw new Error(\"\\n\" + \"The chosen QR Code version cannot contain this amount of data.\\n\" + \"Minimum version required to store current data is: \" + bestVersion + \".\\n\");\n    }\n    const dataBits = createData(version, errorCorrectionLevel, segments);\n    const moduleCount = Utils.getSymbolSize(version);\n    const modules = new BitMatrix(moduleCount);\n    setupFinderPattern(modules, version);\n    setupTimingPattern(modules);\n    setupAlignmentPattern(modules, version);\n    setupFormatInfo(modules, errorCorrectionLevel, 0);\n    if (version >= 7) {\n      setupVersionInfo(modules, version);\n    }\n    setupData(modules, dataBits);\n    if (isNaN(maskPattern)) {\n      maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));\n    }\n    MaskPattern.applyMask(maskPattern, modules);\n    setupFormatInfo(modules, errorCorrectionLevel, maskPattern);\n    return {\n      modules,\n      version,\n      errorCorrectionLevel,\n      maskPattern,\n      segments\n    };\n  }\n  exports.create = function create(data, options) {\n    if (typeof data === \"undefined\" || data === \"\") {\n      throw new Error(\"No input text\");\n    }\n    let errorCorrectionLevel = ECLevel.M;\n    let version;\n    let mask;\n    if (typeof options !== \"undefined\") {\n      errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);\n      version = Version.from(options.version);\n      mask = MaskPattern.from(options.maskPattern);\n      if (options.toSJISFunc) {\n        Utils.setToSJISFunction(options.toSJISFunc);\n      }\n    }\n    return createSymbol(data, version, errorCorrectionLevel, mask);\n  };\n});\n\n// node_modules/qrcode/lib/renderer/utils.js\nvar require_utils2 = __commonJS(exports => {\n  function hex2rgba(hex) {\n    if (typeof hex === \"number\") {\n      hex = hex.toString();\n    }\n    if (typeof hex !== \"string\") {\n      throw new Error(\"Color should be defined as hex string\");\n    }\n    let hexCode = hex.slice().replace(\"#\", \"\").split(\"\");\n    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n      throw new Error(\"Invalid hex color: \" + hex);\n    }\n    if (hexCode.length === 3 || hexCode.length === 4) {\n      hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n        return [c, c];\n      }));\n    }\n    if (hexCode.length === 6) hexCode.push(\"F\", \"F\");\n    const hexValue = parseInt(hexCode.join(\"\"), 16);\n    return {\n      r: hexValue >> 24 & 255,\n      g: hexValue >> 16 & 255,\n      b: hexValue >> 8 & 255,\n      a: hexValue & 255,\n      hex: \"#\" + hexCode.slice(0, 6).join(\"\")\n    };\n  }\n  exports.getOptions = function getOptions(options) {\n    if (!options) options = {};\n    if (!options.color) options.color = {};\n    const margin = typeof options.margin === \"undefined\" || options.margin === null || options.margin < 0 ? 4 : options.margin;\n    const width = options.width && options.width >= 21 ? options.width : undefined;\n    const scale = options.scale || 4;\n    return {\n      width,\n      scale: width ? 4 : scale,\n      margin,\n      color: {\n        dark: hex2rgba(options.color.dark || \"#000000ff\"),\n        light: hex2rgba(options.color.light || \"#ffffffff\")\n      },\n      type: options.type,\n      rendererOpts: options.rendererOpts || {}\n    };\n  };\n  exports.getScale = function getScale(qrSize, opts) {\n    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;\n  };\n  exports.getImageWidth = function getImageWidth(qrSize, opts) {\n    const scale = exports.getScale(qrSize, opts);\n    return Math.floor((qrSize + opts.margin * 2) * scale);\n  };\n  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {\n    const size = qr.modules.size;\n    const data = qr.modules.data;\n    const scale = exports.getScale(size, opts);\n    const symbolSize = Math.floor((size + opts.margin * 2) * scale);\n    const scaledMargin = opts.margin * scale;\n    const palette = [opts.color.light, opts.color.dark];\n    for (let i = 0; i < symbolSize; i++) {\n      for (let j = 0; j < symbolSize; j++) {\n        let posDst = (i * symbolSize + j) * 4;\n        let pxColor = opts.color.light;\n        if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n          const iSrc = Math.floor((i - scaledMargin) / scale);\n          const jSrc = Math.floor((j - scaledMargin) / scale);\n          pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];\n        }\n        imgData[posDst++] = pxColor.r;\n        imgData[posDst++] = pxColor.g;\n        imgData[posDst++] = pxColor.b;\n        imgData[posDst] = pxColor.a;\n      }\n    }\n  };\n});\n\n// node_modules/qrcode/lib/renderer/canvas.js\nvar require_canvas = __commonJS(exports => {\n  var Utils = require_utils2();\n  function clearCanvas(ctx, canvas, size) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    if (!canvas.style) canvas.style = {};\n    canvas.height = size;\n    canvas.width = size;\n    canvas.style.height = size + \"px\";\n    canvas.style.width = size + \"px\";\n  }\n  function getCanvasElement() {\n    try {\n      return document.createElement(\"canvas\");\n    } catch (e) {\n      throw new Error(\"You need to specify a canvas element\");\n    }\n  }\n  exports.render = function render(qrData, canvas, options) {\n    let opts = options;\n    let canvasEl = canvas;\n    if (typeof opts === \"undefined\" && (!canvas || !canvas.getContext)) {\n      opts = canvas;\n      canvas = undefined;\n    }\n    if (!canvas) {\n      canvasEl = getCanvasElement();\n    }\n    opts = Utils.getOptions(opts);\n    const size = Utils.getImageWidth(qrData.modules.size, opts);\n    const ctx = canvasEl.getContext(\"2d\");\n    const image = ctx.createImageData(size, size);\n    Utils.qrToImageData(image.data, qrData, opts);\n    clearCanvas(ctx, canvasEl, size);\n    ctx.putImageData(image, 0, 0);\n    return canvasEl;\n  };\n  exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {\n    let opts = options;\n    if (typeof opts === \"undefined\" && (!canvas || !canvas.getContext)) {\n      opts = canvas;\n      canvas = undefined;\n    }\n    if (!opts) opts = {};\n    const canvasEl = exports.render(qrData, canvas, opts);\n    const type = opts.type || \"image/png\";\n    const rendererOpts = opts.rendererOpts || {};\n    return canvasEl.toDataURL(type, rendererOpts.quality);\n  };\n});\n\n// node_modules/qrcode/lib/renderer/svg-tag.js\nvar require_svg_tag = __commonJS(exports => {\n  var Utils = require_utils2();\n  function getColorAttrib(color, attrib) {\n    const alpha = color.a / 255;\n    const str = attrib + '=\"' + color.hex + '\"';\n    return alpha < 1 ? str + \" \" + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"' : str;\n  }\n  function svgCmd(cmd, x, y) {\n    let str = cmd + x;\n    if (typeof y !== \"undefined\") str += \" \" + y;\n    return str;\n  }\n  function qrToPath(data, size, margin) {\n    let path = \"\";\n    let moveBy = 0;\n    let newRow = false;\n    let lineLength = 0;\n    for (let i = 0; i < data.length; i++) {\n      const col = Math.floor(i % size);\n      const row = Math.floor(i / size);\n      if (!col && !newRow) newRow = true;\n      if (data[i]) {\n        lineLength++;\n        if (!(i > 0 && col > 0 && data[i - 1])) {\n          path += newRow ? svgCmd(\"M\", col + margin, 0.5 + row + margin) : svgCmd(\"m\", moveBy, 0);\n          moveBy = 0;\n          newRow = false;\n        }\n        if (!(col + 1 < size && data[i + 1])) {\n          path += svgCmd(\"h\", lineLength);\n          lineLength = 0;\n        }\n      } else {\n        moveBy++;\n      }\n    }\n    return path;\n  }\n  exports.render = function render(qrData, options, cb) {\n    const opts = Utils.getOptions(options);\n    const size = qrData.modules.size;\n    const data = qrData.modules.data;\n    const qrcodesize = size + opts.margin * 2;\n    const bg = !opts.color.light.a ? \"\" : \"<path \" + getColorAttrib(opts.color.light, \"fill\") + ' d=\"M0 0h' + qrcodesize + \"v\" + qrcodesize + 'H0z\"/>';\n    const path = \"<path \" + getColorAttrib(opts.color.dark, \"stroke\") + ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>';\n    const viewBox = 'viewBox=\"' + \"0 0 \" + qrcodesize + \" \" + qrcodesize + '\"';\n    const width = !opts.width ? \"\" : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" ';\n    const svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + \"</svg>\\n\";\n    if (typeof cb === \"function\") {\n      cb(null, svgTag);\n    }\n    return svgTag;\n  };\n});\n\n// node_modules/qrcode/lib/browser.js\nvar require_browser = __commonJS(exports => {\n  var canPromise = require_can_promise();\n  var QRCode = require_qrcode();\n  var CanvasRenderer = require_canvas();\n  var SvgRenderer = require_svg_tag();\n  function renderCanvas(renderFunc, canvas, text, opts, cb) {\n    const args = [].slice.call(arguments, 1);\n    const argsNum = args.length;\n    const isLastArgCb = typeof args[argsNum - 1] === \"function\";\n    if (!isLastArgCb && !canPromise()) {\n      throw new Error(\"Callback required as last argument\");\n    }\n    if (isLastArgCb) {\n      if (argsNum < 2) {\n        throw new Error(\"Too few arguments provided\");\n      }\n      if (argsNum === 2) {\n        cb = text;\n        text = canvas;\n        canvas = opts = undefined;\n      } else if (argsNum === 3) {\n        if (canvas.getContext && typeof cb === \"undefined\") {\n          cb = opts;\n          opts = undefined;\n        } else {\n          cb = opts;\n          opts = text;\n          text = canvas;\n          canvas = undefined;\n        }\n      }\n    } else {\n      if (argsNum < 1) {\n        throw new Error(\"Too few arguments provided\");\n      }\n      if (argsNum === 1) {\n        text = canvas;\n        canvas = opts = undefined;\n      } else if (argsNum === 2 && !canvas.getContext) {\n        opts = text;\n        text = canvas;\n        canvas = undefined;\n      }\n      return new Promise(function (resolve, reject) {\n        try {\n          const data = QRCode.create(text, opts);\n          resolve(renderFunc(data, canvas, opts));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }\n    try {\n      const data = QRCode.create(text, opts);\n      cb(null, renderFunc(data, canvas, opts));\n    } catch (e) {\n      cb(e);\n    }\n  }\n  exports.create = QRCode.create;\n  exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);\n  exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);\n  exports.toString = renderCanvas.bind(null, function (data, _, opts) {\n    return SvgRenderer.render(data, opts);\n  });\n});\n\n// src/index.ts\nvar import_qrcode = __toESM(require_browser(), 1);\n\n// src/errors.ts\nclass RequestTimeoutError extends Error {\n  constructor(timeout) {\n    super(\"Request timed out after \".concat(timeout, \"ms.\"));\n  }\n}\nclass RejectRequestError extends Error {\n  constructor() {\n    super(\"Request was rejected by the wallet.\");\n  }\n}\nclass UnauthorizedError extends Error {\n  constructor(code) {\n    super(code || \"Unauthorized\");\n    _defineProperty(this, \"code\", void 0);\n    this.code = code;\n  }\n}\nvar UNAUTH_CODES = new Set([\"UNAUTHENTICATED\", \"UNAUTHORIZED\", \"SESSION_EXPIRED\", \"LOGGED_OUT\"]);\nfunction extractErrorCode(message) {\n  var _message$error;\n  if (typeof (message === null || message === void 0 || (_message$error = message.error) === null || _message$error === void 0 ? void 0 : _message$error.code) === \"string\" && message.error.code.length > 0) {\n    return message.error.code;\n  }\n  if ((message === null || message === void 0 ? void 0 : message.type) === \"unauthorized\" && typeof (message === null || message === void 0 ? void 0 : message.code) === \"string\") {\n    return message.code;\n  }\n  return null;\n}\nfunction isUnauthCode(code) {\n  if (!code) {\n    return false;\n  }\n  return UNAUTH_CODES.has(code);\n}\n\n// src/connection.ts\nclass Connection {\n  constructor(_ref) {\n    let {\n      network,\n      walletUrl,\n      apiUrl\n    } = _ref;\n    _defineProperty(this, \"walletUrl\", \"https://cantonloop.com\");\n    _defineProperty(this, \"apiUrl\", \"https://cantonloop.com\");\n    _defineProperty(this, \"ws\", null);\n    _defineProperty(this, \"network\", \"main\");\n    _defineProperty(this, \"ticketId\", null);\n    _defineProperty(this, \"onMessageHandler\", null);\n    _defineProperty(this, \"reconnectPromise\", null);\n    _defineProperty(this, \"status\", \"disconnected\");\n    this.network = network || \"main\";\n    switch (this.network) {\n      case \"local\":\n        this.walletUrl = \"http://localhost:3000\";\n        this.apiUrl = \"http://localhost:8080\";\n        break;\n      case \"devnet\":\n      case \"dev\":\n        this.walletUrl = \"https://devnet.cantonloop.com\";\n        this.apiUrl = \"https://devnet.cantonloop.com\";\n        break;\n      case \"testnet\":\n      case \"test\":\n        this.walletUrl = \"https://testnet.cantonloop.com\";\n        this.apiUrl = \"https://testnet.cantonloop.com\";\n        break;\n      case \"mainnet\":\n      case \"main\":\n        this.walletUrl = \"https://cantonloop.com\";\n        this.apiUrl = \"https://cantonloop.com\";\n        break;\n    }\n    if (walletUrl) {\n      this.walletUrl = walletUrl;\n    }\n    if (apiUrl) {\n      this.apiUrl = apiUrl;\n    }\n  }\n  connectInProgress() {\n    return this.status === \"connecting\" || this.status === \"connected\";\n  }\n  async getTicket(appName, sessionId, version) {\n    const response = await fetch(\"\".concat(this.apiUrl, \"/api/v1/.connect/pair/tickets\"), {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        app_name: appName,\n        session_id: sessionId,\n        version\n      })\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to get ticket from server.\");\n    }\n    return response.json();\n  }\n  async getHolding(authToken) {\n    const response = await fetch(\"\".concat(this.apiUrl, \"/api/v1/.connect/pair/account/holding\"), {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(authToken)\n      }\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to get holdings.\");\n    }\n    return response.json();\n  }\n  async getActiveContracts(authToken, params) {\n    const url = new URL(\"\".concat(this.apiUrl, \"/api/v1/.connect/pair/account/active-contracts\"));\n    if (params !== null && params !== void 0 && params.templateId) {\n      url.searchParams.append(\"templateId\", params.templateId);\n    }\n    if (params !== null && params !== void 0 && params.interfaceId) {\n      url.searchParams.append(\"interfaceId\", params.interfaceId);\n    }\n    const response = await fetch(url.toString(), {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(authToken)\n      }\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to get active contracts.\");\n    }\n    return response.json();\n  }\n  async prepareTransfer(authToken, params) {\n    const payload = {\n      recipient: params.recipient,\n      amount: params.amount\n    };\n    if (params.instrument) {\n      if (params.instrument.instrument_admin) {\n        payload.instrument_admin = params.instrument.instrument_admin;\n      }\n      if (params.instrument.instrument_id) {\n        payload.instrument_id = params.instrument.instrument_id;\n      }\n    }\n    if (params.requested_at) {\n      payload.requested_at = params.requested_at;\n    }\n    if (params.execute_before) {\n      payload.execute_before = params.execute_before;\n    }\n    if (params.memo) {\n      payload.memo = params.memo;\n    }\n    const response = await fetch(\"\".concat(this.apiUrl, \"/api/v1/.connect/pair/transfer\"), {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(authToken)\n      },\n      body: JSON.stringify(payload)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to prepare transfer.\");\n    }\n    const data = await response.json();\n    return data.payload;\n  }\n  async verifySession(authToken) {\n    const response = await fetch(\"\".concat(this.apiUrl, \"/api/v1/.connect/pair/account\"), {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(authToken)\n      }\n    });\n    if (!response.ok) {\n      if (response.status === 401 || response.status === 403) {\n        throw new UnauthorizedError();\n      }\n      throw new Error(\"Session verification failed with status \".concat(response.status, \".\"));\n    }\n    const data = await response.json();\n    const email = data === null || data === void 0 ? void 0 : data.email;\n    if (!(data !== null && data !== void 0 && data.party_id) || !(data !== null && data !== void 0 && data.public_key)) {\n      throw new Error(\"Invalid session verification response.\");\n    }\n    const account = {\n      party_id: data === null || data === void 0 ? void 0 : data.party_id,\n      auth_token: authToken,\n      public_key: data === null || data === void 0 ? void 0 : data.public_key,\n      email,\n      has_preapproval: data === null || data === void 0 ? void 0 : data.has_preapproval,\n      has_merge_delegation: data === null || data === void 0 ? void 0 : data.has_merge_delegation,\n      usdc_bridge_access: data === null || data === void 0 ? void 0 : data.usdc_bridge_access\n    };\n    return account;\n  }\n  connectWebSocket(ticketId, onMessage) {\n    if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) && this.ticketId !== ticketId) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.status === \"connecting\" || this.status === \"connected\") {\n      return;\n    }\n    this.onMessageHandler = onMessage;\n    this.ticketId = ticketId;\n    this.status = \"connecting\";\n    this.attachWebSocket(ticketId, onMessage);\n  }\n  reconnect() {\n    if (!this.ticketId || !this.onMessageHandler) {\n      return Promise.reject(new Error(\"Cannot reconnect without a known ticket.\"));\n    }\n    return new Promise((resolve, reject) => {\n      let opened = false;\n      this.attachWebSocket(this.ticketId, this.onMessageHandler, () => {\n        opened = true;\n        resolve();\n      }, () => {\n        if (opened) {\n          return;\n        }\n        reject(new Error(\"Failed to reconnect to ticket server.\"));\n      }, () => {\n        if (opened) {\n          return;\n        }\n        reject(new Error(\"Failed to reconnect to ticket server.\"));\n      });\n    });\n  }\n  websocketUrl(ticketId) {\n    return \"\".concat(this.network === \"local\" ? \"ws\" : \"wss\", \"://\").concat(this.apiUrl.replace(\"https://\", \"\").replace(\"http://\", \"\"), \"/api/v1/.connect/pair/ws/\").concat(encodeURIComponent(ticketId));\n  }\n  attachWebSocket(ticketId, onMessage, onOpen, onError, onClose) {\n    const wsUrl = this.websocketUrl(ticketId);\n    const ws = new WebSocket(wsUrl);\n    ws.onmessage = onMessage;\n    ws.onopen = () => {\n      this.status = \"connected\";\n      console.log(\"[LoopSDK] Connected to ticket server.\");\n      onOpen === null || onOpen === void 0 || onOpen();\n    };\n    ws.onclose = event => {\n      this.status = \"disconnected\";\n      if (this.ws === ws) {\n        this.ws = null;\n      }\n      console.log(\"[LoopSDK] Disconnected from ticket server.\");\n      onClose === null || onClose === void 0 || onClose(event);\n    };\n    ws.onerror = event => {\n      this.status = \"disconnected\";\n      ws.close();\n      if (this.ws === ws) {\n        this.ws = null;\n      }\n      onError === null || onError === void 0 || onError(event);\n    };\n    this.ws = ws;\n  }\n}\n\n// src/types.ts\nvar MessageType;\n(MessageType2 => {\n  MessageType2[\"HANDSHAKE_ACCEPT\"] = \"handshake_accept\";\n  MessageType2[\"HANDSHAKE_REJECT\"] = \"handshake_reject\";\n  MessageType2[\"RUN_TRANSACTION\"] = \"run_transaction\";\n  MessageType2[\"TRANSACTION_COMPLETED\"] = \"transaction_completed\";\n  MessageType2[\"SIGN_RAW_MESSAGE\"] = \"sign_raw_message\";\n  MessageType2[\"SIGN_RAW_MESSAGE_RESPONSE\"] = \"sign_raw_message_response\";\n  MessageType2[\"REJECT_REQUEST\"] = \"reject_request\";\n})(MessageType || (MessageType = {}));\n\n// src/provider.ts\nvar DEFAULT_REQUEST_TIMEOUT_MS = 300000;\nfunction generateUUID() {\n  return \"10000000-1000-4000-8000-100000000000\".replace(/[018]/g, c => {\n    const gCrypto = globalThis.crypto;\n    if (!(gCrypto !== null && gCrypto !== void 0 && gCrypto.getRandomValues)) {\n      const n2 = Number(c);\n      return (n2 ^ Math.random() * 16 >> n2 / 4).toString(16);\n    }\n    const arr = gCrypto.getRandomValues(new Uint8Array(1));\n    const byte = arr[0];\n    const n = Number(c);\n    return (n ^ (byte & 15) >> n / 4).toString(16);\n  });\n}\nfunction generateRequestId() {\n  const gCrypto = globalThis.crypto;\n  if (gCrypto !== null && gCrypto !== void 0 && gCrypto.randomUUID) {\n    return gCrypto.randomUUID();\n  }\n  return generateUUID();\n}\nclass Provider {\n  constructor(_ref2) {\n    let {\n      connection,\n      party_id,\n      public_key,\n      auth_token,\n      email,\n      hooks\n    } = _ref2;\n    _defineProperty(this, \"connection\", void 0);\n    _defineProperty(this, \"party_id\", void 0);\n    _defineProperty(this, \"public_key\", void 0);\n    _defineProperty(this, \"email\", void 0);\n    _defineProperty(this, \"auth_token\", void 0);\n    _defineProperty(this, \"requests\", new Map());\n    _defineProperty(this, \"requestTimeout\", DEFAULT_REQUEST_TIMEOUT_MS);\n    _defineProperty(this, \"hooks\", void 0);\n    if (!connection) {\n      throw new Error(\"Provider requires a connection object.\");\n    }\n    this.connection = connection;\n    this.party_id = party_id;\n    this.public_key = public_key;\n    this.email = email;\n    this.auth_token = auth_token;\n    this.hooks = hooks;\n  }\n  getAuthToken() {\n    return this.auth_token;\n  }\n  handleResponse(message) {\n    var _message$payload, _message$payload2, _message$payload3;\n    console.log(\"Received response:\", message);\n    if ((message === null || message === void 0 ? void 0 : message.type) === \"transaction_completed\" /* TRANSACTION_COMPLETED */ && (message !== null && message !== void 0 && (_message$payload = message.payload) !== null && _message$payload !== void 0 && _message$payload.update_id || message !== null && message !== void 0 && (_message$payload2 = message.payload) !== null && _message$payload2 !== void 0 && _message$payload2.update_data || message !== null && message !== void 0 && (_message$payload3 = message.payload) !== null && _message$payload3 !== void 0 && _message$payload3.status)) {\n      var _message$payload4, _this$hooks, _this$hooks$onTransac;\n      if (message !== null && message !== void 0 && (_message$payload4 = message.payload) !== null && _message$payload4 !== void 0 && _message$payload4.error_message) {\n        message.payload.error = {\n          error_message: message.payload.error_message\n        };\n        delete message.payload.error_message;\n      }\n      (_this$hooks = this.hooks) === null || _this$hooks === void 0 || (_this$hooks$onTransac = _this$hooks.onTransactionUpdate) === null || _this$hooks$onTransac === void 0 || _this$hooks$onTransac.call(_this$hooks, message.payload, message);\n    }\n    if (message.request_id) {\n      this.requests.set(message.request_id, message);\n    }\n  }\n  getHolding() {\n    return this.connection.getHolding(this.auth_token);\n  }\n  getAccount() {\n    return this.connection.verifySession(this.auth_token);\n  }\n  getActiveContracts(params) {\n    return this.connection.getActiveContracts(this.auth_token, params);\n  }\n  async submitTransaction(payload, options) {\n    const requestPayload = options !== null && options !== void 0 && options.estimateTraffic ? _objectSpread(_objectSpread({}, payload), {}, {\n      estimate_traffic: true\n    }) : payload;\n    return this.sendRequest(\"run_transaction\" /* RUN_TRANSACTION */, requestPayload, options);\n  }\n  async submitAndWaitForTransaction(payload, options) {\n    const requestPayload = options !== null && options !== void 0 && options.estimateTraffic ? _objectSpread(_objectSpread({}, payload), {}, {\n      estimateTraffic: true\n    }) : payload;\n    return this.sendRequest(\"run_transaction\" /* RUN_TRANSACTION */, _objectSpread(_objectSpread({}, requestPayload), {}, {\n      execution_mode: \"wait\"\n    }), options);\n  }\n  async transfer(recipient, amount, instrument, options) {\n    const amountStr = typeof amount === \"number\" ? amount.toString() : amount;\n    const {\n      requestedAt,\n      executeBefore,\n      requestTimeout,\n      estimateTraffic,\n      memo\n    } = options || {};\n    const message = options === null || options === void 0 ? void 0 : options.message;\n    const resolveDate = (value, fallbackMs) => {\n      if (value instanceof Date) {\n        return value.toISOString();\n      }\n      if (typeof value === \"string\" && value.length > 0) {\n        return value;\n      }\n      if (fallbackMs) {\n        return new Date(Date.now() + fallbackMs).toISOString();\n      }\n      return new Date().toISOString();\n    };\n    const requestedAtIso = resolveDate(requestedAt);\n    const executeBeforeIso = resolveDate(executeBefore, 24 * 60 * 60 * 1000);\n    const transferRequest = {\n      recipient,\n      amount: amountStr,\n      instrument: {\n        instrument_admin: instrument === null || instrument === void 0 ? void 0 : instrument.instrument_admin,\n        instrument_id: (instrument === null || instrument === void 0 ? void 0 : instrument.instrument_id) || \"Amulet\"\n      },\n      requested_at: requestedAtIso,\n      execute_before: executeBeforeIso\n    };\n    if (memo) {\n      transferRequest.memo = memo;\n    }\n    const preparedPayload = await this.connection.prepareTransfer(this.auth_token, transferRequest);\n    const submitFn = (options === null || options === void 0 ? void 0 : options.executionMode) === \"wait\" ? this.submitAndWaitForTransaction.bind(this) : this.submitTransaction.bind(this);\n    return submitFn({\n      commands: preparedPayload.commands,\n      disclosedContracts: preparedPayload.disclosedContracts,\n      packageIdSelectionPreference: preparedPayload.packageIdSelectionPreference,\n      actAs: preparedPayload.actAs,\n      readAs: preparedPayload.readAs,\n      synchronizerId: preparedPayload.synchronizerId\n    }, {\n      requestTimeout,\n      message,\n      estimateTraffic\n    });\n  }\n  async signMessage(message) {\n    return this.sendRequest(\"sign_raw_message\" /* SIGN_RAW_MESSAGE */, message);\n  }\n  async ensureConnected() {\n    if (this.connection.ws && this.connection.ws.readyState === WebSocket.OPEN) {\n      return Promise.resolve();\n    }\n    await this.connection.reconnect();\n    if (this.connection.ws && this.connection.ws.readyState === WebSocket.OPEN) {\n      return;\n    }\n    throw new Error(\"Not connected.\");\n  }\n  sendRequest(messageType) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options = arguments.length > 2 ? arguments[2] : undefined;\n    return new Promise((resolve, reject) => {\n      const requestId = generateRequestId();\n      let requestContext;\n      const ensure = async () => {\n        var _options$requestTimeo;\n        try {\n          var _this$hooks2, _this$hooks2$onReques;\n          await this.ensureConnected();\n          requestContext = await ((_this$hooks2 = this.hooks) === null || _this$hooks2 === void 0 || (_this$hooks2$onReques = _this$hooks2.onRequestStart) === null || _this$hooks2$onReques === void 0 ? void 0 : _this$hooks2$onReques.call(_this$hooks2, messageType, options === null || options === void 0 ? void 0 : options.requestLabel));\n        } catch (error) {\n          var _this$hooks3, _this$hooks3$onReques;\n          console.error(\"[LoopSDK] error when checking connection status\", error);\n          (_this$hooks3 = this.hooks) === null || _this$hooks3 === void 0 || (_this$hooks3$onReques = _this$hooks3.onRequestFinish) === null || _this$hooks3$onReques === void 0 || _this$hooks3$onReques.call(_this$hooks3, {\n            status: \"error\",\n            messageType,\n            requestLabel: options === null || options === void 0 ? void 0 : options.requestLabel,\n            requestContext\n          });\n          reject(error);\n          return;\n        }\n        const requestBody = {\n          request_id: requestId,\n          type: messageType,\n          payload: params\n        };\n        if (options !== null && options !== void 0 && options.message) {\n          requestBody.ticket = {\n            message: options.message\n          };\n          if (typeof params === \"object\" && params !== null && !Array.isArray(params)) {\n            requestBody.payload = _objectSpread(_objectSpread({}, params), {}, {\n              ticket: {\n                message: options.message\n              }\n            });\n          }\n        }\n        try {\n          this.connection.ws.send(JSON.stringify(requestBody));\n        } catch (error) {\n          console.error(\"[LoopSDK] error when sending request\", error);\n          reject(error);\n          return;\n        }\n        const intervalTime = 300;\n        let elapsedTime = 0;\n        const timeoutMs = (_options$requestTimeo = options === null || options === void 0 ? void 0 : options.requestTimeout) !== null && _options$requestTimeo !== void 0 ? _options$requestTimeo : this.requestTimeout;\n        const intervalId = setInterval(() => {\n          const response = this.requests.get(requestId);\n          if (response) {\n            clearInterval(intervalId);\n            this.requests.delete(requestId);\n            const code = extractErrorCode(response);\n            if (isUnauthCode(code)) {\n              var _this$hooks4, _this$hooks4$onReques;\n              (_this$hooks4 = this.hooks) === null || _this$hooks4 === void 0 || (_this$hooks4$onReques = _this$hooks4.onRequestFinish) === null || _this$hooks4$onReques === void 0 || _this$hooks4$onReques.call(_this$hooks4, {\n                status: \"error\",\n                messageType,\n                requestLabel: options === null || options === void 0 ? void 0 : options.requestLabel,\n                requestContext,\n                errorCode: code\n              });\n              reject(new UnauthorizedError(code));\n              return;\n            }\n            if (response.type === \"reject_request\" /* REJECT_REQUEST */) {\n              var _this$hooks5, _this$hooks5$onReques;\n              (_this$hooks5 = this.hooks) === null || _this$hooks5 === void 0 || (_this$hooks5$onReques = _this$hooks5.onRequestFinish) === null || _this$hooks5$onReques === void 0 || _this$hooks5$onReques.call(_this$hooks5, {\n                status: \"rejected\",\n                messageType,\n                requestLabel: options === null || options === void 0 ? void 0 : options.requestLabel,\n                requestContext\n              });\n              reject(new RejectRequestError());\n            } else {\n              var _this$hooks6, _this$hooks6$onReques;\n              (_this$hooks6 = this.hooks) === null || _this$hooks6 === void 0 || (_this$hooks6$onReques = _this$hooks6.onRequestFinish) === null || _this$hooks6$onReques === void 0 || _this$hooks6$onReques.call(_this$hooks6, {\n                status: \"success\",\n                messageType,\n                requestLabel: options === null || options === void 0 ? void 0 : options.requestLabel,\n                requestContext\n              });\n              resolve(response.payload);\n            }\n          } else {\n            elapsedTime += intervalTime;\n            if (elapsedTime >= timeoutMs) {\n              var _this$hooks7, _this$hooks7$onReques;\n              clearInterval(intervalId);\n              this.requests.delete(requestId);\n              (_this$hooks7 = this.hooks) === null || _this$hooks7 === void 0 || (_this$hooks7$onReques = _this$hooks7.onRequestFinish) === null || _this$hooks7$onReques === void 0 || _this$hooks7$onReques.call(_this$hooks7, {\n                status: \"timeout\",\n                messageType,\n                requestLabel: options === null || options === void 0 ? void 0 : options.requestLabel,\n                requestContext\n              });\n              reject(new RequestTimeoutError(timeoutMs));\n            }\n          }\n        }, intervalTime);\n      };\n      ensure();\n    });\n  }\n}\n\n// src/session.ts\nvar STORAGE_KEY_LOOP_CONNECT = \"loop_connect\";\nclass SessionInfo {\n  constructor(_ref3) {\n    let {\n      sessionId,\n      ticketId,\n      authToken,\n      partyId,\n      publicKey,\n      email\n    } = _ref3;\n    _defineProperty(this, \"sessionId\", void 0);\n    _defineProperty(this, \"ticketId\", void 0);\n    _defineProperty(this, \"authToken\", void 0);\n    _defineProperty(this, \"partyId\", void 0);\n    _defineProperty(this, \"publicKey\", void 0);\n    _defineProperty(this, \"email\", void 0);\n    _defineProperty(this, \"_isAuthorized\", false);\n    this.sessionId = sessionId;\n    this.ticketId = ticketId;\n    this.authToken = authToken;\n    this.partyId = partyId;\n    this.publicKey = publicKey;\n    this.email = email;\n  }\n  setTicketId(ticketId) {\n    this.ticketId = ticketId;\n    this.save();\n  }\n  authorized() {\n    if (this.ticketId === undefined || this.sessionId === undefined || this.authToken === undefined || this.partyId === undefined || this.publicKey === undefined) {\n      throw new Error(\"Session cannot be authorized without all required fields.\");\n    }\n    this._isAuthorized = true;\n  }\n  isPreAuthorized() {\n    return !this._isAuthorized && this.ticketId !== undefined && this.sessionId !== undefined && this.authToken !== undefined && this.partyId !== undefined && this.publicKey !== undefined;\n  }\n  isAuthorized() {\n    return this._isAuthorized;\n  }\n  save() {\n    localStorage.setItem(\"loop_connect\", this.toJson());\n  }\n  reset() {\n    localStorage.removeItem(STORAGE_KEY_LOOP_CONNECT);\n    this.sessionId = generateRequestId();\n    this._isAuthorized = false;\n    this.ticketId = undefined;\n    this.authToken = undefined;\n    this.partyId = undefined;\n    this.publicKey = undefined;\n    this.email = undefined;\n  }\n  static fromStorage() {\n    const existingConnectionRaw = localStorage.getItem(STORAGE_KEY_LOOP_CONNECT);\n    if (!existingConnectionRaw) {\n      return new SessionInfo({\n        sessionId: generateRequestId()\n      });\n    }\n    let session = null;\n    try {\n      session = new SessionInfo(JSON.parse(existingConnectionRaw));\n    } catch (error) {\n      console.error(\"Failed to parse existing connection info, local storage is corrupted.\", error);\n      localStorage.removeItem(STORAGE_KEY_LOOP_CONNECT);\n      session = new SessionInfo({\n        sessionId: generateRequestId()\n      });\n    }\n    return session;\n  }\n  toJson() {\n    return JSON.stringify({\n      sessionId: this.sessionId,\n      ticketId: this.ticketId,\n      authToken: this.authToken,\n      partyId: this.partyId,\n      publicKey: this.publicKey,\n      email: this.email\n    });\n  }\n}\n\n// src/extensions/usdc/index.ts\nclass UsdcBridge {\n  constructor(getProvider) {\n    _defineProperty(this, \"getProvider\", void 0);\n    this.getProvider = getProvider;\n  }\n  requireProvider() {\n    const provider = this.getProvider();\n    if (!provider) {\n      throw new Error(\"SDK not connected. Call connect() and wait for acceptance first.\");\n    }\n    return provider;\n  }\n  withdrawalUSDCxToEthereum(recipient, amount, options) {\n    const provider = this.requireProvider();\n    const amountStr = typeof amount === \"number\" ? amount.toString() : amount;\n    const withdrawRequest = {\n      recipient,\n      amount: amountStr,\n      reference: options === null || options === void 0 ? void 0 : options.reference\n    };\n    return prepareUsdcWithdraw(provider.connection, provider.getAuthToken(), withdrawRequest).then(preparedPayload => provider.submitTransaction({\n      commands: preparedPayload.commands,\n      disclosedContracts: preparedPayload.disclosedContracts,\n      packageIdSelectionPreference: preparedPayload.packageIdSelectionPreference,\n      actAs: preparedPayload.actAs,\n      readAs: preparedPayload.readAs,\n      synchronizerId: preparedPayload.synchronizerId\n    }, {\n      requestTimeout: options === null || options === void 0 ? void 0 : options.requestTimeout,\n      message: options === null || options === void 0 ? void 0 : options.message\n    }));\n  }\n}\nasync function prepareUsdcWithdraw(connection, authToken, params) {\n  const payload = {\n    recipient: params.recipient,\n    amount: params.amount\n  };\n  if (params.reference) {\n    payload.reference = params.reference;\n  }\n  const response = await fetch(\"\".concat(connection.apiUrl, \"/api/v1/.connect/pair/usdc/withdraw\"), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: \"Bearer \".concat(authToken)\n    },\n    body: JSON.stringify(payload)\n  });\n  if (!response.ok) {\n    throw new Error(\"Failed to prepare USDC withdrawal.\");\n  }\n  const data = await response.json();\n  return data.payload;\n}\n\n// src/wallet.ts\nclass LoopWallet {\n  constructor(getProvider) {\n    _defineProperty(this, \"getProvider\", void 0);\n    _defineProperty(this, \"extension\", void 0);\n    this.getProvider = getProvider;\n    this.extension = {\n      usdcBridge: new UsdcBridge(this.getProvider)\n    };\n  }\n  requireProvider() {\n    const provider = this.getProvider();\n    if (!provider) {\n      throw new Error(\"SDK not connected. Call connect() and wait for acceptance first.\");\n    }\n    return provider;\n  }\n  transfer(recipient, amount, instrument, options) {\n    const provider = this.requireProvider();\n    return provider.transfer(recipient, amount, instrument, options);\n  }\n}\n\n// src/index.ts\nclass LoopSDK {\n  constructor() {\n    _defineProperty(this, \"version\", \"0.7.6\");\n    _defineProperty(this, \"appName\", \"Unknown\");\n    _defineProperty(this, \"connection\", null);\n    _defineProperty(this, \"session\", null);\n    _defineProperty(this, \"provider\", null);\n    _defineProperty(this, \"openMode\", \"popup\");\n    _defineProperty(this, \"requestSigningMode\", \"popup\");\n    _defineProperty(this, \"popupWindow\", null);\n    _defineProperty(this, \"redirectUrl\", void 0);\n    _defineProperty(this, \"onAccept\", null);\n    _defineProperty(this, \"onReject\", null);\n    _defineProperty(this, \"onTransactionUpdate\", null);\n    _defineProperty(this, \"overlay\", null);\n    _defineProperty(this, \"wallet\", void 0);\n    this.wallet = new LoopWallet(() => this.provider);\n  }\n  init(_ref4) {\n    let {\n      appName,\n      network,\n      walletUrl,\n      apiUrl,\n      onAccept,\n      onReject,\n      onTransactionUpdate,\n      options\n    } = _ref4;\n    if (typeof window === \"undefined\" || typeof document === \"undefined\" || typeof localStorage === \"undefined\") {\n      throw new Error(\"LoopSDK can only be initialized in a browser environment with localStorage support.\");\n    }\n    this.appName = appName;\n    this.onAccept = onAccept || null;\n    this.onReject = onReject || null;\n    this.onTransactionUpdate = onTransactionUpdate || null;\n    const resolvedOptions = _objectSpread({\n      openMode: \"popup\",\n      requestSigningMode: \"popup\",\n      redirectUrl: undefined\n    }, options !== null && options !== void 0 ? options : {});\n    this.openMode = resolvedOptions.openMode;\n    this.requestSigningMode = resolvedOptions.requestSigningMode;\n    this.redirectUrl = resolvedOptions.redirectUrl;\n    this.connection = new Connection({\n      network,\n      walletUrl,\n      apiUrl\n    });\n  }\n  async loadSessionInfo() {\n    if (this.session) {\n      return;\n    }\n    this.session = SessionInfo.fromStorage();\n    if (!this.session.isPreAuthorized()) {\n      return;\n    }\n    try {\n      var _this$connection;\n      const verifiedAccount = await ((_this$connection = this.connection) === null || _this$connection === void 0 ? void 0 : _this$connection.verifySession(this.session.authToken));\n      if (!verifiedAccount || (verifiedAccount === null || verifiedAccount === void 0 ? void 0 : verifiedAccount.party_id) !== this.session.partyId) {\n        console.warn(\"[LoopSDK] Stored partyId does not match verified account. Clearing cached session.\");\n        this.logout();\n        return;\n      }\n      this.session.authorized();\n    } catch (err) {\n      if (err instanceof UnauthorizedError) {\n        console.error(\"Unauthorized error when verifying session.\", err);\n        this.session.reset();\n        return;\n      }\n      console.error(\"[LoopSDK] Failed to verify session.\", err);\n      throw err;\n    }\n  }\n  async autoConnect() {\n    if (!this.connection) {\n      throw new Error(\"SDK not initialized. Call init() first.\");\n    }\n    await this.loadSessionInfo();\n    if (!this.session) {\n      throw new Error(\"No valid session found. The network connection maynot available or the backend is not reachable.\");\n    }\n    if (this.session.isAuthorized()) {\n      var _this$onAccept;\n      this.provider = new Provider({\n        connection: this.connection,\n        party_id: this.session.partyId,\n        auth_token: this.session.authToken,\n        public_key: this.session.publicKey,\n        email: this.session.email,\n        hooks: this.createProviderHooks()\n      });\n      (_this$onAccept = this.onAccept) === null || _this$onAccept === void 0 || _this$onAccept.call(this, this.provider);\n      this.connection.connectWebSocket(this.session.ticketId, this.handleWebSocketMessage.bind(this));\n      return Promise.resolve();\n    }\n  }\n  async connect() {\n    if (!this.connection) {\n      throw new Error(\"SDK not initialized. Call init() first.\");\n    }\n    await this.autoConnect();\n    if (!this.session) {\n      throw new Error(\"No valid session found. The network connection maynot available or the backend is not reachable.\");\n    }\n    if (this.session.isAuthorized()) {\n      return;\n    }\n    try {\n      if (!this.session.ticketId) {\n        const {\n          ticket_id: ticketId\n        } = await this.connection.getTicket(this.appName, this.session.sessionId, this.version);\n        this.session.setTicketId(ticketId);\n      }\n      if (!this.connection.connectInProgress()) {\n        this.connection.connectWebSocket(this.session.ticketId, this.handleWebSocketMessage.bind(this));\n      }\n      this.showQrCode(this.buildConnectUrl(this.session.ticketId));\n    } catch (error) {\n      console.error(error);\n      throw error;\n    }\n  }\n  handleWebSocketMessage(event) {\n    const message = JSON.parse(event.data);\n    const errCode = extractErrorCode(message);\n    if (isUnauthCode(errCode)) {\n      console.warn(\"[LoopSDK] Detected session invalidation:\", errCode, {\n        message\n      });\n      this.logout();\n      return;\n    }\n    console.log(\"[LoopSDK] WS message received:\", message);\n    if (message.type === \"handshake_accept\" /* HANDSHAKE_ACCEPT */) {\n      console.log(\"[LoopSDK] Entering HANDSHAKE_ACCEPT flow\");\n      const {\n        authToken,\n        partyId,\n        publicKey,\n        email\n      } = message.payload || {};\n      if (authToken && partyId && publicKey) {\n        this.provider = new Provider({\n          connection: this.connection,\n          party_id: partyId,\n          auth_token: authToken,\n          public_key: publicKey,\n          email,\n          hooks: this.createProviderHooks()\n        });\n        try {\n          var _this$onAccept2;\n          this.session.authToken = authToken;\n          this.session.partyId = partyId;\n          this.session.publicKey = publicKey;\n          this.session.email = email;\n          this.session.authorized();\n          this.session.save();\n          (_this$onAccept2 = this.onAccept) === null || _this$onAccept2 === void 0 || _this$onAccept2.call(this, this.provider);\n          this.hideQrCode();\n          console.log(\"[LoopSDK] HANDSHAKE_ACCEPT: closing popup (if exists)\");\n          this.popupWindow = null;\n        } catch (error) {\n          console.error(\"Failed to update local storage with auth token.\", error);\n        }\n      }\n    } else if (message.type === \"handshake_reject\" /* HANDSHAKE_REJECT */) {\n      var _this$connection2, _this$onReject, _this$session;\n      console.log(\"[LoopSDK] Entering HANDSHAKE_REJECT flow\");\n      (_this$connection2 = this.connection) === null || _this$connection2 === void 0 || (_this$connection2 = _this$connection2.ws) === null || _this$connection2 === void 0 || _this$connection2.close();\n      (_this$onReject = this.onReject) === null || _this$onReject === void 0 || _this$onReject.call(this);\n      this.hideQrCode();\n      (_this$session = this.session) === null || _this$session === void 0 || _this$session.reset();\n      console.log(\"[LoopSDK] HANDSHAKE_REJECT: closing popup (if exists)\");\n      this.popupWindow = null;\n    } else if (this.provider) {\n      this.provider.handleResponse(message);\n    }\n  }\n  getConnectUrl() {\n    var _this$session2;\n    if (!((_this$session2 = this.session) !== null && _this$session2 !== void 0 && _this$session2.ticketId)) {\n      throw new Error(\"No ticket ID found. Please call connect() first.\");\n    }\n    return this.buildConnectUrl(this.session.ticketId);\n  }\n  buildConnectUrl(ticketId) {\n    const url = new URL(\"/.connect/\", this.connection.walletUrl);\n    url.searchParams.set(\"ticketId\", ticketId);\n    if (this.redirectUrl) {\n      url.searchParams.set(\"redirectUrl\", this.redirectUrl);\n    }\n    return url.toString();\n  }\n  buildDashboardUrl() {\n    if (!this.connection) {\n      throw new Error(\"Connection not initialized\");\n    }\n    return this.connection.walletUrl;\n  }\n  openRequestUi() {\n    var _this$session3;\n    if (typeof window === \"undefined\") {\n      return null;\n    }\n    if (!((_this$session3 = this.session) !== null && _this$session3 !== void 0 && _this$session3.ticketId)) {\n      console.warn(\"[LoopSDK] Cannot open wallet UI for request: no active ticket.\");\n      return null;\n    }\n    const dashboardUrl = this.buildDashboardUrl();\n    const targetMode = this.requestSigningMode === \"tab\" ? \"tab\" : \"popup\";\n    const opened = this.openWallet(dashboardUrl, targetMode);\n    if (opened) {\n      this.popupWindow = opened;\n      return opened;\n    }\n    return null;\n  }\n  closePopupIfExists() {\n    if (this.popupWindow && !this.popupWindow.closed) {\n      try {\n        this.popupWindow.close();\n      } catch (_unused) {}\n    }\n    this.popupWindow = null;\n  }\n  openWallet(url, mode) {\n    if (typeof window === \"undefined\") {\n      return null;\n    }\n    const targetMode = mode || this.openMode;\n    if (targetMode === \"popup\") {\n      const width = 480;\n      const height = 720;\n      const left = (window.innerWidth - width) / 2 + window.screenX;\n      const top = (window.innerWidth - height) / 2 + window.screenY;\n      const features = \"width=\".concat(width, \",height=\").concat(height, \",\") + \"left=\".concat(left, \",top=\").concat(top, \",\") + \"menubar=no,toolbar=no,location=no,\" + \"resizable=yes,scrollbars=yes,status=no\";\n      const popup = window.open(url, \"loop-wallet\", features);\n      if (!popup) {\n        return window.open(url, \"_blank\", \"noopener,noreferrer\");\n      }\n      this.popupWindow = popup;\n      try {\n        popup.focus();\n      } catch (_unused2) {}\n      return popup;\n    }\n    return window.open(url, \"_blank\", \"noopener,noreferrer\");\n  }\n  injectModalStyles() {\n    if (document.getElementById(\"loop-connect-styles\")) return;\n    const style = document.createElement(\"style\");\n    style.id = \"loop-connect-styles\";\n    style.textContent = \"\\n\\t\\t\\t.loop-connect {\\n\\t\\t\\t\\tposition: fixed;\\n\\t\\t\\t\\tinset: 0;\\n\\t\\t\\t\\tbackground: rgba(0, 0, 0, 0.85);\\n\\t\\t\\t\\tbackdrop-filter: blur(8px);\\n\\t\\t\\t\\tdisplay: flex;\\n\\t\\t\\t\\tjustify-content: center;\\n\\t\\t\\t\\talign-items: center;\\n\\t\\t\\t\\tz-index: 10000;\\n\\t\\t\\t\\tfont-family: \\\"Inter\\\", system-ui, -apple-system, sans-serif;\\n\\t\\t\\t\\tanimation: fadeIn 0.2s ease-out;\\n\\t\\t\\t}\\n\\t\\t\\t.loop-connect dialog {\\n\\t\\t\\t\\tposition: relative;\\n\\t\\t\\t\\toverflow: hidden;\\n\\t\\t\\t\\tbackground: #080808;\\n\\t\\t\\t\\tbox-shadow: 0 24px 60px -12px rgba(0, 0, 0, 0.5);\\n\\t\\t\\t\\tborder-radius: 40px;\\n\\t\\t\\t\\tborder: none;\\n\\t\\t\\t\\twidth: 340px;\\n\\t\\t\\t\\theight: 534px;\\n\\t\\t\\t\\tbox-sizing: border-box;\\n\\t\\t\\t\\tpadding: 32px;\\n\\t\\t\\t\\tdisplay: flex;\\n\\t\\t\\t\\tflex-direction: column;\\n\\t\\t\\t\\talign-items: center;\\n\\t\\t\\t\\tgap: 0;\\n\\t\\t\\t\\tcolor: #ffffff;\\n\\t\\t\\t}\\n\\t\\t\\t.loop-connect .bg-logo {\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\tright: -20px;\\n\\t\\t\\t\\ttop: -40px;\\n\\t\\t\\t\\twidth: 140px;\\n\\t\\t\\t\\theight: auto;\\n\\t\\t\\t\\topacity: 0.06;\\n\\t\\t\\t\\tpointer-events: none;\\n\\t\\t\\t}\\n\\t\\t\\t.loop-connect h3 {\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\ttop: 32px;\\n\\t\\t\\t\\tleft: 32px;\\n\\t\\t\\t\\tright: 32px;\\n\\t\\t\\t\\tmargin: 0;\\n\\t\\t\\t\\tfont-size: 18px;\\n\\t\\t\\t\\tfont-weight: 700;\\n\\t\\t\\t\\tline-height: 27px;\\n\\t\\t\\t\\tletter-spacing: -0.45px;\\n\\t\\t\\t\\ttext-align: center;\\n\\t\\t\\t}\\n\\t\\t\\t.loop-connect figure {\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\ttop: 91px;\\n\\t\\t\\t\\tleft: 32px;\\n\\t\\t\\t\\twidth: 276px;\\n\\t\\t\\t\\theight: 276px;\\n\\t\\t\\t\\tmargin: 0;\\n\\t\\t\\t\\tbackground: #ffffff;\\n\\t\\t\\t\\tpadding: 20px;\\n\\t\\t\\t\\tborder-radius: 8px;\\n\\t\\t\\t\\tdisplay: flex;\\n\\t\\t\\t\\tjustify-content: center;\\n\\t\\t\\t\\tborder: none;\\n\\t\\t\\t\\tbox-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1);\\n\\t\\t\\t\\tbox-sizing: border-box;\\n\\t\\t\\t}\\n\\t\\t\\t.loop-connect img {\\n\\t\\t\\t\\tdisplay: block;\\n\\t\\t\\t\\twidth: 236px;\\n\\t\\t\\t\\theight: 236px;\\n\\t\\t\\t\\tobject-fit: contain;\\n\\t\\t\\t\\tborder-radius: 12px;\\n\\t\\t\\t}\\n\\t\\t\\t.loop-connect .divider {\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\ttop: 399px;\\n\\t\\t\\t\\tleft: 36px;\\n\\t\\t\\t\\tright: 36px;\\n\\t\\t\\t\\twidth: auto;\\n\\t\\t\\t\\tdisplay: flex;\\n\\t\\t\\t\\talign-items: center;\\n\\t\\t\\t\\tjustify-content: center;\\n\\t\\t\\t\\tgap: 12px;\\n\\t\\t\\t\\tcolor: #64748b;\\n\\t\\t\\t\\tfont-size: 11px;\\n\\t\\t\\t\\tfont-weight: 700;\\n\\t\\t\\t\\tletter-spacing: 0.15em;\\n\\t\\t\\t\\ttext-transform: uppercase;\\n\\t\\t\\t\\ttext-align: center;\\n\\t\\t\\t}\\n\\t\\t\\t.loop-connect .divider::before,\\n\\t\\t\\t.loop-connect .divider::after {\\n\\t\\t\\t\\tcontent: \\\"\\\";\\n\\t\\t\\t\\tflex: 1;\\n\\t\\t\\t\\theight: 1px;\\n\\t\\t\\t\\tbackground: #1e293b;\\n\\t\\t\\t}\\n\\t\\t\\t.loop-connect button {\\n\\t\\t\\t\\tposition: absolute;\\n\\t\\t\\t\\ttop: 447.5px;\\n\\t\\t\\t\\tleft: 32px;\\n\\t\\t\\t\\tright: 32px;\\n\\t\\t\\t\\tbackground: #f2ff96;\\n\\t\\t\\t\\tborder: none;\\n\\t\\t\\t\\tcolor: #0f172a;\\n\\t\\t\\t\\ttext-align: center;\\n\\t\\t\\t\\tfont-family: \\\"Inter\\\", system-ui, -apple-system, sans-serif;\\n\\t\\t\\t\\tfont-style: normal;\\n\\t\\t\\t\\tpadding: 0 24px;\\n\\t\\t\\t\\tborder-radius: 8px;\\n\\t\\t\\t\\tfont-size: 15px;\\n\\t\\t\\t\\tfont-weight: 600;\\n\\t\\t\\t\\tline-height: 22.5px;\\n\\t\\t\\t\\tcursor: pointer;\\n\\t\\t\\t\\ttransition: all 0.2s ease;\\n\\t\\t\\t\\twidth: auto;\\n\\t\\t\\t\\theight: 54.5px;\\n\\t\\t\\t\\tbox-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2),\\n\\t\\t\\t\\t\\t0 4px 6px -4px rgba(0, 0, 0, 0.2);\\n\\t\\t\\t}\\n\\t\\t\\t.loop-connect button:hover {\\n\\t\\t\\t\\tbackground: #f6ffb4;\\n\\t\\t\\t}\\n\\t\\t\\t@keyframes fadeIn {\\n\\t\\t\\t\\tfrom { opacity: 0; }\\n\\t\\t\\t\\tto { opacity: 1; }\\n\\t\\t\\t}\\n\\t\\t\";\n    document.head.appendChild(style);\n  }\n  showQrCode(url) {\n    this.injectModalStyles();\n    import_qrcode.default.toDataURL(url, {\n      margin: 0\n    }, (err, dataUrl) => {\n      if (err) {\n        console.error(\"Failed to generate QR code\", err);\n        return;\n      }\n      const overlay = document.createElement(\"div\");\n      overlay.id = \"loop-sdk-connect-overlay\";\n      overlay.className = \"loop-sdk-connect-overlay loop-connect\";\n      const dialog = document.createElement(\"dialog\");\n      dialog.open = true;\n      const bgLogo = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      bgLogo.setAttribute(\"class\", \"bg-logo\");\n      bgLogo.setAttribute(\"viewBox\", \"0 0 124.05 305.64\");\n      const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n      path.setAttribute(\"d\", \"M24.58,99.47L124.05,0v224.42L24.58,124.95c-7.04-7.04-7.04-18.45,0-25.49Z\");\n      path.setAttribute(\"fill\", \"currentColor\");\n      const rect = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n      rect.setAttribute(\"x\", \"12.89\");\n      rect.setAttribute(\"y\", \"194.48\");\n      rect.setAttribute(\"width\", \"98.27\");\n      rect.setAttribute(\"height\", \"98.27\");\n      rect.setAttribute(\"rx\", \"18.02\");\n      rect.setAttribute(\"ry\", \"18.02\");\n      rect.setAttribute(\"transform\", \"translate(-154.1 115.21) rotate(-45)\");\n      rect.setAttribute(\"fill\", \"currentColor\");\n      bgLogo.appendChild(path);\n      bgLogo.appendChild(rect);\n      const title = document.createElement(\"h3\");\n      title.textContent = \"Scan with Phone\";\n      const figure = document.createElement(\"figure\");\n      const img = document.createElement(\"img\");\n      img.src = dataUrl;\n      img.alt = \"QR Code\";\n      figure.appendChild(img);\n      const divider = document.createElement(\"div\");\n      divider.className = \"divider\";\n      divider.textContent = \"OR\";\n      const button = document.createElement(\"button\");\n      button.type = \"button\";\n      button.textContent = \"Continue in Browser\";\n      button.addEventListener(\"click\", () => {\n        this.openWallet(url);\n      });\n      dialog.appendChild(bgLogo);\n      dialog.appendChild(title);\n      dialog.appendChild(figure);\n      dialog.appendChild(divider);\n      dialog.appendChild(button);\n      overlay.appendChild(dialog);\n      overlay.addEventListener(\"click\", e => {\n        if (e.target === overlay) {\n          this.hideQrCode();\n        }\n      });\n      document.body.appendChild(overlay);\n      this.overlay = overlay;\n    });\n  }\n  hideQrCode() {\n    if (this.overlay && this.overlay.parentElement) {\n      this.overlay.parentElement.removeChild(this.overlay);\n      this.overlay = null;\n    }\n  }\n  logout() {\n    var _this$session4, _this$connection3;\n    (_this$session4 = this.session) === null || _this$session4 === void 0 || _this$session4.reset();\n    this.provider = null;\n    (_this$connection3 = this.connection) === null || _this$connection3 === void 0 || (_this$connection3 = _this$connection3.ws) === null || _this$connection3 === void 0 || _this$connection3.close();\n    this.hideQrCode();\n  }\n  requireProvider() {\n    if (!this.provider) {\n      throw new Error(\"SDK not connected. Call connect() and wait for acceptance first.\");\n    }\n    return this.provider;\n  }\n  createProviderHooks() {\n    var _this$onTransactionUp;\n    return {\n      onRequestStart: () => this.openRequestUi(),\n      onRequestFinish: _ref5 => {\n        let {\n          requestContext\n        } = _ref5;\n        const win = requestContext;\n        if (win) {\n          setTimeout(() => {\n            this.closePopupIfExists();\n          }, 800);\n        }\n      },\n      onTransactionUpdate: (_this$onTransactionUp = this.onTransactionUpdate) !== null && _this$onTransactionUp !== void 0 ? _this$onTransactionUp : undefined\n    };\n  }\n}\nvar loop = new LoopSDK();\nexport { loop, MessageType };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}