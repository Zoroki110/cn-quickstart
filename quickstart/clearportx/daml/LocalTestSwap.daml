module LocalTestSwap where

import Daml.Script
import DA.Time
import DA.List (head)

import qualified Token.Token as T
import qualified AMM.SwapRequest as SR
import qualified AMM.Pool as P

-- Test un swap: Alice swap 5000 USDC → ETH
testLocalSwap : Script ()
testLocalSwap = script do
  -- Récupérer les parties existantes
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Trouver le pool
  pools <- query @P.Pool poolOperator
  let (poolCid, pool) = head pools

  debug $ "Found pool: " <> pool.poolId
  debug $ "Reserves: " <> show pool.reserveA <> " ETH, " <> show pool.reserveB <> " USDC"

  -- Trouver les tokens d'Alice
  aliceTokens <- query @T.Token alice
  let aliceUSDCs = filter (\(_, t) -> t.symbol == "USDC" && t.owner == alice) aliceTokens
  let (aliceUSDCCid, aliceUSDC) = head aliceUSDCs

  debug $ "Alice has: " <> show aliceUSDC.amount <> " USDC"

  -- Créer swap request: 5000 USDC → ETH
  swapReq <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceUSDCCid
    inputSymbol = "USDC"
    inputAmount = 5000.0
    outputSymbol = "ETH"
    minOutput = 2.0  -- Minimum 2 ETH attendu
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 500  -- Max 5% impact

  debug "📝 Swap request created"

  -- Prepare swap (transfer USDC to pool)
  swapReady <- submit alice $ exerciseCmd swapReq SR.PrepareSwap

  debug "✅ Swap prepared (USDC transferred to pool)"

  -- Trouver les pool tokens
  poolTokens <- query @T.Token poolParty
  let poolETHs = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens
  let poolUSDCs = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens
  let (poolETHCid, _) = head poolETHs
  let (poolUSDCCid, _) = head poolUSDCs

  -- Execute swap
  (aliceNewETH, newPool) <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap with
    poolTokenACid = poolETHCid
    poolTokenBCid = poolUSDCCid

  -- Vérifier résultat
  newETHToken <- queryContractId alice aliceNewETH
  let Some ethReceived = newETHToken

  newPoolData <- queryContractId poolOperator newPool
  let Some newPoolState = newPoolData

  debug ""
  debug "🎉 SWAP SUCCESSFUL!"
  debug $ "   Alice swapped: 5,000 USDC"
  debug $ "   Alice received: " <> show ethReceived.amount <> " ETH"
  debug $ "   New pool reserves: " <> show newPoolState.reserveA <> " ETH, " <> show newPoolState.reserveB <> " USDC"
  debug $ "   Effective price: " <> show (5000.0 / ethReceived.amount) <> " USDC/ETH"

  return ()
