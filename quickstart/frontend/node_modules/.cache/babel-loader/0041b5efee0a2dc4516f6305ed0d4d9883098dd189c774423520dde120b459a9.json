{"ast":null,"code":"import _objectSpread from\"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useCallback,useEffect,useState}from\"react\";import{walletManager}from\"./WalletManager\";import{apiPostJson,clearWalletSession,loadWalletSession,persistWalletSession,setAuthToken}from\"../api/client\";const initialAuthState={token:null,partyId:null,walletType:null,loading:false,error:null};let authState=initialAuthState;const authListeners=new Set();let authHydratedFromSession=false;export function useWalletAuth(){hydrateAuthStateFromSession();const[state,setState]=useState(authState);const[loopRehydrateTried,setLoopRehydrateTried]=useState(false);useEffect(()=>{const listener=next=>setState(next);authListeners.add(listener);return()=>{authListeners.delete(listener);};},[]);// Rehydrate Loop provider (SDK can reuse cached session without QR).\nuseEffect(()=>{if(state.walletType===\"loop\"&&!loopRehydrateTried){setLoopRehydrateTried(true);walletManager.connectLoop().catch(err=>console.warn(\"Loop rehydrate failed\",err));}},[state.walletType,loopRehydrateTried]);const runAuthFlow=useCallback(async connect=>{updateAuthState({loading:true,error:null});try{const connector=await connect();if(typeof connector.connect===\"function\"){await connector.connect();}const walletParty=await connector.getParty();const challenge=await requestChallenge(walletParty);const signature=await connector.signMessage(challenge.challenge);const verification=await verifyChallenge(connector,{challengeId:challenge.challengeId,partyId:walletParty,signature});const connectorType=normalizeWalletType(connector.getType());setAuthToken(verification.token);persistWalletSession({token:verification.token,partyId:verification.partyId,walletType:connectorType});updateAuthState({token:verification.token,partyId:verification.partyId,walletType:connectorType});if(typeof window!==\"undefined\"){window.dispatchEvent(new CustomEvent(\"clearportx:wallet:connected\",{detail:{partyId:verification.partyId,walletType:connectorType}}));}return verification;}catch(err){const message=err instanceof Error?err.message:\"Wallet authentication failed\";updateAuthState({error:message});throw err;}finally{updateAuthState({loading:false});}},[]);const authenticateWithLoop=useCallback(()=>runAuthFlow(()=>walletManager.connectLoop()),[runAuthFlow]);const authenticateWithDev=useCallback(()=>runAuthFlow(()=>walletManager.connectDev()),[runAuthFlow]);const authenticateWithZoro=useCallback(()=>runAuthFlow(()=>walletManager.connectZoro()),[runAuthFlow]);const disconnect=useCallback(()=>{clearWalletSession();setAuthToken(null);updateAuthState({token:null,partyId:null,walletType:null,error:null});},[]);return{token:state.token,partyId:state.partyId,walletType:state.walletType,loading:state.loading,error:state.error,authenticateWithLoop,authenticateWithDev,authenticateWithZoro,disconnect};}async function requestChallenge(partyId){return apiPostJson(\"/api/auth/challenge\",{partyId});}async function verifyChallenge(connector,params){return apiPostJson(\"/api/auth/verify\",_objectSpread(_objectSpread({},params),{},{walletType:connector.getType()}));}function normalizeWalletType(value){if(value===\"loop\"||value===\"zoro\"||value===\"dev\"||value===\"unknown\"){return value;}return\"unknown\";}function hydrateAuthStateFromSession(){if(authHydratedFromSession){return;}authHydratedFromSession=true;const session=loadWalletSession();if(session!==null&&session!==void 0&&session.token&&session.partyId){setAuthToken(session.token);authState=_objectSpread(_objectSpread({},authState),{},{token:session.token,partyId:session.partyId,walletType:normalizeWalletType(session.walletType)});}}function updateAuthState(patch){authState=_objectSpread(_objectSpread({},authState),patch);authListeners.forEach(listener=>listener(authState));}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}