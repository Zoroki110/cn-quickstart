{"ast":null,"code":"import _objectSpread from\"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";var _BUILD_INFO$features;// ClearportX Backend API Service\n// Connects to Spring Boot backend at http://localhost:8080\nimport axios from'axios';import{getAccessToken,getPartyId}from'./auth';import{BUILD_INFO}from'../config/build-info';import{getActiveWalletParty,getAuthToken}from'../api/client';const runtimeBackendUrl=typeof window!=='undefined'&&window.__BACKEND_URL__||undefined;const BACKEND_URL=process.env.REACT_APP_BACKEND_API_URL||(BUILD_INFO===null||BUILD_INFO===void 0?void 0:(_BUILD_INFO$features=BUILD_INFO.features)===null||_BUILD_INFO$features===void 0?void 0:_BUILD_INFO$features.backendUrl)||runtimeBackendUrl||'http://localhost:8080';/**\n * Map frontend party names to Canton ledger party IDs\n * This allows using friendly names like \"alice\" in the frontend\n * while using the real Canton party IDs in backend calls\n */const DEVNET_PARTY=process.env.REACT_APP_PARTY_ID||'ClearportX-DEX-1::122081f2b8e29cbe57d1037a18e6f70e57530773b3a4d1bea6bab981b7a76e943b37';const PARTY_MAPPING={'alice@clearportx':DEVNET_PARTY,'alice':DEVNET_PARTY,'bob':DEVNET_PARTY,'AppProvider':DEVNET_PARTY,'app-provider':DEVNET_PARTY};const FALLBACK_TRANSACTIONS=[{id:'demo-add-liquidity-001',title:'AddLiquidity Transaction',type:'ADD_LIQUIDITY',status:'settled',createdAt:'2025-11-15T19:45:00Z',expiresAt:'2025-11-15T20:46:00Z',tokenA:'CC',tokenB:'PP',amountADesired:'1950',amountBDesired:'1950',minLpAmount:'1940',lpTokenSymbol:'LP-CC-PP',contractId:'00b69dbaaa12f291cc65c5377c7b5d11baba199397af2bfdc5ed5757d50d2806d3ca111220d53ee8f31b108591e1517f7787c6adedc2b2386e86c65da1bf100e112392dc9f',eventTimeline:[{id:'demo-add-liquidity-001-evt-1',title:'Add Liquidity Settled',description:'Added 1.95K CC / 1.95K PP and received 1.95K LP tokens.',status:'completed',timestamp:'2025-11-15T19:46:00Z'},{id:'demo-add-liquidity-001-evt-2',title:'Intent Archived',description:'Transaction was archived.',status:'completed',timestamp:'2025-11-15T19:47:00Z'}]}];/**\n * Map frontend party name to Canton party ID\n */function mapPartyToBackend(frontendParty){return PARTY_MAPPING[frontendParty]||frontendParty;}export class BackendApiService{constructor(){this.client=void 0;this.client=axios.create({baseURL:BACKEND_URL,timeout:30000,headers:{'Content-Type':'application/json','ngrok-skip-browser-warning':'true'// Skip ngrok warning page\n}});// JWT and X-Party interceptor\nthis.client.interceptors.request.use(config=>{var _config$url;const walletToken=getAuthToken();const token=walletToken||getAccessToken();const walletPartyId=getActiveWalletParty();const party=walletPartyId||getPartyId()||DEVNET_PARTY;const publicEndpoints=['/api/pools','/api/health','/api/health/ledger','/actuator/health','/api/debug/','/api/clearportx/debug/'];const url=(_config$url=config.url)!==null&&_config$url!==void 0?_config$url:'';const isPublicEndpoint=publicEndpoints.some(endpoint=>url.includes(endpoint));if(isPublicEndpoint){// Force public calls to stay unauthenticated to avoid 401s when logged out.\ndelete config.headers.Authorization;}else if(token){config.headers.Authorization=\"Bearer \".concat(token);console.log('ðŸ” Adding JWT to request:',config.url);}else{console.warn('âš ï¸ No JWT token found for protected endpoint:',config.url);}if(party){config.headers['X-Party']=party;console.log('ðŸ‘¤ Adding X-Party header:',party.substring(0,30)+'...');}return config;});// Retry on 429 (rate limit) only; 409 handled by request() wrapper\nthis.client.interceptors.response.use(response=>response,async error=>{var _error$response;if(((_error$response=error.response)===null||_error$response===void 0?void 0:_error$response.status)===429){const retryAfter=parseInt(error.response.headers['retry-after']||'3',10);const waitMs=isNaN(retryAfter)?3000:retryAfter*1000;console.log(\"\\u26A0\\uFE0F  Rate limited, retrying after \".concat(Math.round(waitMs/1000),\"s...\"));await new Promise(resolve=>setTimeout(resolve,waitMs));// Retry the original request\nreturn this.client.request(error.config);}throw error;});}hasJwt(){const walletToken=getAuthToken();if(walletToken){return true;}const token=getAccessToken();return!!token&&token!=='devnet-mock-token';}// Resolve a fresh pool CID for a given poolId by choosing a pool whose canonical token CIDs are alive for poolParty\nasync resolveFreshPoolCidById(poolId){try{var _cidsRes$data,_poolPartyTokensRes$d;const appParty=this.currentParty();// Resolve poolParty from poolId\nconst parties=await this.client.post('/api/debug/pool-parties',{poolId}).then(r=>{var _r$data;return(_r$data=r.data)===null||_r$data===void 0?void 0:_r$data.parties;}).catch(()=>null);const poolParty=parties===null||parties===void 0?void 0:parties.poolParty;if(!poolParty)return null;// Fetch all pools visible to appParty\nconst cidsRes=await this.client.get('/api/clearportx/debug/party-acs',{params:{template:'AMM.Pool.Pool'},headers:{'X-Party':appParty}});const poolCids=((_cidsRes$data=cidsRes.data)===null||_cidsRes$data===void 0?void 0:_cidsRes$data.cids)||[];// Fetch poolParty tokens once\nconst poolPartyTokensRes=await this.client.get('/api/clearportx/debug/party-acs',{params:{template:'Token.Token.Token'},headers:{'X-Party':poolParty}}).catch(()=>null);const poolPartyTokenCidSet=new Set((poolPartyTokensRes===null||poolPartyTokensRes===void 0?void 0:(_poolPartyTokensRes$d=poolPartyTokensRes.data)===null||_poolPartyTokensRes$d===void 0?void 0:_poolPartyTokensRes$d.cids)||[]);const emptyPools=[];const aliveCanonPools=[];for(const cid of poolCids){try{const meta=await this.client.get('/api/clearportx/debug/pool-by-cid',{params:{cid},headers:{'X-Party':appParty}}).then(r=>r.data);if(!(meta!==null&&meta!==void 0&&meta.success))continue;if(meta.poolId!==poolId)continue;const ca=meta.tokenACid;const cb=meta.tokenBCid;if(!ca&&!cb)emptyPools.push(cid);else if(ca&&cb&&poolPartyTokenCidSet.has(ca)&&poolPartyTokenCidSet.has(cb))aliveCanonPools.push(cid);}catch(_unused){// ignore and continue\n}}if(emptyPools.length>0)return emptyPools[0];if(aliveCanonPools.length>0)return aliveCanonPools[0];return null;}catch(_unused2){return null;}}// Sleep helper for pacing (DevNet-friendly)\nasync sleep(ms){return new Promise(resolve=>setTimeout(resolve,ms));}currentParty(){return getActiveWalletParty()||getPartyId()||DEVNET_PARTY;}// Expose current acting party to UI (for consistent token refresh)\ngetCurrentParty(){return this.currentParty();}// Always resolve a fresh, party-visible CID for a poolId (server guarantees visibility)\nasync resolveAndGrant(poolId,party){var _BUILD_INFO$features2;const res=await this.request(()=>this.client.post('/api/debug/resolve-and-grant',{poolId,party},{headers:{'X-Party':party}}));if(!(res!==null&&res!==void 0&&res.success)||!(res!==null&&res!==void 0&&res.poolCid)){throw new Error(\"Resolver failed for \".concat(poolId));}let cid=res.poolCid;const resolvedPkg=res.packageId;// Prefer latest AMM package when multiple pool instances exist\nconst preferredPkgPrefix=(process.env.REACT_APP_AMM_POOL_PACKAGE_ID||'').trim()||((BUILD_INFO===null||BUILD_INFO===void 0?void 0:(_BUILD_INFO$features2=BUILD_INFO.features)===null||_BUILD_INFO$features2===void 0?void 0:_BUILD_INFO$features2.ammPackageId)||'').trim()||'';try{if(preferredPkgPrefix&&(!resolvedPkg||!(resolvedPkg!==null&&resolvedPkg!==void 0&&resolvedPkg.toLowerCase().startsWith(preferredPkgPrefix.toLowerCase())))){// Scan party-visible pools for the same poolId and pick the one with preferred packageId\nconst rows=await this.fetchPoolsForParty(party);const sameId=rows.filter(r=>r.poolId===poolId);for(const row of sameId){try{const ti=await this.request(()=>this.client.get('/api/debug/pool/template-id',{params:{cid:row.poolCid},headers:{'X-Party':party}}));const pkg=(ti===null||ti===void 0?void 0:ti.packageId)||'';if(pkg&&pkg.toLowerCase().startsWith(preferredPkgPrefix.toLowerCase())){cid=row.poolCid;break;}}catch(_unused3){// ignore and continue\n}}}}catch(_unused4){// best-effort preference; keep resolver selection if anything fails\n}return{poolCid:cid,poolId:res.poolId,packageId:resolvedPkg};}// Centralized request wrapper with single paced 409 retry\nasync request(call){try{const res=await call();return res.data;}catch(e){var _err$response,_err$response2;const err=e;const status=(_err$response=err.response)===null||_err$response===void 0?void 0:_err$response.status;const body=((_err$response2=err.response)===null||_err$response2===void 0?void 0:_err$response2.data)||{};if(status===409){const retryMs=typeof body.retry_after_ms==='number'&&body.retry_after_ms>0?body.retry_after_ms:3500;console.log(\"\\u26A0\\uFE0F  409 Stale/Visibility, retrying once after \".concat(Math.round(retryMs/1000),\"s...\"));await this.sleep(retryMs);const res2=await call();return res2.data;}const domain={code:body.code||'INTERNAL',message:body.message||body.error||err.message||'Internal error',retryAfterMs:body.retry_after_ms,httpStatus:status};throw domain;}}// Use backend summary of pools visible to a party (includes poolCid and reserves)\nasync fetchPoolsForParty(party){try{// Prefer POST to match backend behavior; fallback to GET for compatibility\nlet list=[];try{const resPost=await this.client.post('/api/debug/pools-for-party',{party});list=Array.isArray(resPost.data)?resPost.data:[];}catch(_unused5){const resGet=await this.client.get('/api/debug/pools-for-party',{params:{party}});list=Array.isArray(resGet.data)?resGet.data:[];}return list;}catch(_unused6){return[];}}// Directory mapping (poolId -> latest poolCid); maintained by backend on updates\nasync getDirectoryLatestCid(poolId){try{var _res$data;const res=await this.client.get('/api/clearportx/debug/directory');const mapping=((_res$data=res.data)===null||_res$data===void 0?void 0:_res$data.mapping)||{};const entry=mapping[poolId];const cid=(entry===null||entry===void 0?void 0:entry.poolCid)||null;return cid;}catch(_unused7){return null;}}// Ensure chosen poolCid is visible to acting party; grant if needed; return (possibly) updated CID\nasync ensurePoolCidVisible(poolCid,poolId,party){try{const probe=await this.request(()=>this.client.get('/api/clearportx/debug/pool/fetch-cid',{params:{cid:poolCid},headers:{'X-Party':party}}));if((probe===null||probe===void 0?void 0:probe.visible)===true)return poolCid;}catch(_unused8){// fall through to grant\n}// Do NOT attempt grant over remote. Pick a party-visible CID for same poolId or by pair.\ntry{const rows=await this.fetchPoolsForParty(party);const sameId=rows.find(r=>r.poolId===poolId);if(sameId)return sameId.poolCid;const m=(poolId||'').toUpperCase().match(/([A-Z]+)-([A-Z]+)/);if(m&&m.length>=3){const[,a,b]=m;const byPair=rows.filter(r=>r.symbolA===a&&r.symbolB===b||r.symbolA===b&&r.symbolB===a);if(byPair.length>0){const chosen=[...byPair].sort((x,y)=>parseFloat(y.reserveA)*parseFloat(y.reserveB)-parseFloat(x.reserveA)*parseFloat(x.reserveB))[0];return chosen.poolCid;}}}catch(_unused9){// ignore\n}// Last resort: return original and let caller retry candidates\nreturn poolCid;}// Choose pool CID for a poolId: prefer empty pool (0/0) for first add; else pick highest TVL\nasync resolvePoolCidForIdPreferEmpty(poolId){const party=this.currentParty();const pools=await this.fetchPoolsForParty(party);const forId=pools.filter(p=>p.poolId===poolId);if(forId.length===0)return null;const empties=forId.filter(p=>parseFloat(p.reserveA)===0&&parseFloat(p.reserveB)===0);if(empties.length>0)return empties[0].poolCid;// pick by TVL proxy (reserveA*reserveB) descending\nconst sorted=[...forId].sort((a,b)=>{const ta=parseFloat(a.reserveA)*parseFloat(a.reserveB);const tb=parseFloat(b.reserveA)*parseFloat(b.reserveB);return tb-ta;});return sorted[0].poolCid;}async resolvePoolCid(poolId){return this.resolvePoolCidForIdPreferEmpty(poolId);}/**\n   * Health check - verify backend is running and synced\n   */async healthCheck(){try{const res=await this.client.get('/api/health/ledger');return res.data;}catch(error){console.error('Health check failed:',error);// Return a default response indicating the backend is down\nreturn{status:'DOWN',env:'unknown',darVersion:'unknown',atomicSwapAvailable:false,poolsActive:0,synced:false};}}/**\n   * Get all active pools, preferring the public directory but falling back to the party-specific view when needed.\n   */async getPools(){let publicPools=[];try{const res=await this.client.get('/api/pools');const poolData=Array.isArray(res.data)?res.data:[];publicPools=poolData.map(data=>this.mapPool(data));}catch(error){console.warn('Public pools fetch failed',error);}if(publicPools.length>0){return this.normalizePools(publicPools);}try{const fallbackPools=await this.loadPartyScopedPools();if(fallbackPools.length>0){return this.normalizePools(fallbackPools);}}catch(fallbackErr){console.error('Fallback pool loader failed',fallbackErr);}return[];}async loadPartyScopedPools(){var _BUILD_INFO$features3;const party=this.currentParty();const partyRows=await this.fetchPoolsForParty(party);if(partyRows.length===0){return[];}let directoryMap={};try{var _dirRes$data;const dirRes=await this.client.get('/api/clearportx/debug/directory');directoryMap=((_dirRes$data=dirRes.data)===null||_dirRes$data===void 0?void 0:_dirRes$data.mapping)||{};}catch(_unused0){directoryMap={};}const preferredPkgPrefix=(process.env.REACT_APP_AMM_POOL_PACKAGE_ID||'').trim()||((BUILD_INFO===null||BUILD_INFO===void 0?void 0:(_BUILD_INFO$features3=BUILD_INFO.features)===null||_BUILD_INFO$features3===void 0?void 0:_BUILD_INFO$features3.ammPackageId)||'').trim();const groups=new Map();for(const row of partyRows){const key=[String(row.symbolA),String(row.symbolB)].sort().join('/');const arr=groups.get(key)||[];arr.push(row);groups.set(key,arr);}const chosenRows=[];const groupedValues=Array.from(groups.values());for(const rows of groupedValues){let picked=null;if(!picked&&preferredPkgPrefix){for(const r of rows){try{const ti=await this.request(()=>this.client.get('/api/debug/pool/template-id',{params:{cid:r.poolCid},headers:{'X-Party':party}}));const pkg=(ti===null||ti===void 0?void 0:ti.packageId)||'';if(pkg&&pkg.toLowerCase().startsWith(String(preferredPkgPrefix).toLowerCase())){picked=r;break;}}catch(_unused1){// ignore and continue\n}}}if(!picked){const latestMatches=[];for(const r of rows){var _directoryMap$r$poolI;const latest=(_directoryMap$r$poolI=directoryMap[r.poolId])===null||_directoryMap$r$poolI===void 0?void 0:_directoryMap$r$poolI.poolCid;if(latest&&latest===r.poolCid){latestMatches.push(r);}}if(latestMatches.length>0){picked=[...latestMatches].sort((a,b)=>parseFloat(b.reserveA)*parseFloat(b.reserveB)-parseFloat(a.reserveA)*parseFloat(a.reserveB))[0];}}if(!picked){picked=[...rows].sort((a,b)=>parseFloat(b.reserveA)*parseFloat(b.reserveB)-parseFloat(a.reserveA)*parseFloat(a.reserveB))[0];}if(picked){chosenRows.push(picked);}}return chosenRows.map(row=>this.mapPartyPool(row));}normalizePools(pools){if(!Array.isArray(pools)||pools.length===0){return[];}const activePools=pools.filter(pool=>pool.reserveA>0&&pool.reserveB>0);if(activePools.length===0){return[...pools];}const pairToBest={};for(const pool of activePools){const pairKey=[pool.tokenA.symbol,pool.tokenB.symbol].sort().join('/');const tvl=pool.reserveA*pool.reserveB;const current=pairToBest[pairKey];if(!current||tvl>current.reserveA*current.reserveB){pairToBest[pairKey]=pool;}}return Object.values(pairToBest).sort((a,b)=>{const tvlA=a.reserveA*a.reserveB;const tvlB=b.reserveA*b.reserveB;return tvlB-tvlA;});}/**\n   * Get tokens owned by a party\n   * Maps frontend party names (like 'alice') to Canton party IDs\n   */async getTokens(party){const cantonParty=mapPartyToBackend(party);console.log(\"Getting tokens for \".concat(party,\" (mapped to \").concat(cantonParty,\")\"));try{// Prefer authenticated wallet endpoint; fallback to debug or legacy public tokens\nlet res;try{res=await this.client.get(\"/api/wallet/tokens/\".concat(cantonParty));}catch(e){var _e$response;const status=e===null||e===void 0?void 0:(_e$response=e.response)===null||_e$response===void 0?void 0:_e$response.status;if(status===401||status===403||status===404){// Dev fallback: debug wallet tokens by query param\ntry{res=await this.client.get(\"/api/debug/wallet/tokens\",{params:{party:cantonParty}});}catch(_unused10){// Last resort: legacy tokens (includes canonicals)\nres=await this.client.get(\"/api/tokens/\".concat(cantonParty));}}else{throw e;}}// Ensure res.data is an array\nconst tokenData=Array.isArray(res.data)?res.data:[];// Map all tokens\nlet allTokens=tokenData.map(data=>this.mapToken(data));// Dev-only heuristic: exclude giant faucet mints when unauthenticated\nif(!this.hasJwt()){allTokens=allTokens.filter(t=>(t.balance||0)<100000);}const aggregatedTokens=this.aggregateTokensBySymbol(allTokens).filter(token=>(token.balance||0)>0);console.log(\"Aggregated \".concat(allTokens.length,\" tokens into \").concat(aggregatedTokens.length,\" unique tokens\"));return aggregatedTokens;}catch(error){console.error('Error loading tokens:',error);return[];}}/**\n   * Wallet-only tokens (exclude pool canonical tokens)\n   */async getWalletTokens(party){const cantonParty=mapPartyToBackend(party);console.log(\"Getting wallet tokens for \".concat(party,\" (mapped to \").concat(cantonParty,\")\"));try{const res=await this.client.get(\"/api/wallet/tokens/\".concat(cantonParty));const tokenData=Array.isArray(res.data)?res.data:[];const aggregated=this.aggregateTokensBySymbol(tokenData.map(data=>this.mapToken(data)));console.log(\"Wallet tokens aggregated into \".concat(aggregated.length,\" entries\"));return aggregated;}catch(error){console.error('Error loading wallet tokens:',error);return this.getTokens(party);}}async getLpTokens(party){const cantonParty=mapPartyToBackend(party);console.log(\"Getting LP tokens for \".concat(party,\" (mapped to \").concat(cantonParty,\")\"));try{const res=await this.client.get(\"/api/wallet/lp-tokens/\".concat(cantonParty));const rows=Array.isArray(res.data)?res.data:[];const mapped=rows.map(row=>({poolId:row.poolId||row.pool_id||'',amount:parseFloat(row.amount||row.balance||'0'),contractId:row.contractId||row.cid||'',owner:row.owner||row.party||undefined})).filter(lp=>lp.poolId&&Number.isFinite(lp.amount)&&lp.amount>0);console.log(\"Fetched \".concat(mapped.length,\" LP token positions\"));return mapped;}catch(error){console.error('Error loading LP tokens:',error);return[];}}/**\n   * Get pool CID for a given pool by matching token symbols\n   * Fetches pool CIDs from the backend and finds matching pool\n   */async getPoolCidBySymbols(tokenASymbol,tokenBSymbol){try{var _res$data2;// Get the party ID\nconst party=getPartyId()||DEVNET_PARTY;// Fetch all pools visible to this party\nconst res=await this.client.get('/api/clearportx/debug/party-acs',{params:{template:'AMM.Pool.Pool'},headers:{'X-Party':party}});const poolCids=((_res$data2=res.data)===null||_res$data2===void 0?void 0:_res$data2.cids)||[];console.log(\"Found \".concat(poolCids.length,\" pool CIDs for party\"));// For each pool CID, fetch details to find matching symbols\nfor(const cid of poolCids){try{const poolRes=await this.client.get('/api/clearportx/debug/pool-by-cid',{params:{cid},headers:{'X-Party':party}});const poolData=poolRes.data;if(poolData.success&&(poolData.symbolA===tokenASymbol&&poolData.symbolB===tokenBSymbol||poolData.symbolA===tokenBSymbol&&poolData.symbolB===tokenASymbol)){console.log(\"Found matching pool: \".concat(poolData.poolId,\" with CID: \").concat(cid));return cid;}}catch(error){console.error(\"Error fetching pool details for CID \".concat(cid,\":\"),error);}}console.warn(\"No pool found for \".concat(tokenASymbol,\"/\").concat(tokenBSymbol));return null;}catch(error){console.error('Error fetching pool CIDs:',error);return null;}}/**\n   * Execute swap via debug endpoint (JWT-aware)\n   */async executeAtomicSwap(params){var _params$minOutput,_ref,_ref2,_swapResponse$resolve,_ref3,_swapResponse$command;const party=this.currentParty();const resolvedPoolId=params.poolId||\"\".concat(params.inputSymbol,\"-\").concat(params.outputSymbol);const{poolCid}=await this.resolveAndGrant(resolvedPoolId,party);const minOutputStr=(_params$minOutput=params.minOutput)!==null&&_params$minOutput!==void 0?_params$minOutput:'0';const body={poolCid,poolId:resolvedPoolId,inputSymbol:params.inputSymbol,outputSymbol:params.outputSymbol,amountIn:params.inputAmount,minOutput:minOutputStr};const swapResponse=await this.request(()=>this.client.post('/api/clearportx/debug/swap-by-cid',body,{headers:{'X-Party':party}}));const rawResolvedOutput=(_ref=(_ref2=(_swapResponse$resolve=swapResponse===null||swapResponse===void 0?void 0:swapResponse.resolvedOutput)!==null&&_swapResponse$resolve!==void 0?_swapResponse$resolve:swapResponse===null||swapResponse===void 0?void 0:swapResponse.amountOut)!==null&&_ref2!==void 0?_ref2:swapResponse===null||swapResponse===void 0?void 0:swapResponse.minOutput)!==null&&_ref!==void 0?_ref:'0';const numericResolved=Number(rawResolvedOutput);const amountOut=Number.isFinite(numericResolved)?numericResolved.toString():String(rawResolvedOutput!==null&&rawResolvedOutput!==void 0?rawResolvedOutput:'0');return{receiptCid:(_ref3=(_swapResponse$command=swapResponse===null||swapResponse===void 0?void 0:swapResponse.commandId)!==null&&_swapResponse$command!==void 0?_swapResponse$command:swapResponse===null||swapResponse===void 0?void 0:swapResponse.outputTokenCid)!==null&&_ref3!==void 0?_ref3:'',trader:party,inputSymbol:params.inputSymbol,outputSymbol:params.outputSymbol,amountIn:params.inputAmount,amountOut,timestamp:new Date().toISOString()};}/**\n   * Get pool CID for a given pool ID\n   * Fetches pool CIDs from the backend and finds matching pool by ID\n   */async getPoolCidById(poolId){try{var _res$data3;// Get the party ID\nconst party=getPartyId()||DEVNET_PARTY;// Fetch all pools visible to this party\nconst res=await this.client.get('/api/clearportx/debug/party-acs',{params:{template:'AMM.Pool.Pool'},headers:{'X-Party':party}});const poolCids=((_res$data3=res.data)===null||_res$data3===void 0?void 0:_res$data3.cids)||[];console.log(\"Found \".concat(poolCids.length,\" pool CIDs for party, looking for poolId: \").concat(poolId));// For each pool CID, fetch details to find matching pool ID\nfor(const cid of poolCids){try{const poolRes=await this.client.get('/api/clearportx/debug/pool-by-cid',{params:{cid},headers:{'X-Party':party}});const poolData=poolRes.data;// Check if pool ID matches (partial match since frontend may have simplified IDs)\nif(poolData.success&&(poolData.poolId===poolId||poolData.poolId.includes(poolId)||poolId.includes(poolData.poolId))){console.log(\"Found matching pool by ID: \".concat(poolData.poolId,\" with CID: \").concat(cid));return cid;}}catch(error){console.error(\"Error fetching pool details for CID \".concat(cid,\":\"),error);}}// If not found by ID, try by symbols extracted from the pool ID\n// Pool IDs often have format like \"ETH-USDC-01\" or \"p0-gv-eth-usdc-225946\"\nconst symbols=poolId.toUpperCase().match(/([A-Z]+)-([A-Z]+)/);if(symbols&&symbols.length>=3){const symbolA=symbols[1];const symbolB=symbols[2];console.log(\"Trying to find pool by symbols: \".concat(symbolA,\"/\").concat(symbolB));return this.getPoolCidBySymbols(symbolA,symbolB);}console.warn(\"No pool found for poolId: \".concat(poolId));return null;}catch(error){console.error('Error fetching pool CID by ID:',error);return null;}}/**\n   * Add liquidity to a pool\n   */async addLiquidity(params){if(!this.hasJwt()){var _res$lpTokenCid,_res$lpAmount;const payload={poolId:params.poolId,amountA:params.amountA.toString(),amountB:params.amountB.toString(),minLPTokens:params.minLPTokens.toString()};console.log('Adding liquidity (auto-resolve pool) with:',payload);const res=await this.request(()=>this.client.post('/api/clearportx/debug/add-liquidity-by-cid',payload));return{lpTokenCid:(_res$lpTokenCid=res===null||res===void 0?void 0:res.lpTokenCid)!==null&&_res$lpTokenCid!==void 0?_res$lpTokenCid:'',lpAmount:(_res$lpAmount=res===null||res===void 0?void 0:res.lpAmount)!==null&&_res$lpAmount!==void 0?_res$lpAmount:params.minLPTokens,historyEntryId:res===null||res===void 0?void 0:res.historyEntryId};}const res=await this.client.post('/api/liquidity/add',params);return res.data;}/**\n   * Add liquidity by explicit pool CID (CID-first path)\n   */async addLiquidityByCid(params){var _res$lpTokenCid2,_res$lpAmount2;const party=this.currentParty();const poolId=params.poolId||'';const visibleCid=await this.ensurePoolCidVisible(params.poolCid,poolId,party);const body={poolCid:visibleCid,poolId,amountA:params.amountA,amountB:params.amountB,minLPTokens:params.minLPTokens};const res=await this.request(()=>this.client.post('/api/clearportx/debug/add-liquidity-by-cid',body));return{lpTokenCid:(_res$lpTokenCid2=res===null||res===void 0?void 0:res.lpTokenCid)!==null&&_res$lpTokenCid2!==void 0?_res$lpTokenCid2:'',lpAmount:(_res$lpAmount2=res===null||res===void 0?void 0:res.lpAmount)!==null&&_res$lpAmount2!==void 0?_res$lpAmount2:params.minLPTokens,historyEntryId:res===null||res===void 0?void 0:res.historyEntryId};}/**\n   * Remove liquidity from a pool\n   */async removeLiquidity(params){const res=await this.client.post('/api/liquidity/remove',params);return res.data;}/**\n   * Calculate swap quote (off-chain estimation)\n   * Use this to show estimated output before executing swap\n   */async calculateSwapQuote(params){// Bind the quote to the exact resolver-selected pool CID to avoid mismatch\nconst party=this.currentParty();const resolvedPoolId=params.poolId||\"\".concat(params.inputSymbol,\"-\").concat(params.outputSymbol);const{poolCid}=await this.resolveAndGrant(resolvedPoolId,party);const poolMeta=await this.request(()=>this.client.get('/api/clearportx/debug/pool-by-cid',{params:{cid:poolCid},headers:{'X-Party':party}}));if(!(poolMeta!==null&&poolMeta!==void 0&&poolMeta.success)){throw new Error('Pool not visible for party');}const symbolA=poolMeta.symbolA;const symbolB=poolMeta.symbolB;const reserveA=parseFloat(poolMeta.reserveA);const reserveB=parseFloat(poolMeta.reserveB);const isAtoB=params.inputSymbol===symbolA&&params.outputSymbol===symbolB;const isBtoA=params.inputSymbol===symbolB&&params.outputSymbol===symbolA;if(!isAtoB&&!isBtoA){throw new Error('Symbol mismatch for selected pool');}const inputAmount=parseFloat(params.inputAmount);// Choose reserves based on trade direction (input -> output)\nconst reserveIn=isAtoB?reserveA:reserveB;const reserveOut=isAtoB?reserveB:reserveA;const feeRate=0.003;// 0.30%\nconst feeBps=feeRate*10000;const feeAmount=inputAmount*feeBps/10000;const inputAfterFee=inputAmount-feeAmount;const outputAmount=inputAfterFee*reserveOut/(reserveIn+inputAfterFee);const priceBefore=reserveOut/reserveIn;const priceAfter=(reserveOut-outputAmount)/(reserveIn+inputAmount);const priceImpact=Math.abs((priceAfter-priceBefore)/priceBefore)*100;return{inputAmount,outputAmount,priceImpact,fee:feeAmount,route:[params.inputSymbol,params.outputSymbol],slippage:0.5};}// Helper: Generate idempotency key for swap\ngenerateIdempotencyKey(){return\"swap-\".concat(Date.now(),\"-\").concat(Math.random().toString(36).substr(2,9));}// Helper: Map backend pool DTO to frontend PoolInfo\nmapPool(data){// Use new tokenA/tokenB objects if available, fallback to deprecated symbolA/symbolB\nconst tokenA=data.tokenA||{symbol:data.symbolA,name:data.symbolA,decimals:10};const tokenB=data.tokenB||{symbol:data.symbolB,name:data.symbolB,decimals:10};return{contractId:data.poolId||'',poolId:data.poolId||'',tokenA:{symbol:tokenA.symbol,name:tokenA.name,decimals:tokenA.decimals,balance:0,contractId:'',logoUrl:this.getTokenLogo(tokenA.symbol)},tokenB:{symbol:tokenB.symbol,name:tokenB.name,decimals:tokenB.decimals,balance:0,contractId:'',logoUrl:this.getTokenLogo(tokenB.symbol)},reserveA:parseFloat(data.reserveA),reserveB:parseFloat(data.reserveB),totalLiquidity:parseFloat(data.totalLPSupply||0),feeRate:data.feeRate||0.003,apr:0,// TODO: Calculate from volume/liquidity metrics\nvolume24h:parseFloat(data.volume24h||0)// Real 24h volume from backend\n};}// Map party-scoped row to PoolInfo (row contains poolId, poolCid, symbolA/B, reserveA/B)\nmapPartyPool(row){const tokenA={symbol:row.symbolA,name:row.symbolA,decimals:10};const tokenB={symbol:row.symbolB,name:row.symbolB,decimals:10};return{// contractId keeps poolId for routing consistency in UI\ncontractId:row.poolId||'',poolId:row.poolId||'',tokenA:{symbol:tokenA.symbol,name:tokenA.name,decimals:tokenA.decimals,balance:0,contractId:'',logoUrl:this.getTokenLogo(tokenA.symbol)},tokenB:{symbol:tokenB.symbol,name:tokenB.name,decimals:tokenB.decimals,balance:0,contractId:'',logoUrl:this.getTokenLogo(tokenB.symbol)},reserveA:parseFloat(row.reserveA||'0'),reserveB:parseFloat(row.reserveB||'0'),totalLiquidity:parseFloat(row.totalLPSupply||row.totalLiquidity||'0'),feeRate:0.003,apr:0,volume24h:0};}// Helper: Map backend token DTO to frontend TokenInfo\nmapToken(data){return{symbol:data.symbol,name:data.name||data.symbol,decimals:data.decimals||10,balance:parseFloat(data.amount||data.quantity||'0'),contractId:data.contractId||'',logoUrl:this.getTokenLogo(data.symbol)};}aggregateTokensBySymbol(tokens){const tokenMap=new Map();for(const token of tokens){const existing=tokenMap.get(token.symbol);if(existing){existing.balance=(existing.balance||0)+(token.balance||0);}else{tokenMap.set(token.symbol,_objectSpread({},token));}}return Array.from(tokenMap.values()).sort((a,b)=>(b.balance||0)-(a.balance||0));}// Helper: Get token logo URL\ngetTokenLogo(symbol){var _symbol$toUpperCase,_process$env$PUBLIC_U;const upper=(symbol===null||symbol===void 0?void 0:(_symbol$toUpperCase=symbol.toUpperCase)===null||_symbol$toUpperCase===void 0?void 0:_symbol$toUpperCase.call(symbol))||symbol;const basePath=\"\".concat((_process$env$PUBLIC_U=process.env.PUBLIC_URL)!==null&&_process$env$PUBLIC_U!==void 0?_process$env$PUBLIC_U:'',\"/tokens\");const logos={CBTC:\"\".concat(basePath,\"/cbtc.png\"),CC:\"\".concat(basePath,\"/cc.svg\"),CANTON:\"\".concat(basePath,\"/cc.svg\"),ETH:'https://cryptologos.cc/logos/ethereum-eth-logo.png',USDC:'https://cryptologos.cc/logos/usd-coin-usdc-logo.png',BTC:'https://cryptologos.cc/logos/bitcoin-btc-logo.png',USDT:'https://cryptologos.cc/logos/tether-usdt-logo.png'};return logos[upper]||'';}async getTransactionHistory(){try{const res=await this.client.get('/api/transactions/recent');const rows=Array.isArray(res.data)?res.data:[];if(!rows.length){return FALLBACK_TRANSACTIONS;}return rows.map(row=>this.normalizeTransactionHistoryEntry(row));}catch(error){console.warn('Falling back to demo transaction history payload:',error);return FALLBACK_TRANSACTIONS;}}normalizeTransactionHistoryEntry(entry){var _ref4,_entry$amountADesired,_entry$amountADesired2,_entry$amountA,_ref5,_entry$amountBDesired,_entry$amountBDesired2,_entry$amountB,_entry$minLpAmount$to,_entry$minLpAmount,_entry$minAmountLp,_entry$lpMintedAmount,_entry$lpMintedAmount2,_entry$lpMintedAmount3;const fallbackId=(entry===null||entry===void 0?void 0:entry.id)||(entry===null||entry===void 0?void 0:entry.transactionId)||\"tx-\".concat(Date.now());return{id:fallbackId,title:(entry===null||entry===void 0?void 0:entry.title)||this.inferTransactionTitle(entry===null||entry===void 0?void 0:entry.type),type:(entry===null||entry===void 0?void 0:entry.type)||'UNKNOWN',status:(entry===null||entry===void 0?void 0:entry.status)||'pending',createdAt:(entry===null||entry===void 0?void 0:entry.createdAt)||(entry===null||entry===void 0?void 0:entry.timestamp)||new Date().toISOString(),expiresAt:entry===null||entry===void 0?void 0:entry.expiresAt,tokenA:(entry===null||entry===void 0?void 0:entry.tokenA)||(entry===null||entry===void 0?void 0:entry.symbolA)||'',tokenB:(entry===null||entry===void 0?void 0:entry.tokenB)||(entry===null||entry===void 0?void 0:entry.symbolB)||'',amountADesired:(_ref4=(_entry$amountADesired=entry===null||entry===void 0?void 0:(_entry$amountADesired2=entry.amountADesired)===null||_entry$amountADesired2===void 0?void 0:_entry$amountADesired2.toString())!==null&&_entry$amountADesired!==void 0?_entry$amountADesired:entry===null||entry===void 0?void 0:(_entry$amountA=entry.amountA)===null||_entry$amountA===void 0?void 0:_entry$amountA.toString())!==null&&_ref4!==void 0?_ref4:'0',amountBDesired:(_ref5=(_entry$amountBDesired=entry===null||entry===void 0?void 0:(_entry$amountBDesired2=entry.amountBDesired)===null||_entry$amountBDesired2===void 0?void 0:_entry$amountBDesired2.toString())!==null&&_entry$amountBDesired!==void 0?_entry$amountBDesired:entry===null||entry===void 0?void 0:(_entry$amountB=entry.amountB)===null||_entry$amountB===void 0?void 0:_entry$amountB.toString())!==null&&_ref5!==void 0?_ref5:'0',minLpAmount:(_entry$minLpAmount$to=entry===null||entry===void 0?void 0:(_entry$minLpAmount=entry.minLpAmount)===null||_entry$minLpAmount===void 0?void 0:_entry$minLpAmount.toString())!==null&&_entry$minLpAmount$to!==void 0?_entry$minLpAmount$to:entry===null||entry===void 0?void 0:(_entry$minAmountLp=entry.minAmountLp)===null||_entry$minAmountLp===void 0?void 0:_entry$minAmountLp.toString(),lpTokenSymbol:entry===null||entry===void 0?void 0:entry.lpTokenSymbol,lpMintedAmount:(_entry$lpMintedAmount=entry===null||entry===void 0?void 0:(_entry$lpMintedAmount2=entry.lpMintedAmount)===null||_entry$lpMintedAmount2===void 0?void 0:(_entry$lpMintedAmount3=_entry$lpMintedAmount2.toString)===null||_entry$lpMintedAmount3===void 0?void 0:_entry$lpMintedAmount3.call(_entry$lpMintedAmount2))!==null&&_entry$lpMintedAmount!==void 0?_entry$lpMintedAmount:entry===null||entry===void 0?void 0:entry.lpMintedAmount,contractId:(entry===null||entry===void 0?void 0:entry.contractId)||(entry===null||entry===void 0?void 0:entry.cid)||'',eventTimeline:Array.isArray(entry===null||entry===void 0?void 0:entry.eventTimeline)&&(entry===null||entry===void 0?void 0:entry.eventTimeline.length)>0?entry.eventTimeline.map((item,index)=>({id:(item===null||item===void 0?void 0:item.id)||\"\".concat(fallbackId,\"-evt-\").concat(index),title:(item===null||item===void 0?void 0:item.title)||'Ledger Event',description:(item===null||item===void 0?void 0:item.description)||'',status:(item===null||item===void 0?void 0:item.status)||'completed',timestamp:item===null||item===void 0?void 0:item.timestamp})):[{id:\"\".concat(fallbackId,\"-evt-0\"),title:'Ledger Event',description:'Event recorded on Canton ledger.',status:'completed',timestamp:(entry===null||entry===void 0?void 0:entry.createdAt)||new Date().toISOString()}]};}inferTransactionTitle(type){switch(type){case'ADD_LIQUIDITY':return'AddLiquidity Transaction';case'SWAP':return'Swap Transaction';case'POOL_CREATION':return'Pool Creation Transaction';case'TOKEN_MINT':return'Token Mint Transaction';default:return'Ledger Transaction';}}}// Export singleton instance\nexport const backendApi=new BackendApiService();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}