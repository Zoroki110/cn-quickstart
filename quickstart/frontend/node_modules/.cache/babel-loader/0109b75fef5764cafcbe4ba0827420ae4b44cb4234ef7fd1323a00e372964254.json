{"ast":null,"code":"import _objectSpread from\"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React from\"react\";import{useCallback,useEffect,useState}from\"react\";import{walletManager}from\"./WalletManager\";import{apiPostJson,clearWalletSession,loadWalletSession,persistWalletSession,setAuthToken}from\"../api/client\";import toast from\"react-hot-toast\";const initialAuthState={token:null,partyId:null,walletType:null,loading:false,error:null};let authState=initialAuthState;const authListeners=new Set();let authHydratedFromSession=false;export function useWalletAuth(){hydrateAuthStateFromSession();const[state,setState]=useState(authState);useEffect(()=>{const listener=next=>setState(next);authListeners.add(listener);return()=>{authListeners.delete(listener);};},[]);useEffect(()=>{try{walletManager.initLoopSdk();walletManager.initZoroSdk();}catch(err){console.warn(\"Wallet init failed\",err);}},[]);const runAuthFlow=useCallback(async connect=>{updateAuthState({loading:true,error:null});let connector=null;try{connector=await connect();if(typeof connector.connect===\"function\"){await connector.connect();}const walletParty=await connector.getParty();const challenge=await requestChallenge(walletParty);const signature=await connector.signMessage(challenge.challenge);const verification=await verifyChallenge(connector,{challengeId:challenge.challengeId,partyId:walletParty,signature});const connectorType=normalizeWalletType(connector.getType());setAuthToken(verification.token);persistWalletSession({token:verification.token,partyId:verification.partyId,walletType:connectorType});updateAuthState({token:verification.token,partyId:verification.partyId,walletType:connectorType});if(typeof window!==\"undefined\"){window.dispatchEvent(new CustomEvent(\"clearportx:wallet:connected\",{detail:{partyId:verification.partyId,walletType:connectorType}}));}return verification;}catch(err){const message=err instanceof Error?err.message:\"Wallet authentication failed\";const lower=(message||\"\").toLowerCase();const hint=lower.includes(\"popup\")||lower.includes(\"timeout\")||lower.includes(\"block\")?\" Allow popups for this site.\":\"\";const finalMessage=\"\".concat(message).concat(hint);updateAuthState({error:finalMessage});toast.error(finalMessage);// Cleanup loop session on failure\ntry{var _connector;if((_connector=connector)!==null&&_connector!==void 0&&_connector.getType&&connector.getType()===\"loop\"){var _disconnect,_ref;await((_disconnect=(_ref=connector).disconnect)===null||_disconnect===void 0?void 0:_disconnect.call(_ref));}}catch(_unused){// ignore cleanup errors\n}throw err instanceof Error?new Error(finalMessage):err;}finally{updateAuthState({loading:false});}},[]);const authenticateWithLoop=useCallback(async()=>{updateAuthState({loading:true,error:null});const connector=walletManager.getOrCreateLoopConnector();const debug=typeof window!==\"undefined\"&&localStorage.getItem(\"clearportx.debug.loop\")===\"1\";const log=function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}if(debug)console.debug(\"[Loop]\",...args);};let pollingTimer=null;const pendingKey=\"clearportx.pending.loop.auth\";const setPending=value=>{if(typeof window===\"undefined\")return;try{if(value){window.sessionStorage.setItem(pendingKey,\"1\");}else{window.sessionStorage.removeItem(pendingKey);}}catch(_unused2){/* ignore */}};const maybeRehydrate=()=>{try{var _hasProvider,_ref2;if(!((_hasProvider=(_ref2=connector).hasProvider)!==null&&_hasProvider!==void 0&&_hasProvider.call(_ref2))){var _tryRehydrateFromStor,_ref3;void((_tryRehydrateFromStor=(_ref3=connector).tryRehydrateFromStorage)===null||_tryRehydrateFromStor===void 0?void 0:_tryRehydrateFromStor.call(_ref3));}}catch(_unused3){// ignore\n}};let cleanup;if(typeof window!==\"undefined\"){const onFocus=()=>maybeRehydrate();const onVisibility=()=>{if(document.visibilityState===\"visible\")maybeRehydrate();};const onStorage=e=>{if(e.key===\"loop_connect\")maybeRehydrate();};window.addEventListener(\"focus\",onFocus);document.addEventListener(\"visibilitychange\",onVisibility);window.addEventListener(\"storage\",onStorage);cleanup=()=>{window.removeEventListener(\"focus\",onFocus);document.removeEventListener(\"visibilitychange\",onVisibility);window.removeEventListener(\"storage\",onStorage);if(pollingTimer!==null)clearInterval(pollingTimer);setPending(false);};// Poll up to 180s to resume without second click.\npollingTimer=window.setInterval(()=>{maybeRehydrate();},500);setTimeout(()=>{if(pollingTimer!==null){clearInterval(pollingTimer);pollingTimer=null;}},180000);}try{log(\"connect started\");setPending(true);connector.connectFromClick();maybeRehydrate();const walletParty=await connector.getParty();log(\"approved provider partyId\",walletParty);log(\"auth: challenge requested\");const challenge=await requestChallenge(walletParty);const signAndVerify=async()=>{log(\"auth: calling provider.signMessage\");const rawSignature=await connector.signMessage(challenge.challenge);log(\"auth: signMessage resolved\");const signature=normalizeLoopSignature(rawSignature);log(\"auth: verify called\",{challengeId:challenge.challengeId,partyId:walletParty,signatureType:typeof signature});return verifyChallenge(connector,{challengeId:challenge.challengeId,partyId:walletParty,signature});};const signAndVerifyWithTimeout=async()=>{return Promise.race([signAndVerify(),new Promise((_,reject)=>setTimeout(()=>reject(new Error(\"Signature timed out after 120s\")),120000))]);};const attemptWithRetry=async()=>{try{return await signAndVerifyWithTimeout();}catch(err){const message=err instanceof Error?err.message:\"Signature failed\";const retryable=/timeout|sign|connection|lost/i.test(message);if(!retryable){throw err;}return await new Promise((resolve,reject)=>{const retry=async()=>{try{const v=await signAndVerifyWithTimeout();resolve(v);}catch(e){reject(e);}};toast.custom(t=>/*#__PURE__*/React.createElement(\"div\",{className:\"bg-white dark:bg-dark-800 border border-gray-200 dark:border-gray-700 rounded-lg p-3 shadow\"},[/*#__PURE__*/React.createElement(\"div\",{key:\"msg\",className:\"text-sm font-semibold text-gray-800 dark:text-gray-100\"},\"Signature required â€” click to retry\"),/*#__PURE__*/React.createElement(\"div\",{key:\"actions\",className:\"mt-2 flex gap-2\"},[/*#__PURE__*/React.createElement(\"button\",{key:\"retry\",className:\"px-3 py-1 rounded bg-emerald-600 text-white text-sm\",onClick:()=>{toast.dismiss(t.id);void retry();}},\"Retry Signature\"),/*#__PURE__*/React.createElement(\"button\",{key:\"cancel\",className:\"px-3 py-1 rounded border text-sm text-gray-600 dark:text-gray-300\",onClick:()=>{toast.dismiss(t.id);reject(err);}},\"Cancel\")])]),{duration:60000});});}};const verification=await attemptWithRetry();const connectorType=normalizeWalletType(connector.getType());setAuthToken(verification.token);persistWalletSession({token:verification.token,partyId:verification.partyId,walletType:connectorType});updateAuthState({token:verification.token,partyId:verification.partyId,walletType:connectorType});if(typeof window!==\"undefined\"){window.dispatchEvent(new CustomEvent(\"clearportx:wallet:connected\",{detail:{partyId:verification.partyId,walletType:connectorType}}));}log(\"auth success\");return verification;}catch(err){const message=err instanceof Error?err.message:\"Wallet authentication failed\";updateAuthState({error:message});toast.error(message);// Keep Loop session intact for manual retry; do not eagerly remove loop_connect here.\nthrow err instanceof Error?err:new Error(message);}finally{updateAuthState({loading:false});if(cleanup)cleanup();}},[]);const authenticateWithDev=useCallback(()=>runAuthFlow(()=>walletManager.connectDev()),[runAuthFlow]);const authenticateWithZoro=useCallback(async()=>{updateAuthState({loading:true,error:null});const connector=walletManager.getOrCreateZoroConnector();const debug=typeof window!==\"undefined\"&&localStorage.getItem(\"clearportx.debug.zoro\")===\"1\";const log=function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}if(debug)console.debug(\"[Zoro]\",...args);};try{connector.connectFromClick();const walletParty=await connector.getParty();log(\"auth: challenge requested\");const challenge=await requestChallenge(walletParty);log(\"auth: calling wallet.signMessage\");const signature=await connector.signMessage(challenge.challenge);log(\"auth: verify called\",{challengeId:challenge.challengeId,partyId:walletParty,signatureType:typeof signature});const verification=await verifyChallenge(connector,{challengeId:challenge.challengeId,partyId:walletParty,signature});const connectorType=normalizeWalletType(connector.getType());setAuthToken(verification.token);persistWalletSession({token:verification.token,partyId:verification.partyId,walletType:connectorType});updateAuthState({token:verification.token,partyId:verification.partyId,walletType:connectorType});if(typeof window!==\"undefined\"){window.dispatchEvent(new CustomEvent(\"clearportx:wallet:connected\",{detail:{partyId:verification.partyId,walletType:connectorType}}));}return verification;}catch(err){const message=err instanceof Error?err.message:\"Wallet authentication failed\";updateAuthState({error:message});toast.error(message);try{var _disconnect2,_ref4;await((_disconnect2=(_ref4=connector).disconnect)===null||_disconnect2===void 0?void 0:_disconnect2.call(_ref4));if(typeof window!==\"undefined\"){window.localStorage.removeItem(\"zoro_connect\");}}catch(_unused4){// ignore cleanup errors\n}throw err instanceof Error?err:new Error(message);}finally{updateAuthState({loading:false});}},[]);const disconnect=useCallback(()=>{clearWalletSession();setAuthToken(null);try{var _walletManager$getLoo,_walletManager$getLoo2,_walletManager$getZor,_walletManager$getZor2;(_walletManager$getLoo=walletManager.getLoopConnector())===null||_walletManager$getLoo===void 0?void 0:(_walletManager$getLoo2=_walletManager$getLoo.disconnect)===null||_walletManager$getLoo2===void 0?void 0:_walletManager$getLoo2.call(_walletManager$getLoo);if(typeof window!==\"undefined\"){window.localStorage.removeItem(\"loop_connect\");}(_walletManager$getZor=walletManager.getZoroConnector())===null||_walletManager$getZor===void 0?void 0:(_walletManager$getZor2=_walletManager$getZor.disconnect)===null||_walletManager$getZor2===void 0?void 0:_walletManager$getZor2.call(_walletManager$getZor);if(typeof window!==\"undefined\"){window.localStorage.removeItem(\"zoro_connect\");}}catch(_unused5){// ignore cleanup errors\n}updateAuthState({token:null,partyId:null,walletType:null,error:null});},[]);return{token:state.token,partyId:state.partyId,walletType:state.walletType,loading:state.loading,error:state.error,authenticateWithLoop,authenticateWithDev,authenticateWithZoro,disconnect};}async function requestChallenge(partyId){return apiPostJson(\"/api/auth/challenge\",{partyId});}async function verifyChallenge(connector,params){return apiPostJson(\"/api/auth/verify\",_objectSpread(_objectSpread({},params),{},{walletType:connector.getType()}));}function normalizeWalletType(value){if(value===\"loop\"||value===\"zoro\"||value===\"dev\"||value===\"unknown\"){return value;}return\"unknown\";}function normalizeLoopSignature(result){if(typeof result===\"string\")return result;if(result&&typeof result.signature===\"string\")return result.signature;if(result&&typeof result.sig===\"string\")return result.sig;if(result&&typeof result.signedMessage===\"string\")return result.signedMessage;if(result&&typeof result.signed_message===\"string\")return result.signed_message;throw new Error(\"Loop signature is not a string\");}function hydrateAuthStateFromSession(){if(authHydratedFromSession){return;}authHydratedFromSession=true;const session=loadWalletSession();if(session!==null&&session!==void 0&&session.token&&session.partyId){setAuthToken(session.token);authState=_objectSpread(_objectSpread({},authState),{},{token:session.token,partyId:session.partyId,walletType:normalizeWalletType(session.walletType)});}}function updateAuthState(patch){authState=_objectSpread(_objectSpread({},authState),patch);authListeners.forEach(listener=>listener(authState));}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}