module TestReserveConsistency where

import Daml.Script
import DA.Time
import DA.Assert
import DA.Math (sqrt)
import DA.List (head)

import qualified Token.Token as T
import qualified AMM.Pool as P
import qualified AMM.SwapRequest as SR

-- Critical Test: Verify Reserves Update Correctly After Swap
-- This tests the CRITICAL-6 fix
testReservesUpdateAfterSwap : Script ()
testReservesUpdateAfterSwap = script do
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Create pool with known reserves
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 100.0
    reserveA = 100.0  -- Initial: 100 ETH
    reserveB = 200000.0  -- Initial: 200k USDC

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 100.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 200000.0

  -- Fetch initial pool state
  poolData <- queryContractId poolOperator pool
  let Some initialPool = poolData
  let initialReserveA = initialPool.reserveA
  let initialReserveB = initialPool.reserveB
  let k_initial = initialReserveA * initialReserveB

  -- Alice swaps 1000 USDC for ETH
  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 1000.0

  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 1000.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 1000

  swapReady <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap

  (aliceETH, newPool) <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap with
    poolTokenACid = poolETH
    poolTokenBCid = poolUSDC

  -- CRITICAL CHECK: Verify reserves were updated
  newPoolData <- queryContractId poolOperator newPool
  let Some updatedPool = newPoolData

  -- Get Alice's output amount
  aliceETHData <- queryContractId alice aliceETH
  let Some aliceETHToken = aliceETHData
  let outputAmount = aliceETHToken.amount

  -- Calculate expected reserves after swap
  -- Input: 1000 USDC → reserve B increases by 1000
  -- Output: ~0.497 ETH → reserve A decreases by ~0.497
  let expectedReserveA = initialReserveA - outputAmount
  let expectedReserveB = initialReserveB + 1000.0

  -- Verify reserves match expected
  assertMsg "Reserve A should decrease by output amount"
    (abs(updatedPool.reserveA - expectedReserveA) < 0.0001)
  assertMsg "Reserve B should increase by input amount"
    (abs(updatedPool.reserveB - expectedReserveB) < 0.0001)

  -- Verify k invariant (should increase due to fees)
  let k_after = updatedPool.reserveA * updatedPool.reserveB
  assertMsg "K should increase after swap (fees)" (k_after >= k_initial)

  -- Verify LP supply unchanged (swaps don't affect LP supply)
  assertMsg "LP supply should remain constant" (updatedPool.totalLPSupply == initialPool.totalLPSupply)

  return ()


-- Test Multiple Consecutive Swaps Update Reserves Correctly
testMultipleSwapsReserveConsistency : Script ()
testMultipleSwapsReserveConsistency = script do
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  charlie <- allocateParty "Charlie"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Pool: 100 ETH, 200k USDC
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 100.0
    reserveA = 100.0
    reserveB = 200000.0

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 100.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 200000.0

  pool0Data <- queryContractId poolOperator pool
  let Some pool0State = pool0Data
  let k0 = pool0State.reserveA * pool0State.reserveB

  -- SWAP 1: Alice swaps 500 USDC → ETH
  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 500.0

  swap1Req <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 500.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 5000

  swap1Ready <- submit alice $ exerciseCmd swap1Req SR.PrepareSwap

  poolTokens1 <- query @T.Token poolParty
  let poolETHs1 = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens1
  let poolUSDCs1 = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens1
  let (poolETHCid1, _) = head poolETHs1
  let (poolUSDCCid1, _) = head poolUSDCs1

  (aliceETH, pool1) <- submit poolParty $ exerciseCmd swap1Ready SR.ExecuteSwap with
    poolTokenACid = poolETHCid1
    poolTokenBCid = poolUSDCCid1

  -- Check pool1 reserves
  pool1Data <- queryContractId poolOperator pool1
  let Some pool1State = pool1Data
  let k1 = pool1State.reserveA * pool1State.reserveB

  assertMsg "K should increase after swap 1" (k1 >= k0)
  assertMsg "Reserve A decreased" (pool1State.reserveA < pool0State.reserveA)
  assertMsg "Reserve B increased" (pool1State.reserveB > pool0State.reserveB)

  -- SWAP 2: Bob swaps 0.5 ETH → USDC
  bobETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = bob
    symbol = "ETH"
    amount = 0.5

  swap2Req <- submit bob $ createCmd SR.SwapRequest with
    trader = bob
    poolCid = pool1
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = bobETH
    inputSymbol = "ETH"
    inputAmount = 0.5
    outputSymbol = "USDC"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 5000

  swap2Ready <- submit bob $ exerciseCmd swap2Req SR.PrepareSwap

  poolTokens2 <- query @T.Token poolParty
  let poolETHs2 = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens2
  let poolUSDCs2 = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens2
  let (poolETHCid2, _) = head poolETHs2
  let (poolUSDCCid2, _) = head poolUSDCs2

  (bobUSDC, pool2) <- submit poolParty $ exerciseCmd swap2Ready SR.ExecuteSwap with
    poolTokenACid = poolETHCid2
    poolTokenBCid = poolUSDCCid2

  -- Check pool2 reserves
  pool2Data <- queryContractId poolOperator pool2
  let Some pool2State = pool2Data
  let k2 = pool2State.reserveA * pool2State.reserveB

  assertMsg "K should increase after swap 2" (k2 >= k1)
  assertMsg "Reserve A increased from swap 1" (pool2State.reserveA > pool1State.reserveA)
  assertMsg "Reserve B decreased from swap 1" (pool2State.reserveB < pool1State.reserveB)

  -- SWAP 3: Charlie swaps 1000 USDC → ETH
  charlieUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = charlie
    symbol = "USDC"
    amount = 1000.0

  swap3Req <- submit charlie $ createCmd SR.SwapRequest with
    trader = charlie
    poolCid = pool2
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = charlieUSDC
    inputSymbol = "USDC"
    inputAmount = 1000.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 5000

  swap3Ready <- submit charlie $ exerciseCmd swap3Req SR.PrepareSwap

  poolTokens3 <- query @T.Token poolParty
  let poolETHs3 = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens3
  let poolUSDCs3 = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens3
  let (poolETHCid3, _) = head poolETHs3
  let (poolUSDCCid3, _) = head poolUSDCs3

  (charlieETH, pool3) <- submit poolParty $ exerciseCmd swap3Ready SR.ExecuteSwap with
    poolTokenACid = poolETHCid3
    poolTokenBCid = poolUSDCCid3

  -- Final check: K should have increased over all swaps (fees accumulated)
  pool3Data <- queryContractId poolOperator pool3
  let Some pool3State = pool3Data
  let k3 = pool3State.reserveA * pool3State.reserveB

  assertMsg "K should increase across all swaps" (k3 >= k0)

  -- All LP supply should remain constant
  assertMsg "LP supply unchanged" (pool3State.totalLPSupply == pool0State.totalLPSupply)

  return ()


-- Test K Invariant Holds After Many Swaps
testKInvariantAfter100Swaps : Script ()
testKInvariantAfter100Swaps = script do
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Large pool for many small swaps
  pool0 <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 1000.0
    reserveA = 1000.0  -- 1000 ETH
    reserveB = 2000000.0  -- 2M USDC

  -- Create large pool tokens
  poolETH0 <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 1000.0

  poolUSDC0 <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 2000000.0

  pool0Data <- queryContractId poolOperator pool0
  let Some pool0State = pool0Data
  let k_initial = pool0State.reserveA * pool0State.reserveB

  -- Perform 10 small swaps (testing 100 would exceed script limits)
  -- Each swap: 10 USDC → ETH (very small, 0.0005% of pool)

  let performSmallSwap = \(poolCid, iteration) -> do
        aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
          issuer = issuerUSDC
          owner = alice
          symbol = "USDC"
          amount = 10.0

        swapReq <- submit alice $ createCmd SR.SwapRequest with
          trader = alice
          poolCid = poolCid
          poolParty
          poolOperator
          issuerA = issuerETH
          issuerB = issuerUSDC
          symbolA = "ETH"
          symbolB = "USDC"
          feeBps = 30
          maxTTL = hours 2
          inputTokenCid = aliceUSDC
          inputSymbol = "USDC"
          inputAmount = 10.0
          outputSymbol = "ETH"
          minOutput = 0.0
          deadline = addRelTime now (hours 1)
          maxPriceImpactBps = 5000

        swapReady <- submit alice $ exerciseCmd swapReq SR.PrepareSwap

        poolTokens <- query @T.Token poolParty
        let poolETHs = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens
        let poolUSDCs = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens
        let (poolETHCid, _) = head poolETHs
        let (poolUSDCCid, _) = head poolUSDCs

        (aliceETH, newPool) <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap with
          poolTokenACid = poolETHCid
          poolTokenBCid = poolUSDCCid

        return newPool

  -- Perform 10 swaps sequentially
  pool1 <- performSmallSwap (pool0, 1)
  pool2 <- performSmallSwap (pool1, 2)
  pool3 <- performSmallSwap (pool2, 3)
  pool4 <- performSmallSwap (pool3, 4)
  pool5 <- performSmallSwap (pool4, 5)
  pool6 <- performSmallSwap (pool5, 6)
  pool7 <- performSmallSwap (pool6, 7)
  pool8 <- performSmallSwap (pool7, 8)
  pool9 <- performSmallSwap (pool8, 9)
  pool10 <- performSmallSwap (pool9, 10)

  -- Verify K increased (fees from 10 swaps)
  pool10Data <- queryContractId poolOperator pool10
  let Some pool10State = pool10Data
  let k_final = pool10State.reserveA * pool10State.reserveB

  assertMsg "K should increase after 10 swaps" (k_final >= k_initial)

  -- Verify no significant precision loss
  let k_increase_ratio = k_final / k_initial
  assertMsg "K should increase by less than 1% (0.3% fee per swap)" (k_increase_ratio < 1.01)
  assertMsg "K should increase by at least 0.01% (fees accumulated)" (k_increase_ratio > 1.0001)

  return ()
