module TestBoundaryConditions where

import Daml.Script
import DA.Time
import DA.Assert

import qualified Token.Token as T
import qualified AMM.Pool as P
import qualified AMM.SwapRequest as SR

-- MEDIUM-1: Test Exactly 10% Swap (Flash Loan Boundary)
testExactly10PercentSwap : Script ()
testExactly10PercentSwap = script do
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Pool: 100 ETH, 200k USDC
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 100.0  -- Fake LP supply for testing
    reserveA = 100.0
    reserveB = 200000.0

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 100.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 200000.0

  -- Alice swaps EXACTLY 20,000 USDC (10% of 200k reserve)
  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 20000.0

  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 20000.0  -- EXACTLY 10% of input reserve
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 5000

  swapReady <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap

  -- Output should be ~9.09 ETH, which is 9.09% of 100 ETH (under 10% limit)
  (aliceETH, _) <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap with
    poolTokenACid = poolETH
    poolTokenBCid = poolUSDC

  -- Verify swap succeeded
  aliceETHData <- queryContractId alice aliceETH
  case aliceETHData of
    None -> assertFail "Alice should have received ETH"
    Some eth -> assertMsg "Alice should receive ~9 ETH" (eth.amount > 8.0 && eth.amount < 10.0)

  return ()


-- Test Just Over 10% Swap (Should Fail)
testJustOver10PercentSwap : Script ()
testJustOver10PercentSwap = script do
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Pool: 100 ETH, 200k USDC
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 100.0
    reserveA = 100.0
    reserveB = 200000.0

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 100.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 200000.0

  -- Alice tries to swap 35,000 USDC (17.5% of reserve, over 15% limit)
  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 35000.0

  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 35000.0  -- Over limit!
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 5000

  swapReady <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap

  -- This should FAIL with "Swap too large"
  submitMustFail poolParty $ exerciseCmd swapReady SR.ExecuteSwap with
    poolTokenACid = poolETH
    poolTokenBCid = poolUSDC

  return ()


-- MEDIUM-2: Test Exactly 50% Price Impact (Boundary)
testExactly50PercentPriceImpact : Script ()
testExactly50PercentPriceImpact = script do
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Small pool to make 50% price impact achievable within 10% volume limit
  -- Pool: 100 ETH, 200k USDC
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 100.0
    reserveA = 100.0
    reserveB = 200000.0

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 100.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 200000.0

  -- Calculate swap size that produces ~50% price impact
  -- With 10 ETH input, price impact is roughly:
  -- pBefore = 200000/100 = 2000
  -- pAfter = (200000 - output) / (100 + 10)
  -- For 50% impact: pAfter = 2000 * 0.5 = 1000
  -- So: (200000 - output) / 110 = 1000 â†’ output = 90,000
  -- This requires input that produces 90,000 output

  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 15.0  -- 15% of 100 ETH (at limit)

  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceETH
    inputSymbol = "ETH"
    inputAmount = 10.0
    outputSymbol = "USDC"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 5000  -- Allow 50% max

  swapReady <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap

  (aliceUSDC, _) <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap with
    poolTokenACid = poolETH
    poolTokenBCid = poolUSDC

  -- Verify swap succeeded
  aliceUSDCData <- queryContractId alice aliceUSDC
  case aliceUSDCData of
    None -> assertFail "Alice should have received USDC"
    Some usdc -> assertMsg "Alice should receive USDC" (usdc.amount > 0.0)

  return ()


-- Test Over 50% Price Impact (Should Fail)
testOver50PercentPriceImpact : Script ()
testOver50PercentPriceImpact = script do
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 100.0
    reserveA = 100.0
    reserveB = 200000.0

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 100.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 200000.0

  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 15.0

  -- Try to create swap with maxPriceImpactBps > 5000 (should fail validation)
  swapRequestBad <- submitMustFail alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceETH
    inputSymbol = "ETH"
    inputAmount = 15.0
    outputSymbol = "USDC"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 10000  -- 100% (should be rejected)

  return ()


-- Test Exactly Minimum Liquidity (0.001)
testExactlyMinimumLiquidity : Script ()
testExactlyMinimumLiquidity = script do
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Empty pool
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0

  -- Alice adds EXACTLY minimum liquidity
  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 0.001  -- Exactly minimum

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 0.001  -- Exactly minimum

  (aliceLP, pool1) <- submitMulti [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.AddLiquidity with
    provider = alice
    tokenACid = aliceETH
    tokenBCid = aliceUSDC
    amountA = 0.001
    amountB = 0.001
    minLPTokens = 0.0
    deadline = addRelTime now (hours 1)

  -- Verify LP tokens minted
  aliceLPData <- queryContractId alice aliceLP
  case aliceLPData of
    None -> assertFail "Alice should have LP tokens"
    Some lp -> assertMsg "LP amount should be positive" (lp.amount > 0.0)

  return ()


-- Test Below Minimum Liquidity (Should Fail)
testBelowMinimumLiquidity : Script ()
testBelowMinimumLiquidity = script do
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0

  -- Alice tries to add LESS than minimum liquidity
  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 0.0009  -- Below 0.001 minimum

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 0.0009

  -- Should FAIL with "Minimum liquidity not met"
  submitMultiMustFail [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.AddLiquidity with
    provider = alice
    tokenACid = aliceETH
    tokenBCid = aliceUSDC
    amountA = 0.0009
    amountB = 0.0009
    minLPTokens = 0.0
    deadline = addRelTime now (hours 1)

  return ()


-- Test Exactly 1 Hour Deadline
testExactly1HourDeadline : Script ()
testExactly1HourDeadline = script do
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 100.0
    reserveA = 100.0
    reserveB = 200000.0

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 100.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 200000.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 1000.0

  -- Create swap with EXACTLY 1 hour deadline (maximum allowed)
  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 1000.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)  -- EXACTLY 1 hour
    maxPriceImpactBps = 1000

  swapReady <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap

  -- Execute immediately (should succeed)
  (aliceETH, _) <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap with
    poolTokenACid = poolETH
    poolTokenBCid = poolUSDC

  aliceETHData <- queryContractId alice aliceETH
  case aliceETHData of
    None -> assertFail "Swap should succeed with 1 hour deadline"
    Some _ -> return ()

  return ()


-- Test Over 1 Hour Deadline (Should Fail)
testOver1HourDeadline : Script ()
testOver1HourDeadline = script do
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 100.0
    reserveA = 100.0
    reserveB = 200000.0

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 100.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 200000.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 1000.0

  -- Create swap with deadline > 1 hour (should fail validation)
  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 1000.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = addRelTime now (hours 2)  -- 2 hours (over limit)
    maxPriceImpactBps = 1000

  swapReady <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap

  -- Execute should FAIL with "Deadline too far in future"
  submitMustFail poolParty $ exerciseCmd swapReady SR.ExecuteSwap with
    poolTokenACid = poolETH
    poolTokenBCid = poolUSDC

  return ()
