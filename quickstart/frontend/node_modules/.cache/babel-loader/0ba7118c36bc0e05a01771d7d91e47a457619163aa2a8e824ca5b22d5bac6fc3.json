{"ast":null,"code":"import _objectSpread from\"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";var _ref,_ref2,_sdkModule$loop;import*as loopModule from\"@fivenorth/loop-sdk\";import{setLoopProvider}from\"../loop/loopProvider\";import{submitTx}from\"../loop/submitTx\";const DEBUG=typeof window!==\"undefined\"&&localStorage.getItem(\"clearportx.debug.loop\")===\"1\";const POPUP_HINT=\"Allow popups for this site.\";const CONNECT_TIMEOUT_MS=120000;const sdkModule=loopModule;const resolvedLoopApi=(_ref=(_ref2=(_sdkModule$loop=sdkModule.loop)!==null&&_sdkModule$loop!==void 0?_sdkModule$loop:sdkModule.Loop)!==null&&_ref2!==void 0?_ref2:sdkModule.default)!==null&&_ref!==void 0?_ref:sdkModule;let loopApi=resolvedLoopApi;let initDone=false;let activeConnector=null;export class LoopWalletConnector{constructor(){this.provider=null;this.connectPromise=null;this.pendingResolve=null;this.pendingReject=null;this.pendingTimer=null;}static initOnce(){if(initDone)return;if(DEBUG)console.debug(\"[Loop] init called\");if(!loopApi||typeof loopApi.init!==\"function\"||typeof loopApi.connect!==\"function\"){throw new Error(\"Loop SDK is unavailable (missing init/connect)\");}loopApi.init({appName:\"ClearportX\",network:\"devnet\",options:{openMode:\"popup\",requestSigningMode:\"popup\",redirectUrl:typeof window!==\"undefined\"?window.location.href:undefined},onAccept:provider=>{var _activeConnector;if(DEBUG)console.debug(\"[Loop] onAccept keys\",Object.keys(provider||{}),\"signMessage?\",typeof(provider===null||provider===void 0?void 0:provider.signMessage),\"getHolding?\",typeof(provider===null||provider===void 0?void 0:provider.getHolding));(_activeConnector=activeConnector)===null||_activeConnector===void 0?void 0:_activeConnector.handleAccept(provider);},onReject:()=>{var _activeConnector2;if(DEBUG)console.debug(\"[Loop] onReject\");(_activeConnector2=activeConnector)===null||_activeConnector2===void 0?void 0:_activeConnector2.handleReject(new Error(\"Loop connection rejected\"));}});initDone=true;}async connect(){if(this.provider)return;if(this.connectPromise){await this.connectPromise;return;}activeConnector=this;if(!initDone){LoopWalletConnector.initOnce();}this.ensureConnectPromise(false);await this.connectPromise;}/**\n   * Should be called directly from the click handler (no async/await before calling).\n   */connectFromClick(){activeConnector=this;if(!initDone){LoopWalletConnector.initOnce();}if(DEBUG)console.debug(\"[Loop] connect called in click stack at\",Date.now());this.ensureConnectPromise(true);return this.connectPromise;}async getParty(){var _ref3,_this$provider$party_,_this$provider,_this$provider2,_this$provider3;await this.connect();if(DEBUG)console.debug(\"[Loop] provider ready (getParty)\");const party=(_ref3=(_this$provider$party_=(_this$provider=this.provider)===null||_this$provider===void 0?void 0:_this$provider.party_id)!==null&&_this$provider$party_!==void 0?_this$provider$party_:(_this$provider2=this.provider)===null||_this$provider2===void 0?void 0:_this$provider2.partyId)!==null&&_ref3!==void 0?_ref3:(_this$provider3=this.provider)===null||_this$provider3===void 0?void 0:_this$provider3.party;if(!party){throw new Error(\"Loop connect succeeded but partyId is missing. Allow popups and retry.\");}return party;}async getPartyId(){return this.getParty();}async signMessage(message){var _this$provider4;await this.ensureConnectedOrThrow();if(DEBUG)console.debug(\"[Loop] provider ready (signMessage)\");const signer=(_this$provider4=this.provider)===null||_this$provider4===void 0?void 0:_this$provider4.signMessage;if(!signer){throw new Error(\"Loop wallet does not expose signMessage()\");}const raw=await signer.call(this.provider,message);const normalized=this.normalizeSignature(raw);if(DEBUG)console.debug(\"[Loop] signMessage result type\",typeof raw,\"len\",typeof normalized===\"string\"?normalized.length:0);return normalized;}normalizeSignature(res){var _res$signature,_res$signature2;if(typeof res===\"string\")return res;if(res&&typeof res.signature===\"string\")return res.signature;if(res&&typeof res.sig===\"string\")return res.sig;if(res&&typeof res.signedMessage===\"string\")return res.signedMessage;if(res&&typeof res.signed_message===\"string\")return res.signed_message;if(res&&typeof((_res$signature=res.signature)===null||_res$signature===void 0?void 0:_res$signature.hex)===\"string\")return res.signature.hex;if(res&&typeof((_res$signature2=res.signature)===null||_res$signature2===void 0?void 0:_res$signature2.value)===\"string\")return res.signature.value;throw new Error(\"Unsupported Loop signMessage response: \"+JSON.stringify(Object.keys(res||{})));}async getHoldings(){var _this$provider5;await this.ensureConnectedOrThrow();if(DEBUG)console.debug(\"[Loop] provider ready (getHoldings)\");const gh=(_this$provider5=this.provider)===null||_this$provider5===void 0?void 0:_this$provider5.getHolding;if(typeof gh!==\"function\"){throw new Error(\"Loop provider does not expose getHolding()\");}return gh.call(this.provider);}async getAccount(){var _this$provider6;await this.ensureConnectedOrThrow();if(DEBUG)console.debug(\"[Loop] provider ready (getAccount)\");const ga=(_this$provider6=this.provider)===null||_this$provider6===void 0?void 0:_this$provider6.getAccount;if(typeof ga!==\"function\"){throw new Error(\"Loop provider does not expose getAccount()\");}return ga.call(this.provider);}async getActiveContracts(args){var _this$provider7;await this.ensureConnectedOrThrow();if(DEBUG)console.debug(\"[Loop] provider ready (getActiveContracts)\");const gac=(_this$provider7=this.provider)===null||_this$provider7===void 0?void 0:_this$provider7.getActiveContracts;if(typeof gac!==\"function\"){throw new Error(\"Loop provider does not expose getActiveContracts()\");}return gac.call(this.provider,args);}async submitTransaction(cmd,opts){var _ref4,_ref5,_cmd$actAs,_this$provider8,_this$provider9,_this$provider0,_cmd$deduplicationKey;await this.ensureConnectedOrThrow();if(DEBUG)console.debug(\"[Loop] provider ready (submitTransaction)\");const commands=Array.isArray(cmd===null||cmd===void 0?void 0:cmd.commands)?cmd.commands:Array.isArray(cmd)?cmd:[];const actAs=(_ref4=(_ref5=(_cmd$actAs=cmd===null||cmd===void 0?void 0:cmd.actAs)!==null&&_cmd$actAs!==void 0?_cmd$actAs:(_this$provider8=this.provider)===null||_this$provider8===void 0?void 0:_this$provider8.party_id)!==null&&_ref5!==void 0?_ref5:(_this$provider9=this.provider)===null||_this$provider9===void 0?void 0:_this$provider9.partyId)!==null&&_ref4!==void 0?_ref4:(_this$provider0=this.provider)===null||_this$provider0===void 0?void 0:_this$provider0.party;const readAs=cmd===null||cmd===void 0?void 0:cmd.readAs;const deduplicationKey=(_cmd$deduplicationKey=cmd===null||cmd===void 0?void 0:cmd.deduplicationKey)!==null&&_cmd$deduplicationKey!==void 0?_cmd$deduplicationKey:cmd===null||cmd===void 0?void 0:cmd.commandId;const result=await submitTx({commands,actAs,readAs,deduplicationKey,memo:opts===null||opts===void 0?void 0:opts.memo,estimateTraffic:opts===null||opts===void 0?void 0:opts.estimateTraffic,mode:opts===null||opts===void 0?void 0:opts.mode});if(typeof window!==\"undefined\"&&(process.env.REACT_APP_ENV===\"devnet\"||window.location.hostname===\"localhost\")){try{console.debug(\"[Loop][devnet] submitTx result\",result);}catch(_unused){/* ignore */}}return result;}/**\n   * Accept an incoming CBTC TransferInstruction via Loop SDK.\n   *\n   * Flow:\n   * 1. User provides the TransferInstruction contractId (extracted from TransferOffer)\n   * 2. Loop SDK submits TransferInstruction_Accept on the TI interface\n   * 3. Loop backend automatically provides disclosedContracts via authenticated registry access\n   * 4. Returns the update containing the new CBTC Holding owned by receiver\n   *\n   * @param params.transferInstructionCid - Contract ID of the TransferInstruction to accept\n   * @param params.receiverParty - Party accepting the CBTC (typically ClearportX operator)\n   * @returns Promise with updateId and created contracts info\n   */async acceptIncomingCbtcOffer(params){await this.ensureConnectedOrThrow();const requestId=\"loop-accept-\".concat(Date.now());if(DEBUG)console.debug(\"[Loop] acceptIncomingCbtcOffer called\",_objectSpread(_objectSpread({},params),{},{requestId}));// Use TransferInstruction interface from Splice API token standard\n// This is the correct template for CBTC acceptance (NOT TransferOffer)\nconst templateId=\"#splice-api-token-transfer-instruction-v1:Splice.Api.Token.TransferInstructionV1:TransferInstruction\";const command={commands:[{ExerciseCommand:{templateId,contractId:params.transferInstructionCid,choice:\"TransferInstruction_Accept\",choiceArgument:{}}}]};try{if(DEBUG)console.debug(\"[Loop] Submitting CBTC Accept command:\",{command,requestId});const result=await submitTx({commands:command.commands,actAs:[params.receiverParty],readAs:[params.receiverParty],deduplicationKey:requestId,mode:\"WAIT\"});if(DEBUG)console.debug(\"[Loop] CBTC Accept result:\",{requestId,result});if(!result.ok){return{updateId:\"\",createdContracts:[],success:false,error:result.error.message};}if(result.value.txStatus!==\"SUCCEEDED\"){return{updateId:result.value.ledgerUpdateId||\"\",createdContracts:[],success:false,error:result.value.failures?JSON.stringify(result.value.failures):\"Transaction failed\"};}return{updateId:result.value.ledgerUpdateId||\"\",createdContracts:[],success:true};}catch(err){const errorMessage=(err===null||err===void 0?void 0:err.message)||String(err);console.error(\"[Loop] CBTC Accept failed:\",errorMessage);return{updateId:\"\",createdContracts:[],success:false,error:errorMessage};}}async disconnect(){await this.cleanupAndDisconnect();this.clearPending();}async cleanupAfterFailure(){await this.cleanupAndDisconnect(true);this.clearPending();}getProvider(){return this.provider;}getType(){return\"loop\";}/**\n   * Non-intrusive connectivity check (no prompts).\n   * Returns current connection status without triggering UI.\n   */async checkConnected(){if(this.provider){return{connected:true};}try{const rehydrated=await this.tryRehydrateFromStorage();if(rehydrated&&this.provider){return{connected:true};}}catch(_unused2){/* ignore */}return{connected:false,error:\"Not connected.\"};}/**\n   * Ensure Loop session is usable. Tries reconnect once if needed.\n   */async ensureConnected(requestId){const status=await this.checkConnected();if(status.connected)return status;if(DEBUG)console.debug(\"[Loop] ensureConnected attempt connect\",{requestId});try{await this.connect();}catch(err){const msg=(err===null||err===void 0?void 0:err.message)||\"Not connected.\";if(DEBUG)console.debug(\"[Loop] ensureConnected connect failed\",msg,{requestId});return{connected:false,error:msg};}const after=await this.checkConnected();if(!after.connected&&DEBUG){console.debug(\"[Loop] ensureConnected still not connected\",{requestId});}return after.connected?after:{connected:false,error:\"Not connected.\"};}async ensureConnectedOrThrow(){if(this.provider)return;await this.connect();if(!this.provider){console.warn(\"Loop provider missing after connect()\");throw new Error(\"Loop wallet did not provide a provider after connect()\");}}async handleAccept(provider){var _ref6,_provider$party_id,_provider$getAccount;this.provider=provider;setLoopProvider(provider);const partyId=(_ref6=(_provider$party_id=provider.party_id)!==null&&_provider$party_id!==void 0?_provider$party_id:provider.partyId)!==null&&_ref6!==void 0?_ref6:provider.party;if(DEBUG)console.debug(\"[Loop] approved provider keys\",Object.keys(provider||{}),\"partyId\",partyId);const checker=(_provider$getAccount=provider.getAccount)!==null&&_provider$getAccount!==void 0?_provider$getAccount:provider.getHolding;if(typeof checker===\"function\"){try{await checker.call(provider);if(DEBUG)console.debug(\"[Loop] sanity check passed\");}catch(err){if(DEBUG)console.debug(\"[Loop] sanity check failed\",err);this.provider=null;this.handleReject(err);return;}}if(this.pendingResolve)this.pendingResolve();this.clearPending();}handleReject(err){if(this.pendingReject){this.pendingReject(err);}void this.cleanupAndDisconnect(true);this.clearPending();}clearPending(){if(this.pendingTimer){clearTimeout(this.pendingTimer);}this.pendingTimer=null;this.pendingResolve=null;this.pendingReject=null;this.connectPromise=null;}hasProvider(){return!!this.provider;}/**\n   * Attempt to resume a session if the SDK has already stored loop_connect.\n   * This should be called when the user returns focus from the Loop tab or when storage changes.\n   */async tryRehydrateFromStorage(){if(this.provider)return true;if(this.connectPromise)return true;if(typeof window===\"undefined\")return false;const stored=window.localStorage.getItem(\"loop_connect\");if(!stored)return false;let parsed=null;try{parsed=JSON.parse(stored);}catch(_unused3){return false;}const hasSession=!!(parsed&&(parsed.partyId||parsed.party_id||parsed.party)&&parsed.authToken);if(!hasSession)return false;if(DEBUG)console.debug(\"[Loop] tryRehydrateFromStorage found session, calling connect()\");try{this.ensureConnectPromise(false);return true;}catch(err){if(DEBUG)console.debug(\"[Loop] rehydrate failed\",err);return false;}}ensureConnectPromise(fromClick){if(this.provider)return;if(this.connectPromise)return;const startTs=Date.now();this.connectPromise=new Promise((resolve,reject)=>{this.pendingResolve=resolve;this.pendingReject=reject;this.pendingTimer=setTimeout(()=>{if(DEBUG)console.debug(\"[Loop] connect timeout\");this.clearPending();void this.cleanupAndDisconnect(true);reject(new Error(\"Loop connect timeout. \".concat(POPUP_HINT)));},CONNECT_TIMEOUT_MS);try{var _loopApi$connect;if(DEBUG)console.debug(\"[Loop] calling loop.connect NOW\",startTs,\"fromClick\",fromClick);loopApi===null||loopApi===void 0?void 0:(_loopApi$connect=loopApi.connect)===null||_loopApi$connect===void 0?void 0:_loopApi$connect.call(loopApi);}catch(err){this.clearPending();void this.cleanupAndDisconnect(true);reject(err);}});}async cleanupAndDisconnect(){let clearSession=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this.provider=null;setLoopProvider(null);this.clearLoopStorage(clearSession);try{var _loopApi$disconnect;await(loopApi===null||loopApi===void 0?void 0:(_loopApi$disconnect=loopApi.disconnect)===null||_loopApi$disconnect===void 0?void 0:_loopApi$disconnect.call(loopApi));}catch(_unused4){// ignore\n}}clearLoopStorage(clearSession){try{if(typeof window!==\"undefined\"){window.localStorage.removeItem(\"loop_connect\");if(clearSession){window.localStorage.removeItem(\"clearportx.wallet.session\");}}}catch(_unused5){// ignore storage errors\n}}}// Netlify redeploy marker: do not remove. This forces a fresh build.","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}