module LocalTestSwap where

import Daml.Script
import DA.Time
import DA.List (head)

import qualified Token.Token as T
import qualified AMM.SwapRequest as SR
import qualified AMM.Pool as P
import qualified AMM.Receipt as R
import Test.TestHelpers (createPoolWithLiquidity)
import qualified LPToken.LPToken as LP

-- Test un swap: Alice swap 5000 USDC → ETH
testLocalSwap : Script ()
testLocalSwap = script do
  -- Setup parties
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"
  lpProvider <- allocateParty "LPProvider"

  now <- getTime

  -- Create pool with liquidity (100 ETH, 200,000 USDC)
  poolCid <- createPoolWithLiquidity poolOperator poolParty lpIssuer issuerETH issuerUSDC lpProvider clearportx "ETH" "USDC" 100.0 200000.0

  Some pool <- queryContractId poolOperator poolCid

  debug $ "Created pool: " <> pool.poolId
  debug $ "Reserves: " <> show pool.reserveA <> " ETH, " <> show pool.reserveB <> " USDC"

  -- Create Alice's USDC token
  aliceUSDCCid <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 5000.0

  debug $ "Alice has: 5000.0 USDC"

  -- Créer swap request: 5000 USDC → ETH
  swapReq <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceUSDCCid
    inputSymbol = "USDC"
    inputAmount = 5000.0
    outputSymbol = "ETH"
    minOutput = 2.0  -- Minimum 2 ETH attendu
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 500  -- Max 5% impact

  debug "📝 Swap request created"

  -- Prepare swap (transfer USDC to pool)
  (swapReady, _) <- submit alice $ exerciseCmd swapReq SR.PrepareSwap with protocolFeeReceiver = clearportx

  debug "✅ Swap prepared (USDC transferred to pool)"

  -- Execute swap (no longer needs poolTokenACid/poolTokenBCid parameters)
  receiptCid <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap

  -- Vérifier résultat depuis Receipt
  receipt <- queryContractId alice receiptCid
  let Some swapReceipt = receipt

  aliceNewETH <- queryContractId alice swapReceipt.outputTokenCid
  let Some ethReceived = aliceNewETH

  newPoolData <- queryContractId poolOperator swapReceipt.newPoolCid
  let Some newPoolState = newPoolData

  debug ""
  debug "🎉 SWAP SUCCESSFUL!"
  debug $ "   Alice swapped: 5,000 USDC"
  debug $ "   Alice received: " <> show ethReceived.amount <> " ETH"
  debug $ "   New pool reserves: " <> show newPoolState.reserveA <> " ETH, " <> show newPoolState.reserveB <> " USDC"
  debug $ "   Effective price: " <> show (5000.0 / ethReceived.amount) <> " USDC/ETH"

  return ()
