# Frontend Integration Guide v2.1.0-hardened

**ClearportX DEX Backend Integration Requirements**

## Mandatory HTTP Headers

### 1. Authorization (Required)
```typescript
headers: {
  'Authorization': `Bearer ${jwtToken}`
}
```
- JWT token from Keycloak OAuth2 flow
- Must contain valid `sub` claim mapping to Canton party

### 2. X-Idempotency-Key (Required for POST requests)
```typescript
headers: {
  'X-Idempotency-Key': `swap-${userId}-${timestamp}-${nonce}`
}
```

**Critical Rules:**
- **STABLE on retry**: Same key = same request
- **NEVER mutate payload** between retries with same key
- **Body-hash validation**: Backend validates SHA-256(body) matches key
- Format: any unique string, stable across retries
- TTL: 15 minutes server-side cache

**Example:**
```typescript
const idempotencyKey = `swap-${userAddress}-${Date.now()}-${randomUUID()}`;

// First attempt
await executeSwap(payload, idempotencyKey);

// Retry on 429 - SAME key, SAME payload
await sleep(retryAfterSeconds * 1000);
await executeSwap(payload, idempotencyKey); // ✓ Safe
```

**Anti-pattern (will fail with 400 IDEMPOTENCY_KEY_BODY_MISMATCH):**
```typescript
// ✗ WRONG: Same key, different payload
await executeSwap({ amount: 100 }, 'key-123');
await executeSwap({ amount: 200 }, 'key-123'); // 400 error
```

### 3. X-Request-ID (Optional but recommended)
```typescript
headers: {
  'X-Request-ID': randomUUID()
}
```
- Auto-generated by backend if missing
- Returned in response header for log correlation
- Use for debugging/support tickets

## Handling 429 Rate Limit Responses

### Response Format
```json
HTTP/1.1 429 Too Many Requests
Retry-After: 3
X-Request-ID: abc-123-def
Content-Type: application/json

{
  "error": "RATE_LIMIT_EXCEEDED",
  "message": "Rate limit exceeded - max 2 requests per 5 seconds globally, 10 requests per minute per party",
  "status": 429,
  "timestamp": "2025-10-21T16:45:32.123Z",
  "path": "/api/swap/atomic",
  "requestId": "abc-123-def",
  "retryAfter": 3
}
```

### Retry Logic (Required)
```typescript
interface ErrorResponse {
  error: string;
  message: string;
  status: number;
  timestamp: string;
  path: string;
  requestId: string;
  retryAfter?: number; // Present on 429 responses
}

async function executeSwapWithRetry(
  payload: SwapRequest,
  idempotencyKey: string,
  maxRetries = 3
): Promise<SwapResponse> {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await axios.post('/api/swap/atomic', payload, {
        headers: {
          'Authorization': `Bearer ${jwtToken}`,
          'X-Idempotency-Key': idempotencyKey, // STABLE
          'X-Request-ID': randomUUID(),
          'Content-Type': 'application/json'
        }
      });
    } catch (error) {
      if (error.response?.status === 429) {
        const retryAfter = error.response.data.retryAfter ||
                          parseInt(error.response.headers['retry-after']) ||
                          5;

        console.log(`Rate limited - waiting ${retryAfter}s (attempt ${attempt + 1}/${maxRetries})`);

        if (attempt < maxRetries - 1) {
          await sleep(retryAfter * 1000);
          continue; // Retry with SAME idempotencyKey
        }
      }
      throw error;
    }
  }
}
```

**Critical: Retry-After is an integer ≥1 second**
- Header: `Retry-After: 3` (integer)
- JSON: `"retryAfter": 3` (integer)
- Always identical between header and body

## Error Response Parsing

### Standard Error Format
```typescript
interface ErrorResponse {
  error: string;          // Error code (RATE_LIMIT_EXCEEDED, etc.)
  message: string;        // Human-readable message
  status: number;         // HTTP status code
  timestamp: string;      // ISO 8601
  path: string;           // Request path
  requestId: string;      // X-Request-ID for correlation
  retryAfter?: number;    // Only on 429
  details?: any;          // Optional context
}
```

### Common Error Codes

| Code | Status | Meaning | Action |
|------|--------|---------|--------|
| `RATE_LIMIT_EXCEEDED` | 429 | Too many requests | Wait `retryAfter` seconds, retry with same key |
| `IDEMPOTENCY_KEY_BODY_MISMATCH` | 400 | Same key, different payload | Use new key or keep payload stable |
| `CONTRACT_NOT_FOUND` | 409 | Stale pool/token CID | Refresh ACS, retry |
| `INSUFFICIENT_FUNDS` | 422 | Not enough balance | Show user balance error |
| `SLIPPAGE_PROTECTION` | 422 | Price moved too much | Increase `maxPriceImpactBps` or retry |
| `DEADLINE_EXPIRED` | 408 | Swap took too long | Retry with new deadline |

### Error Handling Example
```typescript
try {
  const response = await executeSwap(payload, idempotencyKey);
  return response.data;
} catch (error) {
  const errorData: ErrorResponse = error.response?.data;

  switch (errorData.error) {
    case 'RATE_LIMIT_EXCEEDED':
      // Wait and retry
      await sleep(errorData.retryAfter! * 1000);
      return executeSwap(payload, idempotencyKey);

    case 'IDEMPOTENCY_KEY_BODY_MISMATCH':
      // Critical: Payload changed between retries
      console.error('Idempotency violation - payload mutated!');
      throw new Error('Cannot retry - request changed');

    case 'CONTRACT_NOT_FOUND':
      // Refresh pool list from /api/pools
      await refreshPools();
      return executeSwap(payload, generateNewKey());

    case 'INSUFFICIENT_FUNDS':
      // Show user-friendly error
      showError(`Insufficient balance: ${errorData.message}`);
      break;

    case 'SLIPPAGE_PROTECTION':
      // Ask user to increase slippage tolerance
      showSlippageWarning();
      break;

    default:
      // Log with requestId for support
      console.error(`Error ${errorData.requestId}: ${errorData.message}`);
      throw error;
  }
}
```

## API Endpoints

### POST /api/swap/atomic
**Atomic one-step swap (recommended)**

Request:
```json
{
  "poolId": "optional-pool-id",  // Auto-discover if omitted
  "inputSymbol": "USDC",
  "inputAmount": "1000.0000000000",  // 10 decimal places
  "outputSymbol": "ETH",
  "minOutput": "0.3000000000",
  "maxPriceImpactBps": 100  // 1% = 100 basis points
}
```

Response (200 OK):
```json
{
  "receiptCid": "00abc123...",
  "trader": "alice::1220...",
  "inputSymbol": "USDC",
  "outputSymbol": "ETH",
  "inputAmount": "1000.0000000000",
  "outputAmount": "0.3245123456",
  "timestamp": "2025-10-21T16:45:32.123Z"
}
```

### POST /api/liquidity/add
**Add liquidity to pool**

Request:
```json
{
  "poolId": "ETH-USDC",
  "amountA": "1.0000000000",
  "amountB": "3000.0000000000",
  "minLPTokens": "54.0000000000"
}
```

Response (200 OK):
```json
{
  "lpTokenCid": "00def456...",
  "poolId": "ETH-USDC",
  "lpTokensIssued": "54.7722557505"
}
```

### POST /api/liquidity/remove
**Remove liquidity from pool**

Request:
```json
{
  "poolId": "ETH-USDC",
  "lpTokenAmount": "50.0000000000",
  "minAmountA": "0.9000000000",
  "minAmountB": "2700.0000000000"
}
```

### GET /api/pools
**List all active pools**

Response:
```json
[
  {
    "poolId": "ETH-USDC",
    "symbolA": "ETH",
    "symbolB": "USDC",
    "reserveA": "100.0000000000",
    "reserveB": "300000.0000000000",
    "feeBps": 30,
    "kInvariant": 30000000.0000000000
  }
]
```

### GET /api/health/ledger
**Health check (no auth required)**

Response:
```json
{
  "status": "OK",
  "synced": true,
  "atomicSwapAvailable": true,
  "darVersion": "1.0.1",
  "poolsActive": 33,
  "pqsOffset": 3573,
  "clearportxContractCount": 590
}
```

## Rate Limiting Configuration

**Devnet Limits:**
- Global: **2 requests per 5 seconds** (0.4 TPS)
- Per-party: **10 requests per minute** (0.17 TPS sustained)

**Expected 429 rate under normal load:**
- Peak traffic: 10-20% of requests may be rate-limited
- Sustained load >0.4 TPS will trigger 429s
- Retry logic is **mandatory** for production

## Security Best Practices

1. **Never log JWT tokens** (sensitive credentials)
2. **Always validate error responses** before retry
3. **Implement exponential backoff** for non-429 errors
4. **Store idempotency keys** for audit trail
5. **Show user-friendly errors** (not raw backend messages)
6. **Implement request timeout** (10s recommended)
7. **Validate input amounts** client-side (10 decimal places)

## Testing Checklist

- [ ] 200 OK response parsing
- [ ] 429 rate limit handling with Retry-After
- [ ] Idempotency key stability across retries
- [ ] X-Request-ID correlation in logs
- [ ] Error response parsing (all codes)
- [ ] Network timeout handling
- [ ] JWT expiration refresh
- [ ] Pool refresh on CONTRACT_NOT_FOUND
- [ ] Slippage protection UI
- [ ] Insufficient balance error display

## Example: React Hook

```typescript
import { useState } from 'react';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';

interface SwapRequest {
  inputSymbol: string;
  inputAmount: string;
  outputSymbol: string;
  minOutput: string;
  maxPriceImpactBps: number;
}

export function useAtomicSwap(jwtToken: string) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const executeSwap = async (request: SwapRequest) => {
    setLoading(true);
    setError(null);

    const idempotencyKey = `swap-${uuidv4()}`;
    const requestId = uuidv4();

    try {
      const response = await axios.post(
        '/api/swap/atomic',
        request,
        {
          headers: {
            'Authorization': `Bearer ${jwtToken}`,
            'X-Idempotency-Key': idempotencyKey,
            'X-Request-ID': requestId,
            'Content-Type': 'application/json'
          },
          timeout: 10000
        }
      );

      return response.data;
    } catch (err: any) {
      if (err.response?.status === 429) {
        const retryAfter = err.response.data.retryAfter || 5;
        setError(`Rate limited - retry in ${retryAfter}s`);

        // Auto-retry after delay
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        return executeSwap(request); // Recursive retry
      }

      setError(err.response?.data?.message || 'Swap failed');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return { executeSwap, loading, error };
}
```

## Support & Debugging

When reporting issues, always include:
- `X-Request-ID` from error response
- Timestamp of request
- Idempotency key used
- Full error response body
- Network trace (HAR file if possible)

Backend logs are correlated via MDC with `requestId` for efficient debugging.
