module DebugArchiveTest where

import Daml.Script
import DA.Time
import qualified Token.Token as T
import qualified AMM.Pool as P

-- Test if ArchiveAndUpdateReserves works correctly
debugArchiveTest : Script ()
debugArchiveTest = script do
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"
  clearportx <- allocateParty "ClearportX"

  debug "=== Testing ArchiveAndUpdateReserves ==="

  -- Create pool
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "TEST"
    maxTTL = hours 1
    totalLPSupply = 100.0
    reserveA = 100.0
    reserveB = 200000.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  debug "✅ Pool created"

  -- Try to call ArchiveAndUpdateReserves with realistic swap values
  -- Simulating a swap: 1000 USDC → ~0.5 ETH
  -- Old k = 100 * 200000 = 20,000,000
  -- New reserves: 99.5 ETH, 201000 USDC
  -- New k = 99.5 * 201000 = 19,999,500 (≈ old k, slightly less due to output)
  newPool <- submit poolParty $ exerciseCmd pool P.ArchiveAndUpdateReserves with
    updatedReserveA = 99.5
    updatedReserveB = 201000.0
    updatedTokenACid = None
    updatedTokenBCid = None

  debug "✅ ArchiveAndUpdateReserves succeeded"

  -- Verify old pool is archived
  oldPoolMaybe <- queryContractId poolOperator pool
  case oldPoolMaybe of
    None -> debug "✅ Old pool correctly archived"
    Some _ -> debug "❌ ERROR: Old pool still exists!"

  -- Verify new pool exists
  newPoolMaybe <- queryContractId poolOperator newPool
  case newPoolMaybe of
    None -> debug "❌ ERROR: New pool doesn't exist!"
    Some p -> do
      debug $ "✅ New pool exists with reserves: " <> show p.reserveA <> " ETH, " <> show p.reserveB <> " USDC"

  return ()
