{"ast":null,"code":"import _objectSpread from \"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classPrivateMethodInitSpec from \"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _defineProperty from \"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldInitSpec from \"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _classPrivateFieldGet from \"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _assertClassBrand from \"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\n// @ts-check\n/**\n * @import {Acr, KeycloakAccountOptions, KeycloakAdapter, KeycloakConfig, KeycloakError, KeycloakFlow, KeycloakInitOptions, KeycloakLoginOptions, KeycloakLogoutOptions, KeycloakPkceMethod, KeycloakProfile, KeycloakRegisterOptions, KeycloakResourceAccess, KeycloakResponseMode, KeycloakResponseType, KeycloakRoles, KeycloakTokenParsed, OpenIdProviderMetadata} from \"./keycloak.ts\"\n */\n/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst CONTENT_TYPE_JSON = 'application/json';\n\n/**\n * @typedef {Object} Endpoints\n * @property {() => string} authorize\n * @property {() => string} token\n * @property {() => string} logout\n * @property {() => string} checkSessionIframe\n * @property {() => string=} thirdPartyCookiesIframe\n * @property {() => string} register\n * @property {() => string} userinfo\n */\n\n/**\n * @typedef {Object} LoginIframe\n * @property {boolean} enable\n * @property {((error: Error | null, value?: boolean) => void)[]} callbackList\n * @property {number} interval\n * @property {HTMLIFrameElement=} iframe\n * @property {string=} iframeOrigin\n */\nvar _refreshQueue = /*#__PURE__*/new WeakMap();\nvar _adapter = /*#__PURE__*/new WeakMap();\nvar _useNonce = /*#__PURE__*/new WeakMap();\nvar _callbackStorage = /*#__PURE__*/new WeakMap();\nvar _logInfo = /*#__PURE__*/new WeakMap();\nvar _logWarn = /*#__PURE__*/new WeakMap();\nvar _loginIframe = /*#__PURE__*/new WeakMap();\nvar _config = /*#__PURE__*/new WeakMap();\nvar _Keycloak_brand = /*#__PURE__*/new WeakSet();\nexport default class Keycloak {\n  /**\n   * @param {KeycloakConfig} config\n   */\n  constructor(_config2) {\n    /**\n     * @param {\"default\" | \"cordova\" | \"cordova-native\"} type\n     * @returns {KeycloakAdapter}\n     */\n    _classPrivateMethodInitSpec(this, _Keycloak_brand);\n    /** @type {Pick<PromiseWithResolvers<boolean>, 'resolve' | 'reject'>[]} */\n    _classPrivateFieldInitSpec(this, _refreshQueue, []);\n    /** @type {KeycloakAdapter} */\n    _classPrivateFieldInitSpec(this, _adapter, void 0);\n    /** @type {boolean} */\n    _classPrivateFieldInitSpec(this, _useNonce, true);\n    /** @type {CallbackStorage} */\n    _classPrivateFieldInitSpec(this, _callbackStorage, void 0);\n    _classPrivateFieldInitSpec(this, _logInfo, _assertClassBrand(_Keycloak_brand, this, _createLogger).call(this, console.info));\n    _classPrivateFieldInitSpec(this, _logWarn, _assertClassBrand(_Keycloak_brand, this, _createLogger).call(this, console.warn));\n    /** @type {LoginIframe} */\n    _classPrivateFieldInitSpec(this, _loginIframe, {\n      enable: true,\n      callbackList: [],\n      interval: 5\n    });\n    /** @type {KeycloakConfig} config */\n    _classPrivateFieldInitSpec(this, _config, void 0);\n    _defineProperty(this, \"didInitialize\", false);\n    _defineProperty(this, \"authenticated\", false);\n    _defineProperty(this, \"loginRequired\", false);\n    /** @type {KeycloakResponseMode} */\n    _defineProperty(this, \"responseMode\", 'fragment');\n    /** @type {KeycloakResponseType} */\n    _defineProperty(this, \"responseType\", 'code');\n    /** @type {KeycloakFlow} */\n    _defineProperty(this, \"flow\", 'standard');\n    /** @type {number?} */\n    _defineProperty(this, \"timeSkew\", null);\n    /** @type {string=} */\n    _defineProperty(this, \"redirectUri\", void 0);\n    /** @type {string=} */\n    _defineProperty(this, \"silentCheckSsoRedirectUri\", void 0);\n    /** @type {boolean} */\n    _defineProperty(this, \"silentCheckSsoFallback\", true);\n    /** @type {KeycloakPkceMethod} */\n    _defineProperty(this, \"pkceMethod\", 'S256');\n    _defineProperty(this, \"enableLogging\", false);\n    /** @type {'GET' | 'POST'} */\n    _defineProperty(this, \"logoutMethod\", 'GET');\n    /** @type {string=} */\n    _defineProperty(this, \"scope\", void 0);\n    _defineProperty(this, \"messageReceiveTimeout\", 10000);\n    /** @type {string=} */\n    _defineProperty(this, \"idToken\", void 0);\n    /** @type {KeycloakTokenParsed=} */\n    _defineProperty(this, \"idTokenParsed\", void 0);\n    /** @type {string=} */\n    _defineProperty(this, \"token\", void 0);\n    /** @type {KeycloakTokenParsed=} */\n    _defineProperty(this, \"tokenParsed\", void 0);\n    /** @type {string=} */\n    _defineProperty(this, \"refreshToken\", void 0);\n    /** @type {KeycloakTokenParsed=} */\n    _defineProperty(this, \"refreshTokenParsed\", void 0);\n    /** @type {string=} */\n    _defineProperty(this, \"clientId\", void 0);\n    /** @type {string=} */\n    _defineProperty(this, \"sessionId\", void 0);\n    /** @type {string=} */\n    _defineProperty(this, \"subject\", void 0);\n    /** @type {string=} */\n    _defineProperty(this, \"authServerUrl\", void 0);\n    /** @type {string=} */\n    _defineProperty(this, \"realm\", void 0);\n    /** @type {KeycloakRoles=} */\n    _defineProperty(this, \"realmAccess\", void 0);\n    /** @type {KeycloakResourceAccess=} */\n    _defineProperty(this, \"resourceAccess\", void 0);\n    /** @type {KeycloakProfile=} */\n    _defineProperty(this, \"profile\", void 0);\n    /** @type {{}=} */\n    _defineProperty(this, \"userInfo\", void 0);\n    /** @type {Endpoints} */\n    _defineProperty(this, \"endpoints\", void 0);\n    /** @type {number=} */\n    _defineProperty(this, \"tokenTimeoutHandle\", void 0);\n    /** @type {() => void=} */\n    _defineProperty(this, \"onAuthSuccess\", void 0);\n    /** @type {(errorData?: KeycloakError) => void=} */\n    _defineProperty(this, \"onAuthError\", void 0);\n    /** @type {() => void=} */\n    _defineProperty(this, \"onAuthRefreshSuccess\", void 0);\n    /** @type {() => void=} */\n    _defineProperty(this, \"onAuthRefreshError\", void 0);\n    /** @type {() => void=} */\n    _defineProperty(this, \"onTokenExpired\", void 0);\n    /** @type {() => void=} */\n    _defineProperty(this, \"onAuthLogout\", void 0);\n    /** @type {(authenticated: boolean) => void=} */\n    _defineProperty(this, \"onReady\", void 0);\n    /** @type {(status: 'success' | 'cancelled' | 'error', action: string) => void=} */\n    _defineProperty(this, \"onActionUpdate\", void 0);\n    if (typeof _config2 !== 'string' && !isObject(_config2)) {\n      throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\");\n    }\n    if (isObject(_config2)) {\n      const requiredProperties = 'oidcProvider' in _config2 ? ['clientId'] : ['url', 'realm', 'clientId'];\n      for (const property of requiredProperties) {\n        if (!(property in _config2)) {\n          throw new Error(\"The configuration object is missing the required '\".concat(property, \"' property.\"));\n        }\n      }\n    }\n    if (!globalThis.isSecureContext) {\n      _classPrivateFieldGet(_logWarn, this).call(this, \"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\n\" + 'Continuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\n' + 'For more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts');\n    }\n    _classPrivateFieldSet(_config, this, _config2);\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<boolean>}\n   */\n  async init() {\n    var _this$onReady;\n    let initOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.didInitialize) {\n      throw new Error(\"A 'Keycloak' instance can only be initialized once.\");\n    }\n    this.didInitialize = true;\n    _classPrivateFieldSet(_callbackStorage, this, createCallbackStorage());\n    const adapters = ['default', 'cordova', 'cordova-native'];\n    if (typeof initOptions.adapter === 'string' && adapters.includes(initOptions.adapter)) {\n      _classPrivateFieldSet(_adapter, this, _assertClassBrand(_Keycloak_brand, this, _loadAdapter).call(this, initOptions.adapter));\n    } else if (typeof initOptions.adapter === 'object') {\n      _classPrivateFieldSet(_adapter, this, initOptions.adapter);\n    } else if ('Cordova' in window || 'cordova' in window) {\n      _classPrivateFieldSet(_adapter, this, _assertClassBrand(_Keycloak_brand, this, _loadAdapter).call(this, 'cordova'));\n    } else {\n      _classPrivateFieldSet(_adapter, this, _assertClassBrand(_Keycloak_brand, this, _loadAdapter).call(this, 'default'));\n    }\n    if (typeof initOptions.useNonce !== 'undefined') {\n      _classPrivateFieldSet(_useNonce, this, initOptions.useNonce);\n    }\n    if (typeof initOptions.checkLoginIframe !== 'undefined') {\n      _classPrivateFieldGet(_loginIframe, this).enable = initOptions.checkLoginIframe;\n    }\n    if (initOptions.checkLoginIframeInterval) {\n      _classPrivateFieldGet(_loginIframe, this).interval = initOptions.checkLoginIframeInterval;\n    }\n    if (initOptions.onLoad === 'login-required') {\n      this.loginRequired = true;\n    }\n    if (initOptions.responseMode) {\n      if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') {\n        this.responseMode = initOptions.responseMode;\n      } else {\n        throw new Error('Invalid value for responseMode');\n      }\n    }\n    if (initOptions.flow) {\n      switch (initOptions.flow) {\n        case 'standard':\n          this.responseType = 'code';\n          break;\n        case 'implicit':\n          this.responseType = 'id_token token';\n          break;\n        case 'hybrid':\n          this.responseType = 'code id_token token';\n          break;\n        default:\n          throw new Error('Invalid value for flow');\n      }\n      this.flow = initOptions.flow;\n    }\n    if (typeof initOptions.timeSkew === 'number') {\n      this.timeSkew = initOptions.timeSkew;\n    }\n    if (initOptions.redirectUri) {\n      this.redirectUri = initOptions.redirectUri;\n    }\n    if (initOptions.silentCheckSsoRedirectUri) {\n      this.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri;\n    }\n    if (typeof initOptions.silentCheckSsoFallback === 'boolean') {\n      this.silentCheckSsoFallback = initOptions.silentCheckSsoFallback;\n    }\n    if (typeof initOptions.pkceMethod !== 'undefined') {\n      if (initOptions.pkceMethod !== 'S256' && initOptions.pkceMethod !== false) {\n        throw new TypeError(\"Invalid value for pkceMethod', expected 'S256' or false but got \".concat(initOptions.pkceMethod, \".\"));\n      }\n      this.pkceMethod = initOptions.pkceMethod;\n    }\n    if (typeof initOptions.enableLogging === 'boolean') {\n      this.enableLogging = initOptions.enableLogging;\n    }\n    if (initOptions.logoutMethod === 'POST') {\n      this.logoutMethod = 'POST';\n    }\n    if (typeof initOptions.scope === 'string') {\n      this.scope = initOptions.scope;\n    }\n    if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) {\n      this.messageReceiveTimeout = initOptions.messageReceiveTimeout;\n    }\n    await _assertClassBrand(_Keycloak_brand, this, _loadConfig).call(this);\n    await _assertClassBrand(_Keycloak_brand, this, _check3pCookiesSupported).call(this);\n    await _assertClassBrand(_Keycloak_brand, this, _processInit).call(this, initOptions);\n    (_this$onReady = this.onReady) === null || _this$onReady === void 0 || _this$onReady.call(this, this.authenticated);\n    return this.authenticated;\n  }\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<void>}\n   */\n  login(options) {\n    return _classPrivateFieldGet(_adapter, this).login(options);\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<string>}\n   */\n  async createLoginUrl(options) {\n    const state = createUUID();\n    const nonce = createUUID();\n    const redirectUri = _classPrivateFieldGet(_adapter, this).redirectUri(options);\n    /** @type {CallbackState} */\n    const callbackState = {\n      state,\n      nonce,\n      redirectUri,\n      loginOptions: options\n    };\n    if (options !== null && options !== void 0 && options.prompt) {\n      callbackState.prompt = options.prompt;\n    }\n    const url = (options === null || options === void 0 ? void 0 : options.action) === 'register' ? this.endpoints.register() : this.endpoints.authorize();\n    let scope = (options === null || options === void 0 ? void 0 : options.scope) || this.scope;\n    const scopeValues = scope ? scope.split(' ') : [];\n\n    // Ensure the 'openid' scope is always included.\n    if (!scopeValues.includes('openid')) {\n      scopeValues.unshift('openid');\n    }\n    scope = scopeValues.join(' ');\n    const params = new URLSearchParams([['client_id', (/** @type {string} */this.clientId)],\n    // The endpoint URI MUST NOT include a fragment component.\n    // https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2\n    ['redirect_uri', stripHash(redirectUri)], ['state', state], ['response_mode', this.responseMode], ['response_type', this.responseType], ['scope', scope]]);\n    if (_classPrivateFieldGet(_useNonce, this)) {\n      params.append('nonce', nonce);\n    }\n    if (options !== null && options !== void 0 && options.prompt) {\n      params.append('prompt', options.prompt);\n    }\n    if (typeof (options === null || options === void 0 ? void 0 : options.maxAge) === 'number') {\n      params.append('max_age', options.maxAge.toString());\n    }\n    if (options !== null && options !== void 0 && options.loginHint) {\n      params.append('login_hint', options.loginHint);\n    }\n    if (options !== null && options !== void 0 && options.idpHint) {\n      params.append('kc_idp_hint', options.idpHint);\n    }\n    if (options !== null && options !== void 0 && options.action && options.action !== 'register') {\n      params.append('kc_action', options.action);\n    }\n    if (options !== null && options !== void 0 && options.locale) {\n      params.append('ui_locales', options.locale);\n    }\n    if (options !== null && options !== void 0 && options.acr) {\n      params.append('claims', buildClaimsParameter(options.acr));\n    }\n    if (options !== null && options !== void 0 && options.acrValues) {\n      params.append('acr_values', options.acrValues);\n    }\n    if (this.pkceMethod) {\n      try {\n        const codeVerifier = generateCodeVerifier(96);\n        const pkceChallenge = await generatePkceChallenge(this.pkceMethod, codeVerifier);\n        callbackState.pkceCodeVerifier = codeVerifier;\n        params.append('code_challenge', pkceChallenge);\n        params.append('code_challenge_method', this.pkceMethod);\n      } catch (error) {\n        throw new Error('Failed to generate PKCE challenge.', {\n          cause: error\n        });\n      }\n    }\n    _classPrivateFieldGet(_callbackStorage, this).add(callbackState);\n    return \"\".concat(url, \"?\").concat(params.toString());\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {Promise<void>}\n   */\n  logout(options) {\n    return _classPrivateFieldGet(_adapter, this).logout(options);\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {string}\n   */\n  createLogoutUrl(options) {\n    var _options$logoutMethod;\n    const logoutMethod = (_options$logoutMethod = options === null || options === void 0 ? void 0 : options.logoutMethod) !== null && _options$logoutMethod !== void 0 ? _options$logoutMethod : this.logoutMethod;\n    const url = this.endpoints.logout();\n    if (logoutMethod === 'POST') {\n      return url;\n    }\n    const params = new URLSearchParams([['client_id', (/** @type {string} */this.clientId)], ['post_logout_redirect_uri', _classPrivateFieldGet(_adapter, this).redirectUri(options)]]);\n    if (this.idToken) {\n      params.append('id_token_hint', this.idToken);\n    }\n    return \"\".concat(url, \"?\").concat(params.toString());\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<void>}\n   */\n  register(options) {\n    return _classPrivateFieldGet(_adapter, this).register(options);\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<string>}\n   */\n  createRegisterUrl(options) {\n    return this.createLoginUrl(_objectSpread(_objectSpread({}, options), {}, {\n      action: 'register'\n    }));\n  }\n\n  /**\n   * @param {KeycloakAccountOptions} [options]\n   * @returns {string}\n   */\n  createAccountUrl(options) {\n    const url = _assertClassBrand(_Keycloak_brand, this, _getRealmUrl).call(this);\n    if (!url) {\n      throw new Error('Unable to create account URL, make sure the adapter is not configured using a generic OIDC provider.');\n    }\n    const params = new URLSearchParams([['referrer', (/** @type {string} */this.clientId)], ['referrer_uri', _classPrivateFieldGet(_adapter, this).redirectUri(options)]]);\n    return \"\".concat(url, \"/account?\").concat(params.toString());\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  accountManagement() {\n    return _classPrivateFieldGet(_adapter, this).accountManagement();\n  }\n\n  /**\n   * @param {string} role\n   * @returns {boolean}\n   */\n  hasRealmRole(role) {\n    const access = this.realmAccess;\n    return !!access && access.roles.indexOf(role) >= 0;\n  }\n\n  /**\n   * @param {string} role\n   * @param {string} [resource]\n   * @returns {boolean}\n   */\n  hasResourceRole(role, resource) {\n    if (!this.resourceAccess) {\n      return false;\n    }\n    const access = this.resourceAccess[resource || (/** @type {string} */this.clientId)];\n    return !!access && access.roles.indexOf(role) >= 0;\n  }\n\n  /**\n   * @returns {Promise<KeycloakProfile>}\n   */\n  async loadUserProfile() {\n    const realmUrl = _assertClassBrand(_Keycloak_brand, this, _getRealmUrl).call(this);\n    if (!realmUrl) {\n      throw new Error('Unable to load user profile, make sure the adapter is not configured using a generic OIDC provider.');\n    }\n    const url = \"\".concat(realmUrl, \"/account\");\n    /** @type {KeycloakProfile} */\n    const profile = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    });\n    return this.profile = profile;\n  }\n\n  /**\n   * @returns {Promise<{}>}\n   */\n  async loadUserInfo() {\n    const url = this.endpoints.userinfo();\n    /** @type {{}} */\n    const userInfo = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    });\n    return this.userInfo = userInfo;\n  }\n\n  /**\n   * @param {number} [minValidity]\n   * @returns {boolean}\n   */\n  isTokenExpired(minValidity) {\n    if (!this.tokenParsed || !this.refreshToken && this.flow !== 'implicit') {\n      throw new Error('Not authenticated');\n    }\n    if (this.timeSkew == null) {\n      _classPrivateFieldGet(_logInfo, this).call(this, '[KEYCLOAK] Unable to determine if token is expired as timeskew is not set');\n      return true;\n    }\n    if (typeof this.tokenParsed.exp !== 'number') {\n      return false;\n    }\n    let expiresIn = this.tokenParsed.exp - Math.ceil(new Date().getTime() / 1000) + this.timeSkew;\n    if (minValidity) {\n      if (isNaN(minValidity)) {\n        throw new Error('Invalid minValidity');\n      }\n      expiresIn -= minValidity;\n    }\n    return expiresIn < 0;\n  }\n\n  /**\n   * @param {number} minValidity\n   * @returns {Promise<boolean>}\n   */\n  async updateToken(minValidity) {\n    if (!this.refreshToken) {\n      throw new Error('Unable to update token, no refresh token available.');\n    }\n    minValidity = minValidity || 5;\n    if (_classPrivateFieldGet(_loginIframe, this).enable) {\n      await _assertClassBrand(_Keycloak_brand, this, _checkLoginIframe).call(this);\n    }\n    let refreshToken = false;\n    if (minValidity === -1) {\n      refreshToken = true;\n      _classPrivateFieldGet(_logInfo, this).call(this, '[KEYCLOAK] Refreshing token: forced refresh');\n    } else if (!this.tokenParsed || this.isTokenExpired(minValidity)) {\n      refreshToken = true;\n      _classPrivateFieldGet(_logInfo, this).call(this, '[KEYCLOAK] Refreshing token: token expired');\n    }\n    if (!refreshToken) {\n      return false;\n    }\n\n    /** @type {PromiseWithResolvers<boolean>} */\n    const {\n      promise,\n      resolve,\n      reject\n    } = Promise.withResolvers();\n    _classPrivateFieldGet(_refreshQueue, this).push({\n      resolve,\n      reject\n    });\n    if (_classPrivateFieldGet(_refreshQueue, this).length === 1) {\n      const url = this.endpoints.token();\n      let timeLocal = new Date().getTime();\n      try {\n        var _this$onAuthRefreshSu;\n        const response = await fetchRefreshToken(url, this.refreshToken, /** @type {string} */this.clientId);\n        _classPrivateFieldGet(_logInfo, this).call(this, '[KEYCLOAK] Token refreshed');\n        timeLocal = (timeLocal + new Date().getTime()) / 2;\n        _assertClassBrand(_Keycloak_brand, this, _setToken).call(this, response.access_token, response.refresh_token, response.id_token, timeLocal);\n        (_this$onAuthRefreshSu = this.onAuthRefreshSuccess) === null || _this$onAuthRefreshSu === void 0 || _this$onAuthRefreshSu.call(this);\n        for (let p = _classPrivateFieldGet(_refreshQueue, this).pop(); p != null; p = _classPrivateFieldGet(_refreshQueue, this).pop()) {\n          p.resolve(true);\n        }\n      } catch (error) {\n        var _this$onAuthRefreshEr;\n        _classPrivateFieldGet(_logWarn, this).call(this, '[KEYCLOAK] Failed to refresh token');\n        if (error instanceof NetworkError && error.response.status === 400) {\n          this.clearToken();\n        }\n        (_this$onAuthRefreshEr = this.onAuthRefreshError) === null || _this$onAuthRefreshEr === void 0 || _this$onAuthRefreshEr.call(this);\n        for (let p = _classPrivateFieldGet(_refreshQueue, this).pop(); p != null; p = _classPrivateFieldGet(_refreshQueue, this).pop()) {\n          p.reject(error);\n        }\n      }\n    }\n    return await promise;\n  }\n  clearToken() {\n    if (this.token) {\n      var _this$onAuthLogout;\n      _assertClassBrand(_Keycloak_brand, this, _setToken).call(this);\n      (_this$onAuthLogout = this.onAuthLogout) === null || _this$onAuthLogout === void 0 || _this$onAuthLogout.call(this);\n      if (this.loginRequired) {\n        this.login();\n      }\n    }\n  }\n\n  /**\n   * @param {string} [token]\n   * @param {string} [refreshToken]\n   * @param {string} [idToken]\n   * @param {number} [timeLocal]\n   */\n}\n\n/**\n * @returns {string}\n */\nfunction _loadAdapter(type) {\n  if (type === 'default') {\n    return _assertClassBrand(_Keycloak_brand, this, _loadDefaultAdapter).call(this);\n  }\n  if (type === 'cordova') {\n    _classPrivateFieldGet(_loginIframe, this).enable = false;\n    return _assertClassBrand(_Keycloak_brand, this, _loadCordovaAdapter).call(this);\n  }\n  if (type === 'cordova-native') {\n    _classPrivateFieldGet(_loginIframe, this).enable = false;\n    return _assertClassBrand(_Keycloak_brand, this, _loadCordovaNativeAdapter).call(this);\n  }\n  throw new Error('invalid adapter type: ' + type);\n}\n/**\n * @returns {KeycloakAdapter}\n */\nfunction _loadDefaultAdapter() {\n  /** @type {KeycloakAdapter['redirectUri']}{} */\n  const redirectUri = options => {\n    return (options === null || options === void 0 ? void 0 : options.redirectUri) || this.redirectUri || globalThis.location.href;\n  };\n  return {\n    login: async options => {\n      window.location.assign(await this.createLoginUrl(options));\n      return await new Promise(() => {});\n    },\n    logout: async options => {\n      var _options$logoutMethod2;\n      const logoutMethod = (_options$logoutMethod2 = options === null || options === void 0 ? void 0 : options.logoutMethod) !== null && _options$logoutMethod2 !== void 0 ? _options$logoutMethod2 : this.logoutMethod;\n      if (logoutMethod === 'GET') {\n        window.location.replace(this.createLogoutUrl(options));\n        return;\n      }\n\n      // Create form to send POST request.\n      const form = document.createElement('form');\n      form.setAttribute('method', 'POST');\n      form.setAttribute('action', this.createLogoutUrl(options));\n      form.style.display = 'none';\n\n      // Add data to form as hidden input fields.\n      const data = {\n        id_token_hint: this.idToken,\n        client_id: this.clientId,\n        post_logout_redirect_uri: redirectUri(options)\n      };\n      for (const [name, value] of Object.entries(data)) {\n        const input = document.createElement('input');\n        input.setAttribute('type', 'hidden');\n        input.setAttribute('name', name);\n        input.setAttribute('value', /** @type {string} */value);\n        form.appendChild(input);\n      }\n\n      // Append form to page and submit it to perform logout and redirect.\n      document.body.appendChild(form);\n      form.submit();\n    },\n    register: async options => {\n      window.location.assign(await this.createRegisterUrl(options));\n      return await new Promise(() => {});\n    },\n    accountManagement: async () => {\n      const accountUrl = this.createAccountUrl();\n      if (typeof accountUrl !== 'undefined') {\n        window.location.href = accountUrl;\n      } else {\n        throw new Error('Not supported by the OIDC server');\n      }\n      return await new Promise(() => {});\n    },\n    redirectUri\n  };\n}\n/**\n * @returns {KeycloakAdapter}\n */\nfunction _loadCordovaAdapter() {\n  /**\n   * @param {string} loginUrl\n   * @param {string} target\n   * @param {string} options\n   * @returns {WindowProxy | null}\n   */\n  const cordovaOpenWindowWrapper = (loginUrl, target, options) => {\n    if (window.cordova && window.cordova.InAppBrowser) {\n      // Use inappbrowser for IOS and Android if available\n      return window.cordova.InAppBrowser.open(loginUrl, target, options);\n    } else {\n      return window.open(loginUrl, target, options);\n    }\n  };\n  const shallowCloneCordovaOptions = userOptions => {\n    if (userOptions && userOptions.cordovaOptions) {\n      return Object.keys(userOptions.cordovaOptions).reduce((options, optionName) => {\n        options[optionName] = userOptions.cordovaOptions[optionName];\n        return options;\n      }, {});\n    } else {\n      return {};\n    }\n  };\n  const formatCordovaOptions = cordovaOptions => {\n    return Object.keys(cordovaOptions).reduce((options, optionName) => {\n      options.push(optionName + '=' + cordovaOptions[optionName]);\n      return options;\n    }, []).join(',');\n  };\n  const createCordovaOptions = userOptions => {\n    const cordovaOptions = shallowCloneCordovaOptions(userOptions);\n    cordovaOptions.location = 'no';\n    if (userOptions && userOptions.prompt === 'none') {\n      cordovaOptions.hidden = 'yes';\n    }\n    return formatCordovaOptions(cordovaOptions);\n  };\n  const getCordovaRedirectUri = () => {\n    return this.redirectUri || 'http://localhost';\n  };\n  return {\n    login: async options => {\n      const cordovaOptions = createCordovaOptions(options);\n      const loginUrl = await this.createLoginUrl(options);\n      const ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions);\n      let completed = false;\n      let closed = false;\n      function closeBrowser() {\n        closed = true;\n        ref.close();\n      }\n      ;\n      return await new Promise((resolve, reject) => {\n        ref.addEventListener('loadstart', async event => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            const callback = _assertClassBrand(_Keycloak_brand, this, _parseCallback).call(this, event.url);\n            try {\n              await _assertClassBrand(_Keycloak_brand, this, _processCallback).call(this, callback);\n              resolve();\n            } catch (error) {\n              reject(error);\n            }\n            closeBrowser();\n            completed = true;\n          }\n        });\n        ref.addEventListener('loaderror', async event => {\n          if (!completed) {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              const callback = _assertClassBrand(_Keycloak_brand, this, _parseCallback).call(this, event.url);\n              try {\n                await _assertClassBrand(_Keycloak_brand, this, _processCallback).call(this, callback);\n                resolve();\n              } catch (error) {\n                reject(error);\n              }\n              closeBrowser();\n              completed = true;\n            } else {\n              reject(new Error('Unable to process login.'));\n              closeBrowser();\n            }\n          }\n        });\n        ref.addEventListener('exit', function (event) {\n          if (!closed) {\n            reject(new Error('User closed the login window.'));\n          }\n        });\n      });\n    },\n    logout: async options => {\n      const logoutUrl = this.createLogoutUrl(options);\n      const ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes');\n      let error = false;\n      ref.addEventListener('loadstart', event => {\n        if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n          ref.close();\n        }\n      });\n      ref.addEventListener('loaderror', event => {\n        if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n          ref.close();\n        } else {\n          error = true;\n          ref.close();\n        }\n      });\n      await new Promise((resolve, reject) => {\n        ref.addEventListener('exit', () => {\n          if (error) {\n            reject(new Error('User closed the login window.'));\n          } else {\n            this.clearToken();\n            resolve();\n          }\n        });\n      });\n    },\n    register: async options => {\n      const registerUrl = await this.createRegisterUrl();\n      const cordovaOptions = createCordovaOptions(options);\n      const ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions);\n\n      /** @type {Promise<void>} */\n      const promise = new Promise((resolve, reject) => {\n        ref.addEventListener('loadstart', async event => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close();\n            const oauth = _assertClassBrand(_Keycloak_brand, this, _parseCallback).call(this, event.url);\n            try {\n              await _assertClassBrand(_Keycloak_brand, this, _processCallback).call(this, oauth);\n              resolve();\n            } catch (error) {\n              reject(error);\n            }\n          }\n        });\n      });\n      await promise;\n    },\n    accountManagement: async () => {\n      const accountUrl = this.createAccountUrl();\n      if (typeof accountUrl !== 'undefined') {\n        const ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no');\n        ref.addEventListener('loadstart', function (event) {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close();\n          }\n        });\n      } else {\n        throw new Error('Not supported by the OIDC server');\n      }\n    },\n    redirectUri: () => {\n      return getCordovaRedirectUri();\n    }\n  };\n}\n/**\n * @returns {KeycloakAdapter}\n */\nfunction _loadCordovaNativeAdapter() {\n  /* global universalLinks */\n  return {\n    login: async options => {\n      const loginUrl = await this.createLoginUrl(options);\n      await new Promise((resolve, reject) => {\n        universalLinks.subscribe('keycloak', async event => {\n          universalLinks.unsubscribe('keycloak');\n          window.cordova.plugins.browsertab.close();\n          const oauth = _assertClassBrand(_Keycloak_brand, this, _parseCallback).call(this, event.url);\n          try {\n            await _assertClassBrand(_Keycloak_brand, this, _processCallback).call(this, oauth);\n            resolve();\n          } catch (error) {\n            reject(error);\n          }\n        });\n        window.cordova.plugins.browsertab.openUrl(loginUrl);\n      });\n    },\n    logout: async options => {\n      const logoutUrl = this.createLogoutUrl(options);\n      await new Promise(resolve => {\n        universalLinks.subscribe('keycloak', () => {\n          universalLinks.unsubscribe('keycloak');\n          window.cordova.plugins.browsertab.close();\n          this.clearToken();\n          resolve();\n        });\n        window.cordova.plugins.browsertab.openUrl(logoutUrl);\n      });\n    },\n    register: async options => {\n      const registerUrl = await this.createRegisterUrl(options);\n      await new Promise((resolve, reject) => {\n        universalLinks.subscribe('keycloak', async event => {\n          universalLinks.unsubscribe('keycloak');\n          window.cordova.plugins.browsertab.close();\n          const oauth = _assertClassBrand(_Keycloak_brand, this, _parseCallback).call(this, event.url);\n          try {\n            await _assertClassBrand(_Keycloak_brand, this, _processCallback).call(this, oauth);\n            resolve();\n          } catch (error) {\n            reject(error);\n          }\n        });\n        window.cordova.plugins.browsertab.openUrl(registerUrl);\n      });\n    },\n    accountManagement: async () => {\n      const accountUrl = this.createAccountUrl();\n      if (typeof accountUrl !== 'undefined') {\n        window.cordova.plugins.browsertab.openUrl(accountUrl);\n      } else {\n        throw new Error('Not supported by the OIDC server');\n      }\n    },\n    redirectUri: options => {\n      if (options && options.redirectUri) {\n        return options.redirectUri;\n      } else if (this.redirectUri) {\n        return this.redirectUri;\n      } else {\n        return 'http://localhost';\n      }\n    }\n  };\n}\n/**\n * @returns {Promise<void>}\n */\nasync function _loadConfig() {\n  if (typeof _classPrivateFieldGet(_config, this) === 'string') {\n    const jsonConfig = await fetchJsonConfig(_classPrivateFieldGet(_config, this));\n    this.authServerUrl = jsonConfig['auth-server-url'];\n    this.realm = jsonConfig.realm;\n    this.clientId = jsonConfig.resource;\n    _assertClassBrand(_Keycloak_brand, this, _setupEndpoints).call(this);\n  } else {\n    this.clientId = _classPrivateFieldGet(_config, this).clientId;\n    if ('oidcProvider' in _classPrivateFieldGet(_config, this)) {\n      await _assertClassBrand(_Keycloak_brand, this, _loadOidcConfig).call(this, _classPrivateFieldGet(_config, this).oidcProvider);\n    } else {\n      this.authServerUrl = _classPrivateFieldGet(_config, this).url;\n      this.realm = _classPrivateFieldGet(_config, this).realm;\n      _assertClassBrand(_Keycloak_brand, this, _setupEndpoints).call(this);\n    }\n  }\n}\n/**\n * @returns {void}\n */\nfunction _setupEndpoints() {\n  this.endpoints = {\n    authorize: () => {\n      return _assertClassBrand(_Keycloak_brand, this, _getRealmUrl).call(this) + '/protocol/openid-connect/auth';\n    },\n    token: () => {\n      return _assertClassBrand(_Keycloak_brand, this, _getRealmUrl).call(this) + '/protocol/openid-connect/token';\n    },\n    logout: () => {\n      return _assertClassBrand(_Keycloak_brand, this, _getRealmUrl).call(this) + '/protocol/openid-connect/logout';\n    },\n    checkSessionIframe: () => {\n      return _assertClassBrand(_Keycloak_brand, this, _getRealmUrl).call(this) + '/protocol/openid-connect/login-status-iframe.html';\n    },\n    thirdPartyCookiesIframe: () => {\n      return _assertClassBrand(_Keycloak_brand, this, _getRealmUrl).call(this) + '/protocol/openid-connect/3p-cookies/step1.html';\n    },\n    register: () => {\n      return _assertClassBrand(_Keycloak_brand, this, _getRealmUrl).call(this) + '/protocol/openid-connect/registrations';\n    },\n    userinfo: () => {\n      return _assertClassBrand(_Keycloak_brand, this, _getRealmUrl).call(this) + '/protocol/openid-connect/userinfo';\n    }\n  };\n}\n/**\n * @param {string | OpenIdProviderMetadata} oidcProvider\n * @returns {Promise<void>}\n */\nasync function _loadOidcConfig(oidcProvider) {\n  if (typeof oidcProvider === 'string') {\n    const url = \"\".concat(stripTrailingSlash(oidcProvider), \"/.well-known/openid-configuration\");\n    const openIdConfig = await fetchOpenIdConfig(url);\n    _assertClassBrand(_Keycloak_brand, this, _setupOidcEndpoints).call(this, openIdConfig);\n  } else {\n    _assertClassBrand(_Keycloak_brand, this, _setupOidcEndpoints).call(this, oidcProvider);\n  }\n}\n/**\n * @param {OpenIdProviderMetadata} config\n * @returns {void}\n */\nfunction _setupOidcEndpoints(config) {\n  this.endpoints = {\n    authorize() {\n      return config.authorization_endpoint;\n    },\n    token() {\n      return config.token_endpoint;\n    },\n    logout() {\n      if (!config.end_session_endpoint) {\n        throw new Error('Not supported by the OIDC server');\n      }\n      return config.end_session_endpoint;\n    },\n    checkSessionIframe() {\n      if (!config.check_session_iframe) {\n        throw new Error('Not supported by the OIDC server');\n      }\n      return config.check_session_iframe;\n    },\n    register() {\n      throw new Error('Redirection to \"Register user\" page not supported in standard OIDC mode');\n    },\n    userinfo() {\n      if (!config.userinfo_endpoint) {\n        throw new Error('Not supported by the OIDC server');\n      }\n      return config.userinfo_endpoint;\n    }\n  };\n}\n/**\n * @returns {Promise<void>}\n */\nasync function _check3pCookiesSupported() {\n  if (!_classPrivateFieldGet(_loginIframe, this).enable && !this.silentCheckSsoRedirectUri || typeof this.endpoints.thirdPartyCookiesIframe !== 'function') {\n    return;\n  }\n  const iframe = document.createElement('iframe');\n  iframe.setAttribute('src', this.endpoints.thirdPartyCookiesIframe());\n  iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n  iframe.setAttribute('title', 'keycloak-3p-check-iframe');\n  iframe.style.display = 'none';\n  document.body.appendChild(iframe);\n\n  /** @type {Promise<void>} */\n  const promise = new Promise(resolve => {\n    /**\n     * @param {MessageEvent} event\n     */\n    const messageCallback = event => {\n      if (iframe.contentWindow !== event.source) {\n        return;\n      }\n      if (event.data !== 'supported' && event.data !== 'unsupported') {\n        return;\n      } else if (event.data === 'unsupported') {\n        _classPrivateFieldGet(_logWarn, this).call(this, '[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n' + ' - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n' + ' - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\n' + 'For more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers');\n        _classPrivateFieldGet(_loginIframe, this).enable = false;\n        if (this.silentCheckSsoFallback) {\n          this.silentCheckSsoRedirectUri = undefined;\n        }\n      }\n      document.body.removeChild(iframe);\n      window.removeEventListener('message', messageCallback);\n      resolve();\n    };\n    window.addEventListener('message', messageCallback, false);\n  });\n  return await applyTimeoutToPromise(promise, this.messageReceiveTimeout, 'Timeout when waiting for 3rd party check iframe message.');\n}\n/**\n * @param {KeycloakInitOptions} initOptions\n * @returns {Promise<void>}\n */\nasync function _processInit(initOptions) {\n  const callback = _assertClassBrand(_Keycloak_brand, this, _parseCallback).call(this, window.location.href);\n  if (callback !== null && callback !== void 0 && callback.redirectUri) {\n    window.history.replaceState(window.history.state, '', callback.redirectUri);\n  }\n  if (callback && callback.valid) {\n    await _assertClassBrand(_Keycloak_brand, this, _setupCheckLoginIframe).call(this);\n    await _assertClassBrand(_Keycloak_brand, this, _processCallback).call(this, callback);\n    return;\n  }\n\n  /** @param {boolean} prompt */\n  const doLogin = async prompt => {\n    /** @type {KeycloakLoginOptions} */\n    const options = {};\n    if (!prompt) {\n      options.prompt = 'none';\n    }\n    if (initOptions.locale) {\n      options.locale = initOptions.locale;\n    }\n    await this.login(options);\n  };\n  const onLoad = async () => {\n    switch (initOptions.onLoad) {\n      case 'check-sso':\n        if (_classPrivateFieldGet(_loginIframe, this).enable) {\n          await _assertClassBrand(_Keycloak_brand, this, _setupCheckLoginIframe).call(this);\n          const unchanged = await _assertClassBrand(_Keycloak_brand, this, _checkLoginIframe).call(this);\n          if (!unchanged) {\n            this.silentCheckSsoRedirectUri ? await _assertClassBrand(_Keycloak_brand, this, _checkSsoSilently).call(this) : await doLogin(false);\n          }\n        } else {\n          this.silentCheckSsoRedirectUri ? await _assertClassBrand(_Keycloak_brand, this, _checkSsoSilently).call(this) : await doLogin(false);\n        }\n        break;\n      case 'login-required':\n        await doLogin(true);\n        break;\n      default:\n        throw new Error('Invalid value for onLoad');\n    }\n  };\n  if (initOptions.token && initOptions.refreshToken) {\n    _assertClassBrand(_Keycloak_brand, this, _setToken).call(this, initOptions.token, initOptions.refreshToken, initOptions.idToken);\n    if (_classPrivateFieldGet(_loginIframe, this).enable) {\n      await _assertClassBrand(_Keycloak_brand, this, _setupCheckLoginIframe).call(this);\n      const unchanged = await _assertClassBrand(_Keycloak_brand, this, _checkLoginIframe).call(this);\n      if (unchanged) {\n        var _this$onAuthSuccess;\n        (_this$onAuthSuccess = this.onAuthSuccess) === null || _this$onAuthSuccess === void 0 || _this$onAuthSuccess.call(this);\n        _assertClassBrand(_Keycloak_brand, this, _scheduleCheckIframe).call(this);\n      }\n    } else {\n      try {\n        var _this$onAuthSuccess2;\n        await this.updateToken(-1);\n        (_this$onAuthSuccess2 = this.onAuthSuccess) === null || _this$onAuthSuccess2 === void 0 || _this$onAuthSuccess2.call(this);\n      } catch (error) {\n        var _this$onAuthError;\n        (_this$onAuthError = this.onAuthError) === null || _this$onAuthError === void 0 || _this$onAuthError.call(this);\n        if (initOptions.onLoad) {\n          await onLoad();\n        } else {\n          throw error;\n        }\n      }\n    }\n  } else if (initOptions.onLoad) {\n    await onLoad();\n  }\n}\n/**\n * @returns {Promise<void>}\n */\nasync function _setupCheckLoginIframe() {\n  if (!_classPrivateFieldGet(_loginIframe, this).enable || _classPrivateFieldGet(_loginIframe, this).iframe) {\n    return;\n  }\n  const iframe = document.createElement('iframe');\n  _classPrivateFieldGet(_loginIframe, this).iframe = iframe;\n  iframe.setAttribute('src', this.endpoints.checkSessionIframe());\n  iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n  iframe.setAttribute('title', 'keycloak-session-iframe');\n  iframe.style.display = 'none';\n  document.body.appendChild(iframe);\n\n  /**\n   * @param {MessageEvent} event\n   */\n  const messageCallback = event => {\n    var _classPrivateFieldGet2;\n    if (event.origin !== _classPrivateFieldGet(_loginIframe, this).iframeOrigin || ((_classPrivateFieldGet2 = _classPrivateFieldGet(_loginIframe, this).iframe) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.contentWindow) !== event.source) {\n      return;\n    }\n    if (!(event.data === 'unchanged' || event.data === 'changed' || event.data === 'error')) {\n      return;\n    }\n    if (event.data !== 'unchanged') {\n      this.clearToken();\n    }\n    const callbacks = _classPrivateFieldGet(_loginIframe, this).callbackList;\n    _classPrivateFieldGet(_loginIframe, this).callbackList = [];\n    for (const callback of callbacks.reverse()) {\n      if (event.data === 'error') {\n        callback(new Error('Error while checking login iframe'));\n      } else {\n        callback(null, event.data === 'unchanged');\n      }\n    }\n  };\n  window.addEventListener('message', messageCallback, false);\n\n  /** @type {Promise<void>} */\n  const promise = new Promise(resolve => {\n    iframe.addEventListener('load', () => {\n      const authUrl = this.endpoints.authorize();\n      if (authUrl.startsWith('/')) {\n        _classPrivateFieldGet(_loginIframe, this).iframeOrigin = globalThis.location.origin;\n      } else {\n        _classPrivateFieldGet(_loginIframe, this).iframeOrigin = new URL(authUrl).origin;\n      }\n      resolve();\n    });\n  });\n  await promise;\n}\n/**\n * @returns {Promise<boolean | undefined>}\n */\nasync function _checkLoginIframe() {\n  if (!_classPrivateFieldGet(_loginIframe, this).iframe || !_classPrivateFieldGet(_loginIframe, this).iframeOrigin) {\n    return;\n  }\n  const message = \"\".concat(this.clientId, \" \").concat(this.sessionId ? this.sessionId : '');\n  const origin = _classPrivateFieldGet(_loginIframe, this).iframeOrigin;\n\n  /** @type {Promise<boolean>} */\n  const promise = new Promise((resolve, reject) => {\n    /** @type {(error: Error | null, value?: boolean) => void} */\n    const callback = (error, result) => error ? reject(error) : resolve(/** @type {boolean} */result);\n    _classPrivateFieldGet(_loginIframe, this).callbackList.push(callback);\n    if (_classPrivateFieldGet(_loginIframe, this).callbackList.length === 1) {\n      var _classPrivateFieldGet3;\n      (_classPrivateFieldGet3 = _classPrivateFieldGet(_loginIframe, this).iframe) === null || _classPrivateFieldGet3 === void 0 || (_classPrivateFieldGet3 = _classPrivateFieldGet3.contentWindow) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.postMessage(message, origin);\n    }\n  });\n  return await promise;\n}\n/**\n * @returns {Promise<void>}\n */\nasync function _checkSsoSilently() {\n  const iframe = document.createElement('iframe');\n  const src = await this.createLoginUrl({\n    prompt: 'none',\n    redirectUri: this.silentCheckSsoRedirectUri\n  });\n  iframe.setAttribute('src', src);\n  iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n  iframe.setAttribute('title', 'keycloak-silent-check-sso');\n  iframe.style.display = 'none';\n  document.body.appendChild(iframe);\n  return await new Promise((resolve, reject) => {\n    /**\n     * @param {MessageEvent} event\n     */\n    const messageCallback = async event => {\n      if (event.origin !== window.location.origin || iframe.contentWindow !== event.source) {\n        return;\n      }\n      const oauth = _assertClassBrand(_Keycloak_brand, this, _parseCallback).call(this, event.data);\n      try {\n        await _assertClassBrand(_Keycloak_brand, this, _processCallback).call(this, oauth);\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n      document.body.removeChild(iframe);\n      window.removeEventListener('message', messageCallback);\n    };\n    window.addEventListener('message', messageCallback);\n  });\n}\n/**\n * @param {string} url\n */\nfunction _parseCallback(url) {\n  const oauth = _assertClassBrand(_Keycloak_brand, this, _parseCallbackUrl).call(this, url);\n  if (!oauth) {\n    return;\n  }\n  const oauthState = _classPrivateFieldGet(_callbackStorage, this).get(oauth.state);\n  if (oauthState) {\n    oauth.valid = true;\n    oauth.redirectUri = oauthState.redirectUri;\n    oauth.storedNonce = oauthState.nonce;\n    oauth.prompt = oauthState.prompt;\n    oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;\n    oauth.loginOptions = oauthState.loginOptions;\n  }\n  return oauth;\n}\n/**\n * @param {string} urlString\n */\nfunction _parseCallbackUrl(urlString) {\n  var _parsed;\n  let supportedParams = [];\n  switch (this.flow) {\n    case 'standard':\n      supportedParams = ['code', 'state', 'session_state', 'kc_action_status', 'kc_action', 'iss'];\n      break;\n    case 'implicit':\n      supportedParams = ['access_token', 'token_type', 'id_token', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss'];\n      break;\n    case 'hybrid':\n      supportedParams = ['access_token', 'token_type', 'id_token', 'code', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss'];\n      break;\n  }\n  supportedParams.push('error');\n  supportedParams.push('error_description');\n  supportedParams.push('error_uri');\n  const url = new URL(urlString);\n  let redirectUri = '';\n  let parsed;\n  if (this.responseMode === 'query' && url.searchParams.size > 0) {\n    parsed = _assertClassBrand(_Keycloak_brand, this, _parseCallbackParams).call(this, url.search, supportedParams);\n    url.search = parsed.paramsString;\n    redirectUri = url.toString();\n  } else if (this.responseMode === 'fragment' && url.hash.length > 0) {\n    parsed = _assertClassBrand(_Keycloak_brand, this, _parseCallbackParams).call(this, url.hash.substring(1), supportedParams);\n    url.hash = '';\n    redirectUri = url.toString();\n  }\n  if ((_parsed = parsed) !== null && _parsed !== void 0 && _parsed.oauthParams) {\n    if (this.flow === 'standard' || this.flow === 'hybrid') {\n      if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n        parsed.oauthParams.redirectUri = redirectUri;\n        return parsed.oauthParams;\n      }\n    } else if (this.flow === 'implicit') {\n      if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n        parsed.oauthParams.redirectUri = redirectUri;\n        return parsed.oauthParams;\n      }\n    }\n  }\n}\n/**\n * @typedef {Object} ParsedCallbackParams\n * @property {string} paramsString\n * @property {Record<string, string | undefined>} oauthParams\n */\n/**\n * @param {string} paramsString\n * @param {string[]} supportedParams\n * @returns {ParsedCallbackParams}\n */\nfunction _parseCallbackParams(paramsString, supportedParams) {\n  const params = new URLSearchParams(paramsString);\n  /** @type {Record<string, string>} */\n  const oauthParams = {};\n  for (const [key, value] of Array.from(params.entries())) {\n    if (supportedParams.includes(key)) {\n      oauthParams[key] = value;\n      params.delete(key);\n    }\n  }\n  return {\n    paramsString: params.toString(),\n    oauthParams\n  };\n}\nasync function _processCallback(oauth) {\n  const {\n    code,\n    error,\n    prompt\n  } = oauth;\n  let timeLocal = new Date().getTime();\n\n  /**\n   * @param {string} accessToken\n   * @param {string=} refreshToken\n   * @param {string=} idToken\n   */\n  const authSuccess = (accessToken, refreshToken, idToken) => {\n    timeLocal = (timeLocal + new Date().getTime()) / 2;\n    _assertClassBrand(_Keycloak_brand, this, _setToken).call(this, accessToken, refreshToken, idToken, timeLocal);\n    if (_classPrivateFieldGet(_useNonce, this) && this.idTokenParsed && this.idTokenParsed.nonce !== oauth.storedNonce) {\n      _classPrivateFieldGet(_logInfo, this).call(this, '[KEYCLOAK] Invalid nonce, clearing token');\n      this.clearToken();\n      throw new Error('Invalid nonce.');\n    }\n  };\n  if (oauth.kc_action_status) {\n    this.onActionUpdate && this.onActionUpdate(oauth.kc_action_status, oauth.kc_action);\n  }\n  if (error) {\n    if (prompt !== 'none') {\n      if (oauth.error_description && oauth.error_description === 'authentication_expired') {\n        await this.login(oauth.loginOptions);\n      } else {\n        var _this$onAuthError2;\n        const errorData = {\n          error,\n          error_description: oauth.error_description\n        };\n        (_this$onAuthError2 = this.onAuthError) === null || _this$onAuthError2 === void 0 || _this$onAuthError2.call(this, errorData);\n        throw errorData;\n      }\n    }\n    return;\n  } else if (this.flow !== 'standard' && (oauth.access_token || oauth.id_token)) {\n    var _this$onAuthSuccess3;\n    authSuccess(oauth.access_token, undefined, oauth.id_token);\n    (_this$onAuthSuccess3 = this.onAuthSuccess) === null || _this$onAuthSuccess3 === void 0 || _this$onAuthSuccess3.call(this);\n  }\n  if (this.flow !== 'implicit' && code) {\n    try {\n      const response = await fetchAccessToken(this.endpoints.token(), code, /** @type {string} */this.clientId, oauth.redirectUri, oauth.pkceCodeVerifier);\n      authSuccess(response.access_token, response.refresh_token, response.id_token);\n      if (this.flow === 'standard') {\n        var _this$onAuthSuccess4;\n        (_this$onAuthSuccess4 = this.onAuthSuccess) === null || _this$onAuthSuccess4 === void 0 || _this$onAuthSuccess4.call(this);\n      }\n      _assertClassBrand(_Keycloak_brand, this, _scheduleCheckIframe).call(this);\n    } catch (error) {\n      var _this$onAuthError3;\n      (_this$onAuthError3 = this.onAuthError) === null || _this$onAuthError3 === void 0 || _this$onAuthError3.call(this);\n      throw error;\n    }\n  }\n}\nasync function _scheduleCheckIframe() {\n  if (_classPrivateFieldGet(_loginIframe, this).enable && this.token) {\n    await waitForTimeout(_classPrivateFieldGet(_loginIframe, this).interval * 1000);\n    const unchanged = await _assertClassBrand(_Keycloak_brand, this, _checkLoginIframe).call(this);\n    if (unchanged) {\n      await _assertClassBrand(_Keycloak_brand, this, _scheduleCheckIframe).call(this);\n    }\n  }\n}\nfunction _setToken(token, refreshToken, idToken, timeLocal) {\n  if (this.tokenTimeoutHandle) {\n    clearTimeout(this.tokenTimeoutHandle);\n    this.tokenTimeoutHandle = undefined;\n  }\n  if (refreshToken) {\n    this.refreshToken = refreshToken;\n    this.refreshTokenParsed = decodeToken(refreshToken);\n  } else {\n    delete this.refreshToken;\n    delete this.refreshTokenParsed;\n  }\n  if (idToken) {\n    this.idToken = idToken;\n    this.idTokenParsed = decodeToken(idToken);\n  } else {\n    delete this.idToken;\n    delete this.idTokenParsed;\n  }\n  if (token) {\n    this.token = token;\n    this.tokenParsed = decodeToken(token);\n    this.sessionId = this.tokenParsed.sid;\n    this.authenticated = true;\n    this.subject = this.tokenParsed.sub;\n    this.realmAccess = this.tokenParsed.realm_access;\n    this.resourceAccess = this.tokenParsed.resource_access;\n    if (timeLocal) {\n      this.timeSkew = Math.floor(timeLocal / 1000) - this.tokenParsed.iat;\n    }\n    if (this.timeSkew !== null) {\n      _classPrivateFieldGet(_logInfo, this).call(this, '[KEYCLOAK] Estimated time difference between browser and server is ' + this.timeSkew + ' seconds');\n      if (this.onTokenExpired) {\n        const expiresIn = (this.tokenParsed.exp - new Date().getTime() / 1000 + this.timeSkew) * 1000;\n        _classPrivateFieldGet(_logInfo, this).call(this, '[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s');\n        if (expiresIn <= 0) {\n          this.onTokenExpired();\n        } else {\n          this.tokenTimeoutHandle = window.setTimeout(this.onTokenExpired, expiresIn);\n        }\n      }\n    }\n  } else {\n    delete this.token;\n    delete this.tokenParsed;\n    delete this.subject;\n    delete this.realmAccess;\n    delete this.resourceAccess;\n    this.authenticated = false;\n  }\n}\n/**\n * @returns {string=}\n */\nfunction _getRealmUrl() {\n  if (typeof this.authServerUrl === 'undefined') {\n    return;\n  }\n  return \"\".concat(stripTrailingSlash(this.authServerUrl), \"/realms/\").concat(encodeURIComponent(/** @type {string} */this.realm));\n}\n/**\n * @param {Function} fn\n * @returns {(message: string) => void}\n */\nfunction _createLogger(fn) {\n  return message => {\n    if (this.enableLogging) {\n      fn.call(console, message);\n    }\n  };\n}\nfunction createUUID() {\n  if (typeof crypto === 'undefined' || typeof crypto.randomUUID === 'undefined') {\n    throw new Error('Web Crypto API is not available.');\n  }\n  return crypto.randomUUID();\n}\n\n/**\n * @param {Acr} requestedAcr\n * @returns {string}\n */\nfunction buildClaimsParameter(requestedAcr) {\n  return JSON.stringify({\n    id_token: {\n      acr: requestedAcr\n    }\n  });\n}\n\n/**\n * @param {number} len\n * @returns {string}\n */\nfunction generateCodeVerifier(len) {\n  return generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n}\n\n/**\n * @param {string} pkceMethod\n * @param {string} codeVerifier\n * @returns {Promise<string>}\n */\nasync function generatePkceChallenge(pkceMethod, codeVerifier) {\n  if (pkceMethod !== 'S256') {\n    throw new TypeError(\"Invalid value for 'pkceMethod', expected 'S256' but got '\".concat(pkceMethod, \"'.\"));\n  }\n\n  // hash codeVerifier, then encode as url-safe base64 without padding\n  const hashBytes = new Uint8Array(await sha256Digest(codeVerifier));\n  const encodedHash = bytesToBase64(hashBytes).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  return encodedHash;\n}\n\n/**\n * @param {number} len\n * @param {string} alphabet\n * @returns {string}\n */\nfunction generateRandomString(len, alphabet) {\n  const randomData = generateRandomData(len);\n  const chars = new Array(len);\n  for (let i = 0; i < len; i++) {\n    chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);\n  }\n  return String.fromCharCode.apply(null, chars);\n}\n\n/**\n * @param {number} len\n * @returns {Uint8Array<ArrayBuffer>}\n */\nfunction generateRandomData(len) {\n  if (typeof crypto === 'undefined' || typeof crypto.getRandomValues === 'undefined') {\n    throw new Error('Web Crypto API is not available.');\n  }\n  return crypto.getRandomValues(new Uint8Array(len));\n}\n\n/**\n * Function to extend existing native Promise with timeout\n *\n * @template T\n * @param {Promise<T>} promise\n * @param {number} timeout\n * @param {string} errorMessage\n * @returns {Promise<T>}\n */\nfunction applyTimeoutToPromise(promise, timeout, errorMessage) {\n  /** @type {number} */\n  let timeoutHandle;\n  const timeoutPromise = new Promise(function (resolve, reject) {\n    timeoutHandle = window.setTimeout(function () {\n      reject(new Error(errorMessage || 'Promise is not settled within timeout of ' + timeout + 'ms'));\n    }, timeout);\n  });\n  return Promise.race([promise, timeoutPromise]).finally(function () {\n    clearTimeout(timeoutHandle);\n  });\n}\n\n/**\n * @returns {CallbackStorage}\n */\nfunction createCallbackStorage() {\n  try {\n    return new LocalStorage();\n  } catch (err) {\n    return new CookieStorage();\n  }\n}\nconst STORAGE_KEY_PREFIX = 'kc-callback-';\n\n/**\n * @typedef {Object} CallbackState\n * @property {string} state\n * @property {string} nonce\n * @property {string} redirectUri\n * @property {KeycloakLoginOptions} [loginOptions]\n * @property {KeycloakLoginOptions['prompt']} [prompt]\n * @property {string} [pkceCodeVerifier]\n */\n\n/**\n * @typedef {Object} CallbackStorage\n * @property {(state?: string) => CallbackState | null} get\n * @property {(state: CallbackState) => void} add\n */\n\n/**\n * @implements {CallbackStorage}\n */\nvar _LocalStorage_brand = /*#__PURE__*/new WeakSet();\nclass LocalStorage {\n  constructor() {\n    /**\n     * Clears all values from local storage that are no longer valid.\n     */\n    _classPrivateMethodInitSpec(this, _LocalStorage_brand);\n    globalThis.localStorage.setItem('kc-test', 'test');\n    globalThis.localStorage.removeItem('kc-test');\n  }\n\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get(state) {\n    if (!state) {\n      return null;\n    }\n    _assertClassBrand(_LocalStorage_brand, this, _clearInvalidValues).call(this);\n    const key = STORAGE_KEY_PREFIX + state;\n    const value = globalThis.localStorage.getItem(key);\n    if (value) {\n      globalThis.localStorage.removeItem(key);\n      return JSON.parse(value);\n    }\n    return null;\n  }\n  /**\n   * @param {CallbackState} state\n   */\n  add(state) {\n    _assertClassBrand(_LocalStorage_brand, this, _clearInvalidValues).call(this);\n    const key = STORAGE_KEY_PREFIX + state.state;\n    const value = JSON.stringify(_objectSpread(_objectSpread({}, state), {}, {\n      // Set the expiry time to 1 hour from now.\n      expires: Date.now() + 60 * 60 * 1000\n    }));\n    try {\n      globalThis.localStorage.setItem(key, value);\n    } catch (error) {\n      // If the storage is full, clear all known values and try again.\n      _assertClassBrand(_LocalStorage_brand, this, _clearAllValues).call(this);\n      globalThis.localStorage.setItem(key, value);\n    }\n  }\n}\n\n/**\n * @implements {CallbackStorage}\n */\nfunction _clearInvalidValues() {\n  const currentTime = Date.now();\n  for (const [key, value] of _assertClassBrand(_LocalStorage_brand, this, _getStoredEntries).call(this)) {\n    // Attempt to parse the expiry time from the value.\n    const expiry = _assertClassBrand(_LocalStorage_brand, this, _parseExpiry).call(this, value);\n\n    // Discard the value if it is malformed or expired.\n    if (expiry === null || expiry < currentTime) {\n      globalThis.localStorage.removeItem(key);\n    }\n  }\n}\n/**\n * Clears all known values from local storage.\n */\nfunction _clearAllValues() {\n  for (const [key] of _assertClassBrand(_LocalStorage_brand, this, _getStoredEntries).call(this)) {\n    globalThis.localStorage.removeItem(key);\n  }\n}\n/**\n * Gets all entries stored in local storage that are known to be managed by this class.\n * @returns {[string, string][]} An array of key-value pairs.\n */\nfunction _getStoredEntries() {\n  return Object.entries(globalThis.localStorage).filter(_ref => {\n    let [key] = _ref;\n    return key.startsWith(STORAGE_KEY_PREFIX);\n  });\n}\n/**\n * Parses the expiry time from a value stored in local storage.\n * @param {string} value\n * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n */\nfunction _parseExpiry(value) {\n  let parsedValue;\n\n  // Attempt to parse the value as JSON.\n  try {\n    parsedValue = JSON.parse(value);\n  } catch (error) {\n    return null;\n  }\n\n  // Attempt to extract the 'expires' property.\n  if (isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') {\n    return parsedValue.expires;\n  }\n  return null;\n}\nvar _CookieStorage_brand = /*#__PURE__*/new WeakSet();\nclass CookieStorage {\n  constructor() {\n    /**\n     * @param {string} key\n     * @returns\n     */\n    _classPrivateMethodInitSpec(this, _CookieStorage_brand);\n  }\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get(state) {\n    if (!state) {\n      return null;\n    }\n    const value = _assertClassBrand(_CookieStorage_brand, this, _getCookie).call(this, STORAGE_KEY_PREFIX + state);\n    _assertClassBrand(_CookieStorage_brand, this, _setCookie).call(this, STORAGE_KEY_PREFIX + state, '', _assertClassBrand(_CookieStorage_brand, this, _cookieExpiration).call(this, -100));\n    if (value) {\n      return JSON.parse(value);\n    }\n    return null;\n  }\n\n  /**\n   * @param {CallbackState} state\n   */\n  add(state) {\n    _assertClassBrand(_CookieStorage_brand, this, _setCookie).call(this, STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), _assertClassBrand(_CookieStorage_brand, this, _cookieExpiration).call(this, 60));\n  }\n}\n\n/**\n * @param {Uint8Array<ArrayBuffer>} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */\nfunction _getCookie(key) {\n  const name = key + '=';\n  const ca = document.cookie.split(';');\n  for (let i = 0; i < ca.length; i++) {\n    let c = ca[i];\n    while (c.charAt(0) === ' ') {\n      c = c.substring(1);\n    }\n    if (c.indexOf(name) === 0) {\n      return c.substring(name.length, c.length);\n    }\n  }\n  return '';\n}\n/**\n * @param {string} key\n * @param {string} value\n * @param {Date} expirationDate\n */\nfunction _setCookie(key, value, expirationDate) {\n  const cookie = key + '=' + value + '; ' + 'expires=' + expirationDate.toUTCString() + '; ';\n  document.cookie = cookie;\n}\n/**\n * @param {number} minutes\n * @returns {Date}\n */\nfunction _cookieExpiration(minutes) {\n  const exp = new Date();\n  exp.setTime(exp.getTime() + minutes * 60 * 1000);\n  return exp;\n}\nfunction bytesToBase64(bytes) {\n  const binString = String.fromCodePoint(...bytes);\n  return btoa(binString);\n}\n\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */\nasync function sha256Digest(message) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  if (typeof crypto === 'undefined' || typeof crypto.subtle === 'undefined') {\n    throw new Error('Web Crypto API is not available.');\n  }\n  return await crypto.subtle.digest('SHA-256', data);\n}\n\n/**\n * @param {string} token\n * @returns {KeycloakTokenParsed}\n */\nfunction decodeToken(token) {\n  const [, payload] = token.split('.');\n  if (typeof payload !== 'string') {\n    throw new Error('Unable to decode token, payload not found.');\n  }\n  let decoded;\n  try {\n    decoded = base64UrlDecode(payload);\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid Base64URL value.', {\n      cause: error\n    });\n  }\n  try {\n    return JSON.parse(decoded);\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid JSON value.', {\n      cause: error\n    });\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction base64UrlDecode(input) {\n  let output = input.replaceAll('-', '+').replaceAll('_', '/');\n  switch (output.length % 4) {\n    case 0:\n      break;\n    case 2:\n      output += '==';\n      break;\n    case 3:\n      output += '=';\n      break;\n    default:\n      throw new Error('Input is not of the correct length.');\n  }\n  try {\n    return b64DecodeUnicode(output);\n  } catch (error) {\n    return atob(output);\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction b64DecodeUnicode(input) {\n  return decodeURIComponent(atob(input).replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase();\n    if (code.length < 2) {\n      code = '0' + code;\n    }\n    return '%' + code;\n  }));\n}\n\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */\nfunction isObject(input) {\n  return typeof input === 'object' && input !== null;\n}\n\n/**\n * @typedef {Object} JsonConfig The JSON version of the adapter configuration.\n * @property {string} auth-server-url The URL of the authentication server.\n * @property {string} realm The name of the realm.\n * @property {string} resource The name of the resource, usually the client ID.\n */\n\n/**\n * Fetch the adapter configuration from the given URL.\n * @param {string} url\n * @returns {Promise<JsonConfig>}\n */\nasync function fetchJsonConfig(url) {\n  return await fetchJSON(url);\n}\n\n/**\n * Fetch the OpenID configuration from the given URL.\n * @param {string} url\n * @returns {Promise<OpenIdProviderMetadata>}\n */\nasync function fetchOpenIdConfig(url) {\n  return await fetchJSON(url);\n}\n\n/**\n * @typedef {Object} AccessTokenResponse The successful token response from the authorization server, based on the {@link https://datatracker.ietf.org/doc/html/rfc6749#section-5.1 OAuth 2.0 Authorization Framework specification}.\n * @property {string} access_token The access token issued by the authorization server.\n * @property {string} token_type The type of the token issued by the authorization server.\n * @property {number} [expires_in] The lifetime in seconds of the access token.\n * @property {string} [refresh_token] The refresh token issued by the authorization server.\n * @property {string} [id_token] The ID token issued by the authorization server, if requested.\n * @property {string} [scope] The scope of the access token.\n */\n\n/**\n * Fetch the access token from the given URL.\n * @param {string} url\n * @param {string} code\n * @param {string} clientId\n * @param {string} redirectUri\n * @param {string} [pkceCodeVerifier]\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchAccessToken(url, code, clientId, redirectUri, pkceCodeVerifier) {\n  const body = new URLSearchParams([['code', code], ['grant_type', 'authorization_code'], ['client_id', clientId], ['redirect_uri', stripHash(redirectUri)]]);\n  if (pkceCodeVerifier) {\n    body.append('code_verifier', pkceCodeVerifier);\n  }\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  });\n}\n\n/**\n * Fetch the refresh token from the given URL.\n * @param {string} url\n * @param {string} refreshToken\n * @param {string} clientId\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchRefreshToken(url, refreshToken, clientId) {\n  const body = new URLSearchParams([['grant_type', 'refresh_token'], ['refresh_token', refreshToken], ['client_id', clientId]]);\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  });\n}\n\n/**\n * @template [T=unknown]\n * @param {string} url\n * @param {RequestInit} init\n * @returns {Promise<T>}\n */\nasync function fetchJSON(url) {\n  let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const headers = new Headers(init.headers);\n  headers.set('Accept', CONTENT_TYPE_JSON);\n  const response = await fetchWithErrorHandling(url, _objectSpread(_objectSpread({}, init), {}, {\n    headers\n  }));\n  return await response.json();\n}\n\n/**\n * @param {string} url\n * @param {RequestInit} [init]\n * @returns {Promise<Response>}\n */\nasync function fetchWithErrorHandling(url, init) {\n  const response = await fetch(url, init);\n  if (!response.ok) {\n    throw new NetworkError('Server responded with an invalid status.', {\n      response\n    });\n  }\n  return response;\n}\n\n/**\n * @param {string} [token]\n * @returns {[string, string]}\n */\nfunction buildAuthorizationHeader(token) {\n  if (!token) {\n    throw new Error('Unable to build authorization header, token is not set, make sure the user is authenticated.');\n  }\n  return ['Authorization', \"bearer \".concat(token)];\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripTrailingSlash(url) {\n  return url.endsWith('/') ? url.slice(0, -1) : url;\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripHash(url) {\n  const parsedUrl = new URL(url);\n  parsedUrl.hash = '';\n  return parsedUrl.toString();\n}\n\n/**\n * @typedef {Object} NetworkErrorOptionsProperties\n * @property {Response} response\n * @typedef {ErrorOptions & NetworkErrorOptionsProperties} NetworkErrorOptions\n */\n\nexport class NetworkError extends Error {\n  /**\n   * @param {string} message\n   * @param {NetworkErrorOptions} options\n   */\n  constructor(message, options) {\n    super(message, options);\n    /** @type {Response} */\n    _defineProperty(this, \"response\", void 0);\n    this.response = options.response;\n  }\n}\n\n/**\n * @param {number} delay\n * @returns {Promise<void>}\n */\nconst waitForTimeout = delay => new Promise(resolve => setTimeout(resolve, delay));","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}