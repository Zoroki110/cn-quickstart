module TestCriticalIntegration where

import Daml.Script
import DA.Time
import DA.Assert
import DA.List (head)

import qualified Token.Token as T
import qualified LPToken.LPToken as LP
import qualified AMM.Pool as P
import qualified AMM.SwapRequest as SR

-- HIGH-1: Test Add Liquidity After Swap
-- Critical scenario: Verify pool works correctly after reserves are updated by swap
testAddLiquidityAfterSwap : Script ()
testAddLiquidityAfterSwap = script do
  -- Setup parties
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  charlie <- allocateParty "Charlie"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Create pool with initial liquidity (Alice: 10 ETH, 20k USDC)
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0

  -- Alice adds initial liquidity
  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 10.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 20000.0

  (aliceLP, pool1) <- submitMulti [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.AddLiquidity with
    provider = alice
    tokenACid = aliceETH
    tokenBCid = aliceUSDC
    amountA = 10.0
    amountB = 20000.0
    minLPTokens = 0.0
    deadline = addRelTime now (hours 1)

  -- Bob swaps 1000 USDC for ETH
  bobUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = bob
    symbol = "USDC"
    amount = 1000.0

  swapRequest <- submit bob $ createCmd SR.SwapRequest with
    trader = bob
    poolCid = pool1
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = bobUSDC
    inputSymbol = "USDC"
    inputAmount = 1000.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 1000  -- 10% max

  swapReady <- submit bob $ exerciseCmd swapRequest SR.PrepareSwap

  -- Get pool tokens for swap execution
  poolTokens <- query @T.Token poolParty
  let poolETHs = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens
  let poolUSDCs = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens

  assertMsg "Pool should have ETH" (not $ null poolETHs)
  assertMsg "Pool should have USDC" (not $ null poolUSDCs)

  let (poolETHCid, _) = head poolETHs
  let (poolUSDCCid, _) = head poolUSDCs

  (bobETH, pool2) <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap with
    poolTokenACid = poolETHCid
    poolTokenBCid = poolUSDCCid

  -- CRITICAL TEST: Charlie adds liquidity AFTER Bob's swap
  -- This verifies pool reserves were updated correctly and new liquidity can be added
  charlieETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = charlie
    symbol = "ETH"
    amount = 5.0

  charlieUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = charlie
    symbol = "USDC"
    amount = 10000.0

  -- Fetch pool2 to verify reserves
  pool2Data <- query @P.Pool poolOperator
  let [(_, poolState)] = filter (\(cid, _) -> cid == pool2) pool2Data

  -- Pool should have ~10 ETH and ~21000 USDC (original + Bob's swap)
  assertMsg "Pool reserve A should be positive" (poolState.reserveA > 0.0)
  assertMsg "Pool reserve B should be positive" (poolState.reserveB > 0.0)

  (charlieLP, pool3) <- submitMulti [charlie, poolParty, lpIssuer] [] $ exerciseCmd pool2 P.AddLiquidity with
    provider = charlie
    tokenACid = charlieETH
    tokenBCid = charlieUSDC
    amountA = 5.0
    amountB = 10000.0
    minLPTokens = 0.0
    deadline = addRelTime now (hours 1)

  -- Verify Charlie got LP tokens
  charlieLPData <- queryContractId charlie charlieLP
  case charlieLPData of
    None -> assertFail "Charlie should have LP tokens"
    Some lp -> assertMsg "Charlie LP amount should be positive" (lp.amount > 0.0)

  -- Verify pool3 reserves increased correctly
  pool3Data <- query @P.Pool poolOperator
  let [(_, pool3State)] = filter (\(cid, _) -> cid == pool3) pool3Data

  assertMsg "Pool reserve A increased" (pool3State.reserveA > poolState.reserveA)
  assertMsg "Pool reserve B increased" (pool3State.reserveB > poolState.reserveB)
  assertMsg "LP supply increased" (pool3State.totalLPSupply > poolState.totalLPSupply)

  return ()


-- HIGH-2: Test Remove Liquidity After Swap
-- Critical scenario: Verify LP holders can exit after pool activity
testRemoveLiquidityAfterSwap : Script ()
testRemoveLiquidityAfterSwap = script do
  -- Setup parties
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Create pool
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0

  -- Alice adds initial liquidity: 10 ETH, 20k USDC
  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 10.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 20000.0

  (aliceLP, pool1) <- submitMulti [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.AddLiquidity with
    provider = alice
    tokenACid = aliceETH
    tokenBCid = aliceUSDC
    amountA = 10.0
    amountB = 20000.0
    minLPTokens = 0.0
    deadline = addRelTime now (hours 1)

  -- Get Alice's LP token amount
  aliceLPData <- queryContractId alice aliceLP
  let Some aliceLPToken = aliceLPData
  let initialLPAmount = aliceLPToken.amount

  -- Bob swaps 500 USDC for ETH (generates fees for Alice)
  bobUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = bob
    symbol = "USDC"
    amount = 500.0

  swapRequest <- submit bob $ createCmd SR.SwapRequest with
    trader = bob
    poolCid = pool1
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = bobUSDC
    inputSymbol = "USDC"
    inputAmount = 500.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 1000

  swapReady <- submit bob $ exerciseCmd swapRequest SR.PrepareSwap

  poolTokens <- query @T.Token poolParty
  let poolETHs = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens
  let poolUSDCs = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens
  let (poolETHCid, _) = head poolETHs
  let (poolUSDCCid, _) = head poolUSDCs

  (bobETH, pool2) <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap with
    poolTokenACid = poolETHCid
    poolTokenBCid = poolUSDCCid

  -- CRITICAL TEST: Alice removes 50% of her liquidity AFTER Bob's swap
  -- This verifies LP tokens work correctly after pool reserves updated
  let lpToRemove = initialLPAmount / 2.0

  -- Get updated pool tokens after swap
  poolTokens2 <- query @T.Token poolParty
  let poolETHs2 = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens2
  let poolUSDCs2 = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens2

  assertMsg "Pool should still have ETH after swap" (not $ null poolETHs2)
  assertMsg "Pool should still have USDC after swap" (not $ null poolUSDCs2)

  let (poolETHCid2, _) = head poolETHs2
  let (poolUSDCCid2, _) = head poolUSDCs2

  (aliceETHout, aliceUSDCout, pool3) <- submitMulti [alice, poolParty, lpIssuer] [] $ exerciseCmd pool2 P.RemoveLiquidity with
    provider = alice
    lpTokenCid = aliceLP
    lpTokenAmount = lpToRemove
    minAmountA = 0.0
    minAmountB = 0.0
    poolTokenACid = poolETHCid2
    poolTokenBCid = poolUSDCCid2
    deadline = addRelTime now (hours 1)

  -- Verify Alice received tokens
  aliceETHoutData <- queryContractId alice aliceETHout
  aliceUSDCoutData <- queryContractId alice aliceUSDCout

  case (aliceETHoutData, aliceUSDCoutData) of
    (Some eth, Some usdc) -> do
      assertMsg "Alice should receive ETH" (eth.amount > 0.0)
      assertMsg "Alice should receive USDC" (usdc.amount > 0.0)
      -- Alice should receive slightly more than 50% due to accrued fees from Bob's swap
      assertMsg "Alice ETH should be ~5 (half of 10)" (eth.amount >= 4.9 && eth.amount <= 5.1)
    _ -> assertFail "Alice should receive both tokens"

  -- Verify pool LP supply decreased
  pool3Data <- query @P.Pool poolOperator
  let [(_, pool3State)] = filter (\(cid, _) -> cid == pool3) pool3Data

  pool2Data <- queryContractId poolOperator pool2
  let Some pool2State = pool2Data

  assertMsg "LP supply should decrease" (pool3State.totalLPSupply < pool2State.totalLPSupply)

  return ()


-- Integration Test: Full Cycle (Add → Swap → Swap → Remove)
testFullCycleWithMultipleSwaps : Script ()
testFullCycleWithMultipleSwaps = script do
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  charlie <- allocateParty "Charlie"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime

  -- Step 1: Create empty pool
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0

  -- Step 2: Alice adds liquidity (100 ETH, 200k USDC)
  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 100.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 200000.0

  (aliceLP, pool1) <- submitMulti [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.AddLiquidity with
    provider = alice
    tokenACid = aliceETH
    tokenBCid = aliceUSDC
    amountA = 100.0
    amountB = 200000.0
    minLPTokens = 0.0
    deadline = addRelTime now (hours 1)

  -- Fetch initial pool state
  pool1Data <- queryContractId poolOperator pool1
  let Some pool1State = pool1Data
  let k_initial = pool1State.reserveA * pool1State.reserveB

  -- Step 3: Bob swaps USDC → ETH
  bobUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = bob
    symbol = "USDC"
    amount = 5000.0

  swapReq1 <- submit bob $ createCmd SR.SwapRequest with
    trader = bob
    poolCid = pool1
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = bobUSDC
    inputSymbol = "USDC"
    inputAmount = 5000.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 5000

  swapReady1 <- submit bob $ exerciseCmd swapReq1 SR.PrepareSwap

  poolTokens1 <- query @T.Token poolParty
  let poolETHs1 = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens1
  let poolUSDCs1 = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens1
  let (poolETHCid1, _) = head poolETHs1
  let (poolUSDCCid1, _) = head poolUSDCs1

  (bobETH1, pool2) <- submit poolParty $ exerciseCmd swapReady1 SR.ExecuteSwap with
    poolTokenACid = poolETHCid1
    poolTokenBCid = poolUSDCCid1

  -- Step 4: Charlie swaps ETH → USDC
  charlieETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = charlie
    symbol = "ETH"
    amount = 1.0

  swapReq2 <- submit charlie $ createCmd SR.SwapRequest with
    trader = charlie
    poolCid = pool2
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = charlieETH
    inputSymbol = "ETH"
    inputAmount = 1.0
    outputSymbol = "USDC"
    minOutput = 0.0
    deadline = addRelTime now (hours 1)
    maxPriceImpactBps = 5000

  swapReady2 <- submit charlie $ exerciseCmd swapReq2 SR.PrepareSwap

  poolTokens2 <- query @T.Token poolParty
  let poolETHs2 = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens2
  let poolUSDCs2 = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens2
  let (poolETHCid2, _) = head poolETHs2
  let (poolUSDCCid2, _) = head poolUSDCs2

  (charlieUSDC, pool3) <- submit poolParty $ exerciseCmd swapReady2 SR.ExecuteSwap with
    poolTokenACid = poolETHCid2
    poolTokenBCid = poolUSDCCid2

  -- Fetch pool state after swaps
  pool3Data <- queryContractId poolOperator pool3
  let Some pool3State = pool3Data
  let k_after_swaps = pool3State.reserveA * pool3State.reserveB

  -- Verify k increased (fees accumulated)
  assertMsg "K should increase due to fees" (k_after_swaps >= k_initial)

  -- Step 5: Alice removes ALL liquidity
  aliceLPData <- queryContractId alice aliceLP
  let Some aliceLPToken = aliceLPData

  poolTokens3 <- query @T.Token poolParty
  let poolETHs3 = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens3
  let poolUSDCs3 = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens3
  let (poolETHCid3, _) = head poolETHs3
  let (poolUSDCCid3, _) = head poolUSDCs3

  (aliceETHfinal, aliceUSDCfinal, pool4) <- submitMulti [alice, poolParty, lpIssuer] [] $ exerciseCmd pool3 P.RemoveLiquidity with
    provider = alice
    lpTokenCid = aliceLP
    lpTokenAmount = aliceLPToken.amount
    minAmountA = 0.0
    minAmountB = 0.0
    poolTokenACid = poolETHCid3
    poolTokenBCid = poolUSDCCid3
    deadline = addRelTime now (hours 1)

  -- Verify Alice received MORE than initial (due to fees)
  aliceETHfinalData <- queryContractId alice aliceETHfinal
  aliceUSDCfinalData <- queryContractId alice aliceUSDCfinal

  case (aliceETHfinalData, aliceUSDCfinalData) of
    (Some eth, Some usdc) -> do
      -- Alice should get back slightly more than 100 ETH and 200k USDC due to fees
      assertMsg "Alice should profit from fees (ETH)" (eth.amount >= 100.0)
      assertMsg "Alice should profit from fees (USDC)" (usdc.amount >= 200000.0)
    _ -> assertFail "Alice should receive both tokens"

  return ()
