module StandaloneSwapTest where

import Daml.Script
import DA.Time
import qualified Token.Token as T
import qualified AMM.SwapRequest as SR
import qualified AMM.Pool as P

-- Test standalone: init + swap dans le mÃªme script
standaloneSwapTest : Script ()
standaloneSwapTest = script do
  -- Parties
  alice <- allocateParty "Alice"
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  clearportx <- allocateParty "ClearportX"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime
  let deadline = addRelTime now (hours 1)

  debug "Step 1: Creating empty pool..."
  emptyPool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  debug "Step 2: Creating LP tokens..."
  lpETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolOperator
    symbol = "ETH"
    amount = 100.0

  lpUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolOperator
    symbol = "USDC"
    amount = 200000.0

  debug "Step 3: Adding liquidity..."
  (lpToken, pool) <- submitMulti [poolOperator, poolParty, lpIssuer] [] $
    exerciseCmd emptyPool P.AddLiquidity with
      provider = poolOperator
      tokenACid = lpETH
      tokenBCid = lpUSDC
      amountA = 100.0
      amountB = 200000.0
      minLPTokens = 0.0
      deadline = deadline

  debug "âœ… Pool has liquidity: 100 ETH + 200,000 USDC"

  debug "Step 4: Creating Alice's USDC..."
  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 5000.0

  debug "Step 5: Creating swap request..."
  swapReq <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty = poolParty
    poolOperator = poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 5000.0
    outputSymbol = "ETH"
    minOutput = 2.0
    deadline = deadline
    maxPriceImpactBps = 500

  debug "Step 6: Preparing swap..."
  (swapReady, _) <- submit alice $ exerciseCmd swapReq SR.PrepareSwap with protocolFeeReceiver = clearportx

  debug "Step 7: Executing swap..."
  receiptCid <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap

  debug "Step 8: Verifying result..."
  Some receipt <- queryContractId alice receiptCid
  Some ethToken <- queryContractId alice receipt.outputTokenCid

  debug ""
  debug "ðŸŽ‰ SWAP SUCCESSFUL!"
  debug $ "   Alice swapped: 5,000 USDC"
  debug $ "   Alice received: " <> show ethToken.amount <> " ETH"
  debug $ "   Expected ~2.44 ETH"
  debug $ "   Price: " <> show receipt.price <> " ETH/USDC"

  -- VÃ©rification
  assertMsg "Alice should receive ~2.44 ETH" (ethToken.amount > 2.4 && ethToken.amount < 2.5)

  return ()
