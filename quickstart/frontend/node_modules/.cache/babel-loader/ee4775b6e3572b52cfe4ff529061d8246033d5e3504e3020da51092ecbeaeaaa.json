{"ast":null,"code":"import _defineProperty from \"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar __create = Object.create;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __toESM = (mod, isNodeMode, target) => {\n  target = mod != null ? __create(__getProtoOf(mod)) : {};\n  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n    value: mod,\n    enumerable: true\n  }) : target;\n  for (let key of __getOwnPropNames(mod)) if (!__hasOwnProp.call(to, key)) __defProp(to, key, {\n    get: () => mod[key],\n    enumerable: true\n  });\n  return to;\n};\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = {\n  exports: {}\n}).exports, mod), mod.exports);\n\n// node_modules/qrcode/lib/can-promise.js\nvar require_can_promise = __commonJS((exports, module) => {\n  module.exports = function () {\n    return typeof Promise === \"function\" && Promise.prototype && Promise.prototype.then;\n  };\n});\n\n// node_modules/qrcode/lib/core/utils.js\nvar require_utils = __commonJS(exports => {\n  var toSJISFunction;\n  var CODEWORDS_COUNT = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];\n  exports.getSymbolSize = function getSymbolSize(version) {\n    if (!version) throw new Error('\"version\" cannot be null or undefined');\n    if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40');\n    return version * 4 + 17;\n  };\n  exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {\n    return CODEWORDS_COUNT[version];\n  };\n  exports.getBCHDigit = function (data) {\n    let digit = 0;\n    while (data !== 0) {\n      digit++;\n      data >>>= 1;\n    }\n    return digit;\n  };\n  exports.setToSJISFunction = function setToSJISFunction(f) {\n    if (typeof f !== \"function\") {\n      throw new Error('\"toSJISFunc\" is not a valid function.');\n    }\n    toSJISFunction = f;\n  };\n  exports.isKanjiModeEnabled = function () {\n    return typeof toSJISFunction !== \"undefined\";\n  };\n  exports.toSJIS = function toSJIS(kanji) {\n    return toSJISFunction(kanji);\n  };\n});\n\n// node_modules/qrcode/lib/core/error-correction-level.js\nvar require_error_correction_level = __commonJS(exports => {\n  exports.L = {\n    bit: 1\n  };\n  exports.M = {\n    bit: 0\n  };\n  exports.Q = {\n    bit: 3\n  };\n  exports.H = {\n    bit: 2\n  };\n  function fromString(string) {\n    if (typeof string !== \"string\") {\n      throw new Error(\"Param is not a string\");\n    }\n    const lcStr = string.toLowerCase();\n    switch (lcStr) {\n      case \"l\":\n      case \"low\":\n        return exports.L;\n      case \"m\":\n      case \"medium\":\n        return exports.M;\n      case \"q\":\n      case \"quartile\":\n        return exports.Q;\n      case \"h\":\n      case \"high\":\n        return exports.H;\n      default:\n        throw new Error(\"Unknown EC Level: \" + string);\n    }\n  }\n  exports.isValid = function isValid(level) {\n    return level && typeof level.bit !== \"undefined\" && level.bit >= 0 && level.bit < 4;\n  };\n  exports.from = function from(value, defaultValue) {\n    if (exports.isValid(value)) {\n      return value;\n    }\n    try {\n      return fromString(value);\n    } catch (e) {\n      return defaultValue;\n    }\n  };\n});\n\n// node_modules/qrcode/lib/core/bit-buffer.js\nvar require_bit_buffer = __commonJS((exports, module) => {\n  function BitBuffer() {\n    this.buffer = [];\n    this.length = 0;\n  }\n  BitBuffer.prototype = {\n    get: function (index) {\n      const bufIndex = Math.floor(index / 8);\n      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;\n    },\n    put: function (num, length) {\n      for (let i = 0; i < length; i++) {\n        this.putBit((num >>> length - i - 1 & 1) === 1);\n      }\n    },\n    getLengthInBits: function () {\n      return this.length;\n    },\n    putBit: function (bit) {\n      const bufIndex = Math.floor(this.length / 8);\n      if (this.buffer.length <= bufIndex) {\n        this.buffer.push(0);\n      }\n      if (bit) {\n        this.buffer[bufIndex] |= 128 >>> this.length % 8;\n      }\n      this.length++;\n    }\n  };\n  module.exports = BitBuffer;\n});\n\n// node_modules/qrcode/lib/core/bit-matrix.js\nvar require_bit_matrix = __commonJS((exports, module) => {\n  function BitMatrix(size) {\n    if (!size || size < 1) {\n      throw new Error(\"BitMatrix size must be defined and greater than 0\");\n    }\n    this.size = size;\n    this.data = new Uint8Array(size * size);\n    this.reservedBit = new Uint8Array(size * size);\n  }\n  BitMatrix.prototype.set = function (row, col, value, reserved) {\n    const index = row * this.size + col;\n    this.data[index] = value;\n    if (reserved) this.reservedBit[index] = true;\n  };\n  BitMatrix.prototype.get = function (row, col) {\n    return this.data[row * this.size + col];\n  };\n  BitMatrix.prototype.xor = function (row, col, value) {\n    this.data[row * this.size + col] ^= value;\n  };\n  BitMatrix.prototype.isReserved = function (row, col) {\n    return this.reservedBit[row * this.size + col];\n  };\n  module.exports = BitMatrix;\n});\n\n// node_modules/qrcode/lib/core/alignment-pattern.js\nvar require_alignment_pattern = __commonJS(exports => {\n  var getSymbolSize = require_utils().getSymbolSize;\n  exports.getRowColCoords = function getRowColCoords(version) {\n    if (version === 1) return [];\n    const posCount = Math.floor(version / 7) + 2;\n    const size = getSymbolSize(version);\n    const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;\n    const positions = [size - 7];\n    for (let i = 1; i < posCount - 1; i++) {\n      positions[i] = positions[i - 1] - intervals;\n    }\n    positions.push(6);\n    return positions.reverse();\n  };\n  exports.getPositions = function getPositions(version) {\n    const coords = [];\n    const pos = exports.getRowColCoords(version);\n    const posLength = pos.length;\n    for (let i = 0; i < posLength; i++) {\n      for (let j = 0; j < posLength; j++) {\n        if (i === 0 && j === 0 || i === 0 && j === posLength - 1 || i === posLength - 1 && j === 0) {\n          continue;\n        }\n        coords.push([pos[i], pos[j]]);\n      }\n    }\n    return coords;\n  };\n});\n\n// node_modules/qrcode/lib/core/finder-pattern.js\nvar require_finder_pattern = __commonJS(exports => {\n  var getSymbolSize = require_utils().getSymbolSize;\n  var FINDER_PATTERN_SIZE = 7;\n  exports.getPositions = function getPositions(version) {\n    const size = getSymbolSize(version);\n    return [[0, 0], [size - FINDER_PATTERN_SIZE, 0], [0, size - FINDER_PATTERN_SIZE]];\n  };\n});\n\n// node_modules/qrcode/lib/core/mask-pattern.js\nvar require_mask_pattern = __commonJS(exports => {\n  exports.Patterns = {\n    PATTERN000: 0,\n    PATTERN001: 1,\n    PATTERN010: 2,\n    PATTERN011: 3,\n    PATTERN100: 4,\n    PATTERN101: 5,\n    PATTERN110: 6,\n    PATTERN111: 7\n  };\n  var PenaltyScores = {\n    N1: 3,\n    N2: 3,\n    N3: 40,\n    N4: 10\n  };\n  exports.isValid = function isValid(mask) {\n    return mask != null && mask !== \"\" && !isNaN(mask) && mask >= 0 && mask <= 7;\n  };\n  exports.from = function from(value) {\n    return exports.isValid(value) ? parseInt(value, 10) : undefined;\n  };\n  exports.getPenaltyN1 = function getPenaltyN1(data) {\n    const size = data.size;\n    let points = 0;\n    let sameCountCol = 0;\n    let sameCountRow = 0;\n    let lastCol = null;\n    let lastRow = null;\n    for (let row = 0; row < size; row++) {\n      sameCountCol = sameCountRow = 0;\n      lastCol = lastRow = null;\n      for (let col = 0; col < size; col++) {\n        let module2 = data.get(row, col);\n        if (module2 === lastCol) {\n          sameCountCol++;\n        } else {\n          if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n          lastCol = module2;\n          sameCountCol = 1;\n        }\n        module2 = data.get(col, row);\n        if (module2 === lastRow) {\n          sameCountRow++;\n        } else {\n          if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n          lastRow = module2;\n          sameCountRow = 1;\n        }\n      }\n      if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n      if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n    }\n    return points;\n  };\n  exports.getPenaltyN2 = function getPenaltyN2(data) {\n    const size = data.size;\n    let points = 0;\n    for (let row = 0; row < size - 1; row++) {\n      for (let col = 0; col < size - 1; col++) {\n        const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);\n        if (last === 4 || last === 0) points++;\n      }\n    }\n    return points * PenaltyScores.N2;\n  };\n  exports.getPenaltyN3 = function getPenaltyN3(data) {\n    const size = data.size;\n    let points = 0;\n    let bitsCol = 0;\n    let bitsRow = 0;\n    for (let row = 0; row < size; row++) {\n      bitsCol = bitsRow = 0;\n      for (let col = 0; col < size; col++) {\n        bitsCol = bitsCol << 1 & 2047 | data.get(row, col);\n        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;\n        bitsRow = bitsRow << 1 & 2047 | data.get(col, row);\n        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;\n      }\n    }\n    return points * PenaltyScores.N3;\n  };\n  exports.getPenaltyN4 = function getPenaltyN4(data) {\n    let darkCount = 0;\n    const modulesCount = data.data.length;\n    for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];\n    const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);\n    return k * PenaltyScores.N4;\n  };\n  function getMaskAt(maskPattern, i, j) {\n    switch (maskPattern) {\n      case exports.Patterns.PATTERN000:\n        return (i + j) % 2 === 0;\n      case exports.Patterns.PATTERN001:\n        return i % 2 === 0;\n      case exports.Patterns.PATTERN010:\n        return j % 3 === 0;\n      case exports.Patterns.PATTERN011:\n        return (i + j) % 3 === 0;\n      case exports.Patterns.PATTERN100:\n        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\n      case exports.Patterns.PATTERN101:\n        return i * j % 2 + i * j % 3 === 0;\n      case exports.Patterns.PATTERN110:\n        return (i * j % 2 + i * j % 3) % 2 === 0;\n      case exports.Patterns.PATTERN111:\n        return (i * j % 3 + (i + j) % 2) % 2 === 0;\n      default:\n        throw new Error(\"bad maskPattern:\" + maskPattern);\n    }\n  }\n  exports.applyMask = function applyMask(pattern, data) {\n    const size = data.size;\n    for (let col = 0; col < size; col++) {\n      for (let row = 0; row < size; row++) {\n        if (data.isReserved(row, col)) continue;\n        data.xor(row, col, getMaskAt(pattern, row, col));\n      }\n    }\n  };\n  exports.getBestMask = function getBestMask(data, setupFormatFunc) {\n    const numPatterns = Object.keys(exports.Patterns).length;\n    let bestPattern = 0;\n    let lowerPenalty = Infinity;\n    for (let p = 0; p < numPatterns; p++) {\n      setupFormatFunc(p);\n      exports.applyMask(p, data);\n      const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);\n      exports.applyMask(p, data);\n      if (penalty < lowerPenalty) {\n        lowerPenalty = penalty;\n        bestPattern = p;\n      }\n    }\n    return bestPattern;\n  };\n});\n\n// node_modules/qrcode/lib/core/error-correction-code.js\nvar require_error_correction_code = __commonJS(exports => {\n  var ECLevel = require_error_correction_level();\n  var EC_BLOCKS_TABLE = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81];\n  var EC_CODEWORDS_TABLE = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];\n  exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {\n    switch (errorCorrectionLevel) {\n      case ECLevel.L:\n        return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];\n      case ECLevel.M:\n        return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];\n      case ECLevel.Q:\n        return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];\n      case ECLevel.H:\n        return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];\n      default:\n        return;\n    }\n  };\n  exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {\n    switch (errorCorrectionLevel) {\n      case ECLevel.L:\n        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];\n      case ECLevel.M:\n        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];\n      case ECLevel.Q:\n        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];\n      case ECLevel.H:\n        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];\n      default:\n        return;\n    }\n  };\n});\n\n// node_modules/qrcode/lib/core/galois-field.js\nvar require_galois_field = __commonJS(exports => {\n  var EXP_TABLE = new Uint8Array(512);\n  var LOG_TABLE = new Uint8Array(256);\n  (function initTables() {\n    let x = 1;\n    for (let i = 0; i < 255; i++) {\n      EXP_TABLE[i] = x;\n      LOG_TABLE[x] = i;\n      x <<= 1;\n      if (x & 256) {\n        x ^= 285;\n      }\n    }\n    for (let i = 255; i < 512; i++) {\n      EXP_TABLE[i] = EXP_TABLE[i - 255];\n    }\n  })();\n  exports.log = function log(n) {\n    if (n < 1) throw new Error(\"log(\" + n + \")\");\n    return LOG_TABLE[n];\n  };\n  exports.exp = function exp(n) {\n    return EXP_TABLE[n];\n  };\n  exports.mul = function mul(x, y) {\n    if (x === 0 || y === 0) return 0;\n    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];\n  };\n});\n\n// node_modules/qrcode/lib/core/polynomial.js\nvar require_polynomial = __commonJS(exports => {\n  var GF = require_galois_field();\n  exports.mul = function mul(p1, p2) {\n    const coeff = new Uint8Array(p1.length + p2.length - 1);\n    for (let i = 0; i < p1.length; i++) {\n      for (let j = 0; j < p2.length; j++) {\n        coeff[i + j] ^= GF.mul(p1[i], p2[j]);\n      }\n    }\n    return coeff;\n  };\n  exports.mod = function mod(divident, divisor) {\n    let result = new Uint8Array(divident);\n    while (result.length - divisor.length >= 0) {\n      const coeff = result[0];\n      for (let i = 0; i < divisor.length; i++) {\n        result[i] ^= GF.mul(divisor[i], coeff);\n      }\n      let offset = 0;\n      while (offset < result.length && result[offset] === 0) offset++;\n      result = result.slice(offset);\n    }\n    return result;\n  };\n  exports.generateECPolynomial = function generateECPolynomial(degree) {\n    let poly = new Uint8Array([1]);\n    for (let i = 0; i < degree; i++) {\n      poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));\n    }\n    return poly;\n  };\n});\n\n// node_modules/qrcode/lib/core/reed-solomon-encoder.js\nvar require_reed_solomon_encoder = __commonJS((exports, module) => {\n  var Polynomial = require_polynomial();\n  function ReedSolomonEncoder(degree) {\n    this.genPoly = undefined;\n    this.degree = degree;\n    if (this.degree) this.initialize(this.degree);\n  }\n  ReedSolomonEncoder.prototype.initialize = function initialize(degree) {\n    this.degree = degree;\n    this.genPoly = Polynomial.generateECPolynomial(this.degree);\n  };\n  ReedSolomonEncoder.prototype.encode = function encode(data) {\n    if (!this.genPoly) {\n      throw new Error(\"Encoder not initialized\");\n    }\n    const paddedData = new Uint8Array(data.length + this.degree);\n    paddedData.set(data);\n    const remainder = Polynomial.mod(paddedData, this.genPoly);\n    const start = this.degree - remainder.length;\n    if (start > 0) {\n      const buff = new Uint8Array(this.degree);\n      buff.set(remainder, start);\n      return buff;\n    }\n    return remainder;\n  };\n  module.exports = ReedSolomonEncoder;\n});\n\n// node_modules/qrcode/lib/core/version-check.js\nvar require_version_check = __commonJS(exports => {\n  exports.isValid = function isValid(version) {\n    return !isNaN(version) && version >= 1 && version <= 40;\n  };\n});\n\n// node_modules/qrcode/lib/core/regex.js\nvar require_regex = __commonJS(exports => {\n  var numeric = \"[0-9]+\";\n  var alphanumeric = \"[A-Z $%*+\\\\-./:]+\";\n  var kanji = \"(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|\" + \"[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|\" + \"[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|\" + \"[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+\";\n  kanji = kanji.replace(/u/g, \"\\\\u\");\n  var byte = \"(?:(?![A-Z0-9 $%*+\\\\-./:]|\" + kanji + \")(?:.|[\\r\\n]))+\";\n  exports.KANJI = new RegExp(kanji, \"g\");\n  exports.BYTE_KANJI = new RegExp(\"[^A-Z0-9 $%*+\\\\-./:]+\", \"g\");\n  exports.BYTE = new RegExp(byte, \"g\");\n  exports.NUMERIC = new RegExp(numeric, \"g\");\n  exports.ALPHANUMERIC = new RegExp(alphanumeric, \"g\");\n  var TEST_KANJI = new RegExp(\"^\" + kanji + \"$\");\n  var TEST_NUMERIC = new RegExp(\"^\" + numeric + \"$\");\n  var TEST_ALPHANUMERIC = new RegExp(\"^[A-Z0-9 $%*+\\\\-./:]+$\");\n  exports.testKanji = function testKanji(str) {\n    return TEST_KANJI.test(str);\n  };\n  exports.testNumeric = function testNumeric(str) {\n    return TEST_NUMERIC.test(str);\n  };\n  exports.testAlphanumeric = function testAlphanumeric(str) {\n    return TEST_ALPHANUMERIC.test(str);\n  };\n});\n\n// node_modules/qrcode/lib/core/mode.js\nvar require_mode = __commonJS(exports => {\n  var VersionCheck = require_version_check();\n  var Regex = require_regex();\n  exports.NUMERIC = {\n    id: \"Numeric\",\n    bit: 1 << 0,\n    ccBits: [10, 12, 14]\n  };\n  exports.ALPHANUMERIC = {\n    id: \"Alphanumeric\",\n    bit: 1 << 1,\n    ccBits: [9, 11, 13]\n  };\n  exports.BYTE = {\n    id: \"Byte\",\n    bit: 1 << 2,\n    ccBits: [8, 16, 16]\n  };\n  exports.KANJI = {\n    id: \"Kanji\",\n    bit: 1 << 3,\n    ccBits: [8, 10, 12]\n  };\n  exports.MIXED = {\n    bit: -1\n  };\n  exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n    if (!mode.ccBits) throw new Error(\"Invalid mode: \" + mode);\n    if (!VersionCheck.isValid(version)) {\n      throw new Error(\"Invalid version: \" + version);\n    }\n    if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];\n    return mode.ccBits[2];\n  };\n  exports.getBestModeForData = function getBestModeForData(dataStr) {\n    if (Regex.testNumeric(dataStr)) return exports.NUMERIC;else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (Regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;\n  };\n  exports.toString = function toString(mode) {\n    if (mode && mode.id) return mode.id;\n    throw new Error(\"Invalid mode\");\n  };\n  exports.isValid = function isValid(mode) {\n    return mode && mode.bit && mode.ccBits;\n  };\n  function fromString(string) {\n    if (typeof string !== \"string\") {\n      throw new Error(\"Param is not a string\");\n    }\n    const lcStr = string.toLowerCase();\n    switch (lcStr) {\n      case \"numeric\":\n        return exports.NUMERIC;\n      case \"alphanumeric\":\n        return exports.ALPHANUMERIC;\n      case \"kanji\":\n        return exports.KANJI;\n      case \"byte\":\n        return exports.BYTE;\n      default:\n        throw new Error(\"Unknown mode: \" + string);\n    }\n  }\n  exports.from = function from(value, defaultValue) {\n    if (exports.isValid(value)) {\n      return value;\n    }\n    try {\n      return fromString(value);\n    } catch (e) {\n      return defaultValue;\n    }\n  };\n});\n\n// node_modules/qrcode/lib/core/version.js\nvar require_version = __commonJS(exports => {\n  var Utils = require_utils();\n  var ECCode = require_error_correction_code();\n  var ECLevel = require_error_correction_level();\n  var Mode = require_mode();\n  var VersionCheck = require_version_check();\n  var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n  var G18_BCH = Utils.getBCHDigit(G18);\n  function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {\n    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n        return currentVersion;\n      }\n    }\n    return;\n  }\n  function getReservedBitsCount(mode, version) {\n    return Mode.getCharCountIndicator(mode, version) + 4;\n  }\n  function getTotalBitsFromDataArray(segments, version) {\n    let totalBits = 0;\n    segments.forEach(function (data) {\n      const reservedBits = getReservedBitsCount(data.mode, version);\n      totalBits += reservedBits + data.getBitsLength();\n    });\n    return totalBits;\n  }\n  function getBestVersionForMixedData(segments, errorCorrectionLevel) {\n    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n      const length = getTotalBitsFromDataArray(segments, currentVersion);\n      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n        return currentVersion;\n      }\n    }\n    return;\n  }\n  exports.from = function from(value, defaultValue) {\n    if (VersionCheck.isValid(value)) {\n      return parseInt(value, 10);\n    }\n    return defaultValue;\n  };\n  exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {\n    if (!VersionCheck.isValid(version)) {\n      throw new Error(\"Invalid QR Code version\");\n    }\n    if (typeof mode === \"undefined\") mode = Mode.BYTE;\n    const totalCodewords = Utils.getSymbolTotalCodewords(version);\n    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n    if (mode === Mode.MIXED) return dataTotalCodewordsBits;\n    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);\n    switch (mode) {\n      case Mode.NUMERIC:\n        return Math.floor(usableBits / 10 * 3);\n      case Mode.ALPHANUMERIC:\n        return Math.floor(usableBits / 11 * 2);\n      case Mode.KANJI:\n        return Math.floor(usableBits / 13);\n      case Mode.BYTE:\n      default:\n        return Math.floor(usableBits / 8);\n    }\n  };\n  exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {\n    let seg;\n    const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);\n    if (Array.isArray(data)) {\n      if (data.length > 1) {\n        return getBestVersionForMixedData(data, ecl);\n      }\n      if (data.length === 0) {\n        return 1;\n      }\n      seg = data[0];\n    } else {\n      seg = data;\n    }\n    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);\n  };\n  exports.getEncodedBits = function getEncodedBits(version) {\n    if (!VersionCheck.isValid(version) || version < 7) {\n      throw new Error(\"Invalid QR Code version\");\n    }\n    let d = version << 12;\n    while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n      d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;\n    }\n    return version << 12 | d;\n  };\n});\n\n// node_modules/qrcode/lib/core/format-info.js\nvar require_format_info = __commonJS(exports => {\n  var Utils = require_utils();\n  var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\n  var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\n  var G15_BCH = Utils.getBCHDigit(G15);\n  exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {\n    const data = errorCorrectionLevel.bit << 3 | mask;\n    let d = data << 10;\n    while (Utils.getBCHDigit(d) - G15_BCH >= 0) {\n      d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;\n    }\n    return (data << 10 | d) ^ G15_MASK;\n  };\n});\n\n// node_modules/qrcode/lib/core/numeric-data.js\nvar require_numeric_data = __commonJS((exports, module) => {\n  var Mode = require_mode();\n  function NumericData(data) {\n    this.mode = Mode.NUMERIC;\n    this.data = data.toString();\n  }\n  NumericData.getBitsLength = function getBitsLength(length) {\n    return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);\n  };\n  NumericData.prototype.getLength = function getLength() {\n    return this.data.length;\n  };\n  NumericData.prototype.getBitsLength = function getBitsLength() {\n    return NumericData.getBitsLength(this.data.length);\n  };\n  NumericData.prototype.write = function write(bitBuffer) {\n    let i, group, value;\n    for (i = 0; i + 3 <= this.data.length; i += 3) {\n      group = this.data.substr(i, 3);\n      value = parseInt(group, 10);\n      bitBuffer.put(value, 10);\n    }\n    const remainingNum = this.data.length - i;\n    if (remainingNum > 0) {\n      group = this.data.substr(i);\n      value = parseInt(group, 10);\n      bitBuffer.put(value, remainingNum * 3 + 1);\n    }\n  };\n  module.exports = NumericData;\n});\n\n// node_modules/qrcode/lib/core/alphanumeric-data.js\nvar require_alphanumeric_data = __commonJS((exports, module) => {\n  var Mode = require_mode();\n  var ALPHA_NUM_CHARS = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \" \", \"$\", \"%\", \"*\", \"+\", \"-\", \".\", \"/\", \":\"];\n  function AlphanumericData(data) {\n    this.mode = Mode.ALPHANUMERIC;\n    this.data = data;\n  }\n  AlphanumericData.getBitsLength = function getBitsLength(length) {\n    return 11 * Math.floor(length / 2) + 6 * (length % 2);\n  };\n  AlphanumericData.prototype.getLength = function getLength() {\n    return this.data.length;\n  };\n  AlphanumericData.prototype.getBitsLength = function getBitsLength() {\n    return AlphanumericData.getBitsLength(this.data.length);\n  };\n  AlphanumericData.prototype.write = function write(bitBuffer) {\n    let i;\n    for (i = 0; i + 2 <= this.data.length; i += 2) {\n      let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;\n      value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);\n      bitBuffer.put(value, 11);\n    }\n    if (this.data.length % 2) {\n      bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);\n    }\n  };\n  module.exports = AlphanumericData;\n});\n\n// node_modules/qrcode/lib/core/byte-data.js\nvar require_byte_data = __commonJS((exports, module) => {\n  var Mode = require_mode();\n  function ByteData(data) {\n    this.mode = Mode.BYTE;\n    if (typeof data === \"string\") {\n      this.data = new TextEncoder().encode(data);\n    } else {\n      this.data = new Uint8Array(data);\n    }\n  }\n  ByteData.getBitsLength = function getBitsLength(length) {\n    return length * 8;\n  };\n  ByteData.prototype.getLength = function getLength() {\n    return this.data.length;\n  };\n  ByteData.prototype.getBitsLength = function getBitsLength() {\n    return ByteData.getBitsLength(this.data.length);\n  };\n  ByteData.prototype.write = function (bitBuffer) {\n    for (let i = 0, l = this.data.length; i < l; i++) {\n      bitBuffer.put(this.data[i], 8);\n    }\n  };\n  module.exports = ByteData;\n});\n\n// node_modules/qrcode/lib/core/kanji-data.js\nvar require_kanji_data = __commonJS((exports, module) => {\n  var Mode = require_mode();\n  var Utils = require_utils();\n  function KanjiData(data) {\n    this.mode = Mode.KANJI;\n    this.data = data;\n  }\n  KanjiData.getBitsLength = function getBitsLength(length) {\n    return length * 13;\n  };\n  KanjiData.prototype.getLength = function getLength() {\n    return this.data.length;\n  };\n  KanjiData.prototype.getBitsLength = function getBitsLength() {\n    return KanjiData.getBitsLength(this.data.length);\n  };\n  KanjiData.prototype.write = function (bitBuffer) {\n    let i;\n    for (i = 0; i < this.data.length; i++) {\n      let value = Utils.toSJIS(this.data[i]);\n      if (value >= 33088 && value <= 40956) {\n        value -= 33088;\n      } else if (value >= 57408 && value <= 60351) {\n        value -= 49472;\n      } else {\n        throw new Error(\"Invalid SJIS character: \" + this.data[i] + \"\\n\" + \"Make sure your charset is UTF-8\");\n      }\n      value = (value >>> 8 & 255) * 192 + (value & 255);\n      bitBuffer.put(value, 13);\n    }\n  };\n  module.exports = KanjiData;\n});\n\n// node_modules/dijkstrajs/dijkstra.js\nvar require_dijkstra = __commonJS((exports, module) => {\n  var dijkstra = {\n    single_source_shortest_paths: function (graph, s, d) {\n      var predecessors = {};\n      var costs = {};\n      costs[s] = 0;\n      var open = dijkstra.PriorityQueue.make();\n      open.push(s, 0);\n      var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n      while (!open.empty()) {\n        closest = open.pop();\n        u = closest.value;\n        cost_of_s_to_u = closest.cost;\n        adjacent_nodes = graph[u] || {};\n        for (v in adjacent_nodes) {\n          if (adjacent_nodes.hasOwnProperty(v)) {\n            cost_of_e = adjacent_nodes[v];\n            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n            cost_of_s_to_v = costs[v];\n            first_visit = typeof costs[v] === \"undefined\";\n            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n              costs[v] = cost_of_s_to_u_plus_cost_of_e;\n              open.push(v, cost_of_s_to_u_plus_cost_of_e);\n              predecessors[v] = u;\n            }\n          }\n        }\n      }\n      if (typeof d !== \"undefined\" && typeof costs[d] === \"undefined\") {\n        var msg = [\"Could not find a path from \", s, \" to \", d, \".\"].join(\"\");\n        throw new Error(msg);\n      }\n      return predecessors;\n    },\n    extract_shortest_path_from_predecessor_list: function (predecessors, d) {\n      var nodes = [];\n      var u = d;\n      var predecessor;\n      while (u) {\n        nodes.push(u);\n        predecessor = predecessors[u];\n        u = predecessors[u];\n      }\n      nodes.reverse();\n      return nodes;\n    },\n    find_path: function (graph, s, d) {\n      var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n      return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n    },\n    PriorityQueue: {\n      make: function (opts) {\n        var T = dijkstra.PriorityQueue,\n          t = {},\n          key;\n        opts = opts || {};\n        for (key in T) {\n          if (T.hasOwnProperty(key)) {\n            t[key] = T[key];\n          }\n        }\n        t.queue = [];\n        t.sorter = opts.sorter || T.default_sorter;\n        return t;\n      },\n      default_sorter: function (a, b) {\n        return a.cost - b.cost;\n      },\n      push: function (value, cost) {\n        var item = {\n          value,\n          cost\n        };\n        this.queue.push(item);\n        this.queue.sort(this.sorter);\n      },\n      pop: function () {\n        return this.queue.shift();\n      },\n      empty: function () {\n        return this.queue.length === 0;\n      }\n    }\n  };\n  if (typeof module !== \"undefined\") {\n    module.exports = dijkstra;\n  }\n});\n\n// node_modules/qrcode/lib/core/segments.js\nvar require_segments = __commonJS(exports => {\n  var Mode = require_mode();\n  var NumericData = require_numeric_data();\n  var AlphanumericData = require_alphanumeric_data();\n  var ByteData = require_byte_data();\n  var KanjiData = require_kanji_data();\n  var Regex = require_regex();\n  var Utils = require_utils();\n  var dijkstra = require_dijkstra();\n  function getStringByteLength(str) {\n    return unescape(encodeURIComponent(str)).length;\n  }\n  function getSegments(regex, mode, str) {\n    const segments = [];\n    let result;\n    while ((result = regex.exec(str)) !== null) {\n      segments.push({\n        data: result[0],\n        index: result.index,\n        mode,\n        length: result[0].length\n      });\n    }\n    return segments;\n  }\n  function getSegmentsFromString(dataStr) {\n    const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);\n    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);\n    let byteSegs;\n    let kanjiSegs;\n    if (Utils.isKanjiModeEnabled()) {\n      byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);\n      kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);\n    } else {\n      byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);\n      kanjiSegs = [];\n    }\n    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n    return segs.sort(function (s1, s2) {\n      return s1.index - s2.index;\n    }).map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      };\n    });\n  }\n  function getSegmentBitsLength(length, mode) {\n    switch (mode) {\n      case Mode.NUMERIC:\n        return NumericData.getBitsLength(length);\n      case Mode.ALPHANUMERIC:\n        return AlphanumericData.getBitsLength(length);\n      case Mode.KANJI:\n        return KanjiData.getBitsLength(length);\n      case Mode.BYTE:\n        return ByteData.getBitsLength(length);\n    }\n  }\n  function mergeSegments(segs) {\n    return segs.reduce(function (acc, curr) {\n      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n      if (prevSeg && prevSeg.mode === curr.mode) {\n        acc[acc.length - 1].data += curr.data;\n        return acc;\n      }\n      acc.push(curr);\n      return acc;\n    }, []);\n  }\n  function buildNodes(segs) {\n    const nodes = [];\n    for (let i = 0; i < segs.length; i++) {\n      const seg = segs[i];\n      switch (seg.mode) {\n        case Mode.NUMERIC:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: Mode.ALPHANUMERIC,\n            length: seg.length\n          }, {\n            data: seg.data,\n            mode: Mode.BYTE,\n            length: seg.length\n          }]);\n          break;\n        case Mode.ALPHANUMERIC:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: Mode.BYTE,\n            length: seg.length\n          }]);\n          break;\n        case Mode.KANJI:\n          nodes.push([seg, {\n            data: seg.data,\n            mode: Mode.BYTE,\n            length: getStringByteLength(seg.data)\n          }]);\n          break;\n        case Mode.BYTE:\n          nodes.push([{\n            data: seg.data,\n            mode: Mode.BYTE,\n            length: getStringByteLength(seg.data)\n          }]);\n      }\n    }\n    return nodes;\n  }\n  function buildGraph(nodes, version) {\n    const table = {};\n    const graph = {\n      start: {}\n    };\n    let prevNodeIds = [\"start\"];\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeGroup = nodes[i];\n      const currentNodeIds = [];\n      for (let j = 0; j < nodeGroup.length; j++) {\n        const node = nodeGroup[j];\n        const key = \"\" + i + j;\n        currentNodeIds.push(key);\n        table[key] = {\n          node,\n          lastCount: 0\n        };\n        graph[key] = {};\n        for (let n = 0; n < prevNodeIds.length; n++) {\n          const prevNodeId = prevNodeIds[n];\n          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n            graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n            table[prevNodeId].lastCount += node.length;\n          } else {\n            if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;\n            graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);\n          }\n        }\n      }\n      prevNodeIds = currentNodeIds;\n    }\n    for (let n = 0; n < prevNodeIds.length; n++) {\n      graph[prevNodeIds[n]].end = 0;\n    }\n    return {\n      map: graph,\n      table\n    };\n  }\n  function buildSingleSegment(data, modesHint) {\n    let mode;\n    const bestMode = Mode.getBestModeForData(data);\n    mode = Mode.from(modesHint, bestMode);\n    if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n      throw new Error('\"' + data + '\"' + \" cannot be encoded with mode \" + Mode.toString(mode) + \".\\n Suggested mode is: \" + Mode.toString(bestMode));\n    }\n    if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n      mode = Mode.BYTE;\n    }\n    switch (mode) {\n      case Mode.NUMERIC:\n        return new NumericData(data);\n      case Mode.ALPHANUMERIC:\n        return new AlphanumericData(data);\n      case Mode.KANJI:\n        return new KanjiData(data);\n      case Mode.BYTE:\n        return new ByteData(data);\n    }\n  }\n  exports.fromArray = function fromArray(array) {\n    return array.reduce(function (acc, seg) {\n      if (typeof seg === \"string\") {\n        acc.push(buildSingleSegment(seg, null));\n      } else if (seg.data) {\n        acc.push(buildSingleSegment(seg.data, seg.mode));\n      }\n      return acc;\n    }, []);\n  };\n  exports.fromString = function fromString(data, version) {\n    const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());\n    const nodes = buildNodes(segs);\n    const graph = buildGraph(nodes, version);\n    const path = dijkstra.find_path(graph.map, \"start\", \"end\");\n    const optimizedSegs = [];\n    for (let i = 1; i < path.length - 1; i++) {\n      optimizedSegs.push(graph.table[path[i]].node);\n    }\n    return exports.fromArray(mergeSegments(optimizedSegs));\n  };\n  exports.rawSplit = function rawSplit(data) {\n    return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));\n  };\n});\n\n// node_modules/qrcode/lib/core/qrcode.js\nvar require_qrcode = __commonJS(exports => {\n  var Utils = require_utils();\n  var ECLevel = require_error_correction_level();\n  var BitBuffer = require_bit_buffer();\n  var BitMatrix = require_bit_matrix();\n  var AlignmentPattern = require_alignment_pattern();\n  var FinderPattern = require_finder_pattern();\n  var MaskPattern = require_mask_pattern();\n  var ECCode = require_error_correction_code();\n  var ReedSolomonEncoder = require_reed_solomon_encoder();\n  var Version = require_version();\n  var FormatInfo = require_format_info();\n  var Mode = require_mode();\n  var Segments = require_segments();\n  function setupFinderPattern(matrix, version) {\n    const size = matrix.size;\n    const pos = FinderPattern.getPositions(version);\n    for (let i = 0; i < pos.length; i++) {\n      const row = pos[i][0];\n      const col = pos[i][1];\n      for (let r = -1; r <= 7; r++) {\n        if (row + r <= -1 || size <= row + r) continue;\n        for (let c = -1; c <= 7; c++) {\n          if (col + c <= -1 || size <= col + c) continue;\n          if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {\n            matrix.set(row + r, col + c, true, true);\n          } else {\n            matrix.set(row + r, col + c, false, true);\n          }\n        }\n      }\n    }\n  }\n  function setupTimingPattern(matrix) {\n    const size = matrix.size;\n    for (let r = 8; r < size - 8; r++) {\n      const value = r % 2 === 0;\n      matrix.set(r, 6, value, true);\n      matrix.set(6, r, value, true);\n    }\n  }\n  function setupAlignmentPattern(matrix, version) {\n    const pos = AlignmentPattern.getPositions(version);\n    for (let i = 0; i < pos.length; i++) {\n      const row = pos[i][0];\n      const col = pos[i][1];\n      for (let r = -2; r <= 2; r++) {\n        for (let c = -2; c <= 2; c++) {\n          if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {\n            matrix.set(row + r, col + c, true, true);\n          } else {\n            matrix.set(row + r, col + c, false, true);\n          }\n        }\n      }\n    }\n  }\n  function setupVersionInfo(matrix, version) {\n    const size = matrix.size;\n    const bits = Version.getEncodedBits(version);\n    let row, col, mod;\n    for (let i = 0; i < 18; i++) {\n      row = Math.floor(i / 3);\n      col = i % 3 + size - 8 - 3;\n      mod = (bits >> i & 1) === 1;\n      matrix.set(row, col, mod, true);\n      matrix.set(col, row, mod, true);\n    }\n  }\n  function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {\n    const size = matrix.size;\n    const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);\n    let i, mod;\n    for (i = 0; i < 15; i++) {\n      mod = (bits >> i & 1) === 1;\n      if (i < 6) {\n        matrix.set(i, 8, mod, true);\n      } else if (i < 8) {\n        matrix.set(i + 1, 8, mod, true);\n      } else {\n        matrix.set(size - 15 + i, 8, mod, true);\n      }\n      if (i < 8) {\n        matrix.set(8, size - i - 1, mod, true);\n      } else if (i < 9) {\n        matrix.set(8, 15 - i - 1 + 1, mod, true);\n      } else {\n        matrix.set(8, 15 - i - 1, mod, true);\n      }\n    }\n    matrix.set(size - 8, 8, 1, true);\n  }\n  function setupData(matrix, data) {\n    const size = matrix.size;\n    let inc = -1;\n    let row = size - 1;\n    let bitIndex = 7;\n    let byteIndex = 0;\n    for (let col = size - 1; col > 0; col -= 2) {\n      if (col === 6) col--;\n      while (true) {\n        for (let c = 0; c < 2; c++) {\n          if (!matrix.isReserved(row, col - c)) {\n            let dark = false;\n            if (byteIndex < data.length) {\n              dark = (data[byteIndex] >>> bitIndex & 1) === 1;\n            }\n            matrix.set(row, col - c, dark);\n            bitIndex--;\n            if (bitIndex === -1) {\n              byteIndex++;\n              bitIndex = 7;\n            }\n          }\n        }\n        row += inc;\n        if (row < 0 || size <= row) {\n          row -= inc;\n          inc = -inc;\n          break;\n        }\n      }\n    }\n  }\n  function createData(version, errorCorrectionLevel, segments) {\n    const buffer = new BitBuffer();\n    segments.forEach(function (data) {\n      buffer.put(data.mode.bit, 4);\n      buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));\n      data.write(buffer);\n    });\n    const totalCodewords = Utils.getSymbolTotalCodewords(version);\n    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;\n    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n      buffer.put(0, 4);\n    }\n    while (buffer.getLengthInBits() % 8 !== 0) {\n      buffer.putBit(0);\n    }\n    const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;\n    for (let i = 0; i < remainingByte; i++) {\n      buffer.put(i % 2 ? 17 : 236, 8);\n    }\n    return createCodewords(buffer, version, errorCorrectionLevel);\n  }\n  function createCodewords(bitBuffer, version, errorCorrectionLevel) {\n    const totalCodewords = Utils.getSymbolTotalCodewords(version);\n    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);\n    const dataTotalCodewords = totalCodewords - ecTotalCodewords;\n    const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);\n    const blocksInGroup2 = totalCodewords % ecTotalBlocks;\n    const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;\n    const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);\n    const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);\n    const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;\n    const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;\n    const rs = new ReedSolomonEncoder(ecCount);\n    let offset = 0;\n    const dcData = new Array(ecTotalBlocks);\n    const ecData = new Array(ecTotalBlocks);\n    let maxDataSize = 0;\n    const buffer = new Uint8Array(bitBuffer.buffer);\n    for (let b = 0; b < ecTotalBlocks; b++) {\n      const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;\n      dcData[b] = buffer.slice(offset, offset + dataSize);\n      ecData[b] = rs.encode(dcData[b]);\n      offset += dataSize;\n      maxDataSize = Math.max(maxDataSize, dataSize);\n    }\n    const data = new Uint8Array(totalCodewords);\n    let index = 0;\n    let i, r;\n    for (i = 0; i < maxDataSize; i++) {\n      for (r = 0; r < ecTotalBlocks; r++) {\n        if (i < dcData[r].length) {\n          data[index++] = dcData[r][i];\n        }\n      }\n    }\n    for (i = 0; i < ecCount; i++) {\n      for (r = 0; r < ecTotalBlocks; r++) {\n        data[index++] = ecData[r][i];\n      }\n    }\n    return data;\n  }\n  function createSymbol(data, version, errorCorrectionLevel, maskPattern) {\n    let segments;\n    if (Array.isArray(data)) {\n      segments = Segments.fromArray(data);\n    } else if (typeof data === \"string\") {\n      let estimatedVersion = version;\n      if (!estimatedVersion) {\n        const rawSegments = Segments.rawSplit(data);\n        estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);\n      }\n      segments = Segments.fromString(data, estimatedVersion || 40);\n    } else {\n      throw new Error(\"Invalid data\");\n    }\n    const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);\n    if (!bestVersion) {\n      throw new Error(\"The amount of data is too big to be stored in a QR Code\");\n    }\n    if (!version) {\n      version = bestVersion;\n    } else if (version < bestVersion) {\n      throw new Error(\"\\n\" + \"The chosen QR Code version cannot contain this amount of data.\\n\" + \"Minimum version required to store current data is: \" + bestVersion + \".\\n\");\n    }\n    const dataBits = createData(version, errorCorrectionLevel, segments);\n    const moduleCount = Utils.getSymbolSize(version);\n    const modules = new BitMatrix(moduleCount);\n    setupFinderPattern(modules, version);\n    setupTimingPattern(modules);\n    setupAlignmentPattern(modules, version);\n    setupFormatInfo(modules, errorCorrectionLevel, 0);\n    if (version >= 7) {\n      setupVersionInfo(modules, version);\n    }\n    setupData(modules, dataBits);\n    if (isNaN(maskPattern)) {\n      maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));\n    }\n    MaskPattern.applyMask(maskPattern, modules);\n    setupFormatInfo(modules, errorCorrectionLevel, maskPattern);\n    return {\n      modules,\n      version,\n      errorCorrectionLevel,\n      maskPattern,\n      segments\n    };\n  }\n  exports.create = function create(data, options) {\n    if (typeof data === \"undefined\" || data === \"\") {\n      throw new Error(\"No input text\");\n    }\n    let errorCorrectionLevel = ECLevel.M;\n    let version;\n    let mask;\n    if (typeof options !== \"undefined\") {\n      errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);\n      version = Version.from(options.version);\n      mask = MaskPattern.from(options.maskPattern);\n      if (options.toSJISFunc) {\n        Utils.setToSJISFunction(options.toSJISFunc);\n      }\n    }\n    return createSymbol(data, version, errorCorrectionLevel, mask);\n  };\n});\n\n// node_modules/qrcode/lib/renderer/utils.js\nvar require_utils2 = __commonJS(exports => {\n  function hex2rgba(hex) {\n    if (typeof hex === \"number\") {\n      hex = hex.toString();\n    }\n    if (typeof hex !== \"string\") {\n      throw new Error(\"Color should be defined as hex string\");\n    }\n    let hexCode = hex.slice().replace(\"#\", \"\").split(\"\");\n    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n      throw new Error(\"Invalid hex color: \" + hex);\n    }\n    if (hexCode.length === 3 || hexCode.length === 4) {\n      hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n        return [c, c];\n      }));\n    }\n    if (hexCode.length === 6) hexCode.push(\"F\", \"F\");\n    const hexValue = parseInt(hexCode.join(\"\"), 16);\n    return {\n      r: hexValue >> 24 & 255,\n      g: hexValue >> 16 & 255,\n      b: hexValue >> 8 & 255,\n      a: hexValue & 255,\n      hex: \"#\" + hexCode.slice(0, 6).join(\"\")\n    };\n  }\n  exports.getOptions = function getOptions(options) {\n    if (!options) options = {};\n    if (!options.color) options.color = {};\n    const margin = typeof options.margin === \"undefined\" || options.margin === null || options.margin < 0 ? 4 : options.margin;\n    const width = options.width && options.width >= 21 ? options.width : undefined;\n    const scale = options.scale || 4;\n    return {\n      width,\n      scale: width ? 4 : scale,\n      margin,\n      color: {\n        dark: hex2rgba(options.color.dark || \"#000000ff\"),\n        light: hex2rgba(options.color.light || \"#ffffffff\")\n      },\n      type: options.type,\n      rendererOpts: options.rendererOpts || {}\n    };\n  };\n  exports.getScale = function getScale(qrSize, opts) {\n    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;\n  };\n  exports.getImageWidth = function getImageWidth(qrSize, opts) {\n    const scale = exports.getScale(qrSize, opts);\n    return Math.floor((qrSize + opts.margin * 2) * scale);\n  };\n  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {\n    const size = qr.modules.size;\n    const data = qr.modules.data;\n    const scale = exports.getScale(size, opts);\n    const symbolSize = Math.floor((size + opts.margin * 2) * scale);\n    const scaledMargin = opts.margin * scale;\n    const palette = [opts.color.light, opts.color.dark];\n    for (let i = 0; i < symbolSize; i++) {\n      for (let j = 0; j < symbolSize; j++) {\n        let posDst = (i * symbolSize + j) * 4;\n        let pxColor = opts.color.light;\n        if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n          const iSrc = Math.floor((i - scaledMargin) / scale);\n          const jSrc = Math.floor((j - scaledMargin) / scale);\n          pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];\n        }\n        imgData[posDst++] = pxColor.r;\n        imgData[posDst++] = pxColor.g;\n        imgData[posDst++] = pxColor.b;\n        imgData[posDst] = pxColor.a;\n      }\n    }\n  };\n});\n\n// node_modules/qrcode/lib/renderer/canvas.js\nvar require_canvas = __commonJS(exports => {\n  var Utils = require_utils2();\n  function clearCanvas(ctx, canvas, size) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    if (!canvas.style) canvas.style = {};\n    canvas.height = size;\n    canvas.width = size;\n    canvas.style.height = size + \"px\";\n    canvas.style.width = size + \"px\";\n  }\n  function getCanvasElement() {\n    try {\n      return document.createElement(\"canvas\");\n    } catch (e) {\n      throw new Error(\"You need to specify a canvas element\");\n    }\n  }\n  exports.render = function render(qrData, canvas, options) {\n    let opts = options;\n    let canvasEl = canvas;\n    if (typeof opts === \"undefined\" && (!canvas || !canvas.getContext)) {\n      opts = canvas;\n      canvas = undefined;\n    }\n    if (!canvas) {\n      canvasEl = getCanvasElement();\n    }\n    opts = Utils.getOptions(opts);\n    const size = Utils.getImageWidth(qrData.modules.size, opts);\n    const ctx = canvasEl.getContext(\"2d\");\n    const image = ctx.createImageData(size, size);\n    Utils.qrToImageData(image.data, qrData, opts);\n    clearCanvas(ctx, canvasEl, size);\n    ctx.putImageData(image, 0, 0);\n    return canvasEl;\n  };\n  exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {\n    let opts = options;\n    if (typeof opts === \"undefined\" && (!canvas || !canvas.getContext)) {\n      opts = canvas;\n      canvas = undefined;\n    }\n    if (!opts) opts = {};\n    const canvasEl = exports.render(qrData, canvas, opts);\n    const type = opts.type || \"image/png\";\n    const rendererOpts = opts.rendererOpts || {};\n    return canvasEl.toDataURL(type, rendererOpts.quality);\n  };\n});\n\n// node_modules/qrcode/lib/renderer/svg-tag.js\nvar require_svg_tag = __commonJS(exports => {\n  var Utils = require_utils2();\n  function getColorAttrib(color, attrib) {\n    const alpha = color.a / 255;\n    const str = attrib + '=\"' + color.hex + '\"';\n    return alpha < 1 ? str + \" \" + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"' : str;\n  }\n  function svgCmd(cmd, x, y) {\n    let str = cmd + x;\n    if (typeof y !== \"undefined\") str += \" \" + y;\n    return str;\n  }\n  function qrToPath(data, size, margin) {\n    let path = \"\";\n    let moveBy = 0;\n    let newRow = false;\n    let lineLength = 0;\n    for (let i = 0; i < data.length; i++) {\n      const col = Math.floor(i % size);\n      const row = Math.floor(i / size);\n      if (!col && !newRow) newRow = true;\n      if (data[i]) {\n        lineLength++;\n        if (!(i > 0 && col > 0 && data[i - 1])) {\n          path += newRow ? svgCmd(\"M\", col + margin, 0.5 + row + margin) : svgCmd(\"m\", moveBy, 0);\n          moveBy = 0;\n          newRow = false;\n        }\n        if (!(col + 1 < size && data[i + 1])) {\n          path += svgCmd(\"h\", lineLength);\n          lineLength = 0;\n        }\n      } else {\n        moveBy++;\n      }\n    }\n    return path;\n  }\n  exports.render = function render(qrData, options, cb) {\n    const opts = Utils.getOptions(options);\n    const size = qrData.modules.size;\n    const data = qrData.modules.data;\n    const qrcodesize = size + opts.margin * 2;\n    const bg = !opts.color.light.a ? \"\" : \"<path \" + getColorAttrib(opts.color.light, \"fill\") + ' d=\"M0 0h' + qrcodesize + \"v\" + qrcodesize + 'H0z\"/>';\n    const path = \"<path \" + getColorAttrib(opts.color.dark, \"stroke\") + ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>';\n    const viewBox = 'viewBox=\"' + \"0 0 \" + qrcodesize + \" \" + qrcodesize + '\"';\n    const width = !opts.width ? \"\" : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" ';\n    const svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + \"</svg>\\n\";\n    if (typeof cb === \"function\") {\n      cb(null, svgTag);\n    }\n    return svgTag;\n  };\n});\n\n// node_modules/qrcode/lib/browser.js\nvar require_browser = __commonJS(exports => {\n  var canPromise = require_can_promise();\n  var QRCode = require_qrcode();\n  var CanvasRenderer = require_canvas();\n  var SvgRenderer = require_svg_tag();\n  function renderCanvas(renderFunc, canvas, text, opts, cb) {\n    const args = [].slice.call(arguments, 1);\n    const argsNum = args.length;\n    const isLastArgCb = typeof args[argsNum - 1] === \"function\";\n    if (!isLastArgCb && !canPromise()) {\n      throw new Error(\"Callback required as last argument\");\n    }\n    if (isLastArgCb) {\n      if (argsNum < 2) {\n        throw new Error(\"Too few arguments provided\");\n      }\n      if (argsNum === 2) {\n        cb = text;\n        text = canvas;\n        canvas = opts = undefined;\n      } else if (argsNum === 3) {\n        if (canvas.getContext && typeof cb === \"undefined\") {\n          cb = opts;\n          opts = undefined;\n        } else {\n          cb = opts;\n          opts = text;\n          text = canvas;\n          canvas = undefined;\n        }\n      }\n    } else {\n      if (argsNum < 1) {\n        throw new Error(\"Too few arguments provided\");\n      }\n      if (argsNum === 1) {\n        text = canvas;\n        canvas = opts = undefined;\n      } else if (argsNum === 2 && !canvas.getContext) {\n        opts = text;\n        text = canvas;\n        canvas = undefined;\n      }\n      return new Promise(function (resolve, reject) {\n        try {\n          const data = QRCode.create(text, opts);\n          resolve(renderFunc(data, canvas, opts));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    }\n    try {\n      const data = QRCode.create(text, opts);\n      cb(null, renderFunc(data, canvas, opts));\n    } catch (e) {\n      cb(e);\n    }\n  }\n  exports.create = QRCode.create;\n  exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);\n  exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);\n  exports.toString = renderCanvas.bind(null, function (data, _, opts) {\n    return SvgRenderer.render(data, opts);\n  });\n});\n\n// src/index.ts\nvar import_qrcode = __toESM(require_browser(), 1);\n\n// src/types.ts\nvar MessageType;\n(MessageType2 => {\n  MessageType2[\"HANDSHAKE_ACCEPT\"] = \"handshake_accept\";\n  MessageType2[\"HANDSHAKE_REJECT\"] = \"handshake_reject\";\n  MessageType2[\"RUN_TRANSACTION\"] = \"run_transaction\";\n  MessageType2[\"RUN_TRANSACTION_RESPONSE\"] = \"run_transaction_response\";\n  MessageType2[\"SIGN_RAW_MESSAGE\"] = \"sign_raw_message\";\n  MessageType2[\"SIGN_RAW_MESSAGE_RESPONSE\"] = \"sign_raw_message_response\";\n  MessageType2[\"REJECT_REQUEST\"] = \"reject_request\";\n})(MessageType || (MessageType = {}));\n\n// src/connection.ts\nclass Connection {\n  constructor(_ref) {\n    let {\n      network,\n      walletUrl,\n      apiUrl\n    } = _ref;\n    _defineProperty(this, \"walletUrl\", \"https://cantonloop.com\");\n    _defineProperty(this, \"apiUrl\", \"https://cantonloop.com\");\n    _defineProperty(this, \"ws\", null);\n    _defineProperty(this, \"network\", \"main\");\n    this.network = network || \"main\";\n    switch (this.network) {\n      case \"local\":\n        this.walletUrl = \"http://localhost:3000\";\n        this.apiUrl = \"http://localhost:8080\";\n        break;\n      case \"devnet\":\n      case \"dev\":\n        this.walletUrl = \"https://devnet.cantonloop.com\";\n        this.apiUrl = \"https://devnet.cantonloop.com\";\n        break;\n      case \"testnet\":\n      case \"test\":\n        this.walletUrl = \"https://testnet.cantonloop.com\";\n        this.apiUrl = \"https://testnet.cantonloop.com\";\n        break;\n      case \"mainnet\":\n      case \"main\":\n        this.walletUrl = \"https://cantonloop.com\";\n        this.apiUrl = \"https://cantonloop.com\";\n        break;\n    }\n    if (walletUrl) {\n      this.walletUrl = walletUrl;\n    }\n    if (apiUrl) {\n      this.apiUrl = apiUrl;\n    }\n  }\n  async getTicket(appName, sessionId, version) {\n    const response = await fetch(\"\".concat(this.apiUrl, \"/api/v1/.connect/pair/tickets\"), {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        app_name: appName,\n        session_id: sessionId,\n        version\n      })\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to get ticket from server.\");\n    }\n    return response.json();\n  }\n  async getHolding(authToken) {\n    const response = await fetch(\"\".concat(this.apiUrl, \"/api/v1/.connect/pair/account/holding\"), {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(authToken)\n      }\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to get holdings.\");\n    }\n    return response.json();\n  }\n  async getActiveContracts(authToken, params) {\n    const url = new URL(\"\".concat(this.apiUrl, \"/api/v1/.connect/pair/account/active-contracts\"));\n    if (params !== null && params !== void 0 && params.templateId) {\n      url.searchParams.append(\"templateId\", params.templateId);\n    }\n    if (params !== null && params !== void 0 && params.interfaceId) {\n      url.searchParams.append(\"interfaceId\", params.interfaceId);\n    }\n    const response = await fetch(url.toString(), {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(authToken)\n      }\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to get active contracts.\");\n    }\n    return response.json();\n  }\n  async verifySession(authToken) {\n    const response = await fetch(\"\".concat(this.apiUrl, \"/api/v1/.connect/pair/account\"), {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer \".concat(authToken)\n      }\n    });\n    if (!response.ok) {\n      throw new Error(\"Session verification failed.\");\n    }\n    const data = await response.json();\n    if (!(data !== null && data !== void 0 && data.party_id) || !(data !== null && data !== void 0 && data.public_key)) {\n      throw new Error(\"Invalid session verification response.\");\n    }\n    const account = {\n      party_id: data === null || data === void 0 ? void 0 : data.party_id,\n      auth_token: authToken,\n      public_key: data === null || data === void 0 ? void 0 : data.public_key\n    };\n    return account;\n  }\n  websocketUrl(ticketId) {\n    return \"\".concat(this.network === \"local\" ? \"ws\" : \"wss\", \"://\").concat(this.apiUrl.replace(\"https://\", \"\").replace(\"http://\", \"\"), \"/api/v1/.connect/pair/ws/\").concat(ticketId);\n  }\n  connectWebSocket(ticketId, onMessage) {\n    const wsUrl = this.websocketUrl(ticketId);\n    this.ws = new WebSocket(wsUrl);\n    this.ws.onmessage = onMessage;\n    this.ws.onopen = () => {\n      console.log(\"Connected to ticket server.\");\n    };\n    this.ws.onclose = () => {\n      console.log(\"Disconnected from ticket server.\");\n    };\n  }\n}\n\n// src/errors.ts\nclass RequestTimeoutError extends Error {\n  constructor(timeout) {\n    super(\"Request timed out after \".concat(timeout, \"ms.\"));\n  }\n}\nclass RejectRequestError extends Error {\n  constructor() {\n    super(\"Request was rejected by the wallet.\");\n  }\n}\n\n// src/provider.ts\nfunction generateRequestId() {\n  return crypto.randomUUID();\n}\nclass Provider {\n  constructor(_ref2) {\n    let {\n      connection,\n      party_id,\n      public_key,\n      auth_token,\n      requestTimeout\n    } = _ref2;\n    _defineProperty(this, \"connection\", void 0);\n    _defineProperty(this, \"party_id\", void 0);\n    _defineProperty(this, \"public_key\", void 0);\n    _defineProperty(this, \"auth_token\", void 0);\n    _defineProperty(this, \"requests\", new Map());\n    _defineProperty(this, \"requestTimeout\", 30000);\n    if (!connection) {\n      throw new Error(\"Provider requires a connection object.\");\n    }\n    this.connection = connection;\n    this.party_id = party_id;\n    this.public_key = public_key;\n    this.auth_token = auth_token;\n    this.requestTimeout = requestTimeout || 30000;\n  }\n  handleResponse(message) {\n    console.log(\"Received response:\", message);\n    if (message.request_id) {\n      this.requests.set(message.request_id, message);\n    }\n  }\n  async getHolding() {\n    return this.connection.getHolding(this.auth_token);\n  }\n  async getActiveContracts(params) {\n    return this.connection.getActiveContracts(this.auth_token, params);\n  }\n  async submitTransaction(payload) {\n    return this.sendRequest(\"run_transaction\" /* RUN_TRANSACTION */, payload);\n  }\n  async signMessage(message) {\n    return this.sendRequest(\"sign_raw_message\" /* SIGN_RAW_MESSAGE */, message);\n  }\n  sendRequest(messageType) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      if (!this.connection.ws || this.connection.ws.readyState !== WebSocket.OPEN) {\n        return reject(new Error(\"Not connected.\"));\n      }\n      const requestId = generateRequestId();\n      this.connection.ws.send(JSON.stringify({\n        request_id: requestId,\n        type: messageType,\n        payload: params\n      }));\n      const intervalTime = 300;\n      let elapsedTime = 0;\n      const intervalId = setInterval(() => {\n        const response = this.requests.get(requestId);\n        if (response) {\n          clearInterval(intervalId);\n          this.requests.delete(requestId);\n          if (response.type === \"reject_request\" /* REJECT_REQUEST */) {\n            reject(new RejectRequestError());\n          } else {\n            resolve(response.payload);\n          }\n        } else {\n          elapsedTime += intervalTime;\n          if (elapsedTime >= this.requestTimeout) {\n            clearInterval(intervalId);\n            this.requests.delete(requestId);\n            reject(new RequestTimeoutError(this.requestTimeout));\n          }\n        }\n      }, intervalTime);\n    });\n  }\n}\n\n// src/index.ts\nclass LoopSDK {\n  constructor() {\n    _defineProperty(this, \"version\", \"0.0.1\");\n    _defineProperty(this, \"appName\", \"Unknown\");\n    _defineProperty(this, \"connection\", null);\n    _defineProperty(this, \"provider\", null);\n    _defineProperty(this, \"onAccept\", null);\n    _defineProperty(this, \"onReject\", null);\n    _defineProperty(this, \"overlay\", null);\n    _defineProperty(this, \"ticketId\", null);\n  }\n  init(_ref3) {\n    let {\n      appName,\n      network,\n      walletUrl,\n      apiUrl,\n      onAccept,\n      onReject\n    } = _ref3;\n    this.appName = appName;\n    this.onAccept = onAccept || null;\n    this.onReject = onReject || null;\n    this.connection = new Connection({\n      network,\n      walletUrl,\n      apiUrl\n    });\n  }\n  async connect() {\n    if (typeof window === \"undefined\") {\n      console.warn(\"LoopSDK.connect() can only be called in a browser environment.\");\n      return;\n    }\n    if (!this.connection) {\n      throw new Error(\"SDK not initialized. Call init() first.\");\n    }\n    const existingConnectionRaw = localStorage.getItem(\"loop_connect\");\n    if (existingConnectionRaw) {\n      try {\n        const {\n          ticketId,\n          authToken,\n          partyId,\n          publicKey\n        } = JSON.parse(existingConnectionRaw);\n        if (authToken && partyId && publicKey) {\n          try {\n            const verifiedAccount = await this.connection.verifySession(authToken);\n            if (verifiedAccount.party_id === partyId) {\n              var _this$onAccept;\n              this.provider = new Provider({\n                connection: this.connection,\n                party_id: partyId,\n                auth_token: authToken,\n                public_key: publicKey\n              });\n              (_this$onAccept = this.onAccept) === null || _this$onAccept === void 0 || _this$onAccept.call(this, this.provider);\n              if (ticketId) {\n                this.connection.connectWebSocket(ticketId, this.handleWebSocketMessage.bind(this));\n              }\n              return;\n            }\n          } catch (err) {\n            console.error(\"Auto-login failed, token is invalid. Starting new connection.\", err);\n          }\n        }\n        if (ticketId) {\n          this.ticketId = ticketId;\n          const connectUrl = \"\".concat(this.connection.walletUrl, \"/.connect/?ticketId=\").concat(ticketId);\n          this.showQrCode(connectUrl);\n          this.connection.connectWebSocket(ticketId, this.handleWebSocketMessage.bind(this));\n          return;\n        }\n      } catch (error) {\n        console.error(\"Failed to parse existing connection info, creating a new one.\", error);\n      }\n      localStorage.removeItem(\"loop_connect\");\n    }\n    const sessionId = generateRequestId();\n    try {\n      const {\n        ticket_id: ticketId\n      } = await this.connection.getTicket(this.appName, sessionId, this.version);\n      this.ticketId = ticketId;\n      localStorage.setItem(\"loop_connect\", JSON.stringify({\n        sessionId,\n        ticketId\n      }));\n      const connectUrl = \"\".concat(this.connection.walletUrl, \"/.connect/?ticketId=\").concat(ticketId);\n      this.showQrCode(connectUrl);\n      this.connection.connectWebSocket(ticketId, this.handleWebSocketMessage.bind(this));\n    } catch (error) {\n      console.error(error);\n      return;\n    }\n  }\n  handleWebSocketMessage(event) {\n    const message = JSON.parse(event.data);\n    if (message.type === \"handshake_accept\" /* HANDSHAKE_ACCEPT */) {\n      const {\n        authToken,\n        partyId,\n        publicKey\n      } = message.payload || {};\n      if (authToken && partyId && publicKey) {\n        this.provider = new Provider({\n          connection: this.connection,\n          party_id: partyId,\n          auth_token: authToken,\n          public_key: publicKey\n        });\n        const connectionInfoRaw = localStorage.getItem(\"loop_connect\");\n        if (connectionInfoRaw) {\n          try {\n            var _this$onAccept2, _this$connection;\n            const connectionInfo = JSON.parse(connectionInfoRaw);\n            connectionInfo.authToken = authToken;\n            connectionInfo.partyId = partyId;\n            connectionInfo.publicKey = publicKey;\n            localStorage.setItem(\"loop_connect\", JSON.stringify(connectionInfo));\n            (_this$onAccept2 = this.onAccept) === null || _this$onAccept2 === void 0 || _this$onAccept2.call(this, this.provider);\n            this.hideQrCode();\n            (_this$connection = this.connection) === null || _this$connection === void 0 || _this$connection.connectWebSocket(connectionInfo.ticketId, this.handleWebSocketMessage.bind(this));\n          } catch (error) {\n            console.error(\"Failed to update local storage with auth token.\", error);\n          }\n        }\n      }\n    } else if (message.type === \"handshake_reject\" /* HANDSHAKE_REJECT */) {\n      var _this$connection2, _this$onReject;\n      localStorage.removeItem(\"loop_connect\");\n      (_this$connection2 = this.connection) === null || _this$connection2 === void 0 || (_this$connection2 = _this$connection2.ws) === null || _this$connection2 === void 0 || _this$connection2.close();\n      (_this$onReject = this.onReject) === null || _this$onReject === void 0 || _this$onReject.call(this);\n      this.hideQrCode();\n    } else if (this.provider) {\n      this.provider.handleResponse(message);\n    }\n  }\n  showQrCode(url) {\n    if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n      return;\n    }\n    import_qrcode.default.toDataURL(url, (err, dataUrl) => {\n      if (err) {\n        console.error(\"Failed to generate QR code\", err);\n        return;\n      }\n      const overlay = document.createElement(\"div\");\n      overlay.style.position = \"fixed\";\n      overlay.style.top = \"0\";\n      overlay.style.left = \"0\";\n      overlay.style.width = \"100%\";\n      overlay.style.height = \"100%\";\n      overlay.style.backgroundColor = \"rgba(0,0,0,0.5)\";\n      overlay.style.display = \"flex\";\n      overlay.style.justifyContent = \"center\";\n      overlay.style.alignItems = \"center\";\n      overlay.style.zIndex = \"1000\";\n      overlay.style.flexDirection = \"column\";\n      const img = document.createElement(\"img\");\n      img.src = dataUrl;\n      overlay.appendChild(img);\n      const link = document.createElement(\"a\");\n      link.href = url;\n      link.textContent = \"Or click here to connect\";\n      link.style.color = \"white\";\n      link.style.marginTop = \"20px\";\n      link.target = \"_blank\";\n      overlay.appendChild(link);\n      overlay.onclick = e => {\n        if (e.target === overlay) {\n          this.hideQrCode();\n        }\n      };\n      document.body.appendChild(overlay);\n      this.overlay = overlay;\n    });\n  }\n  hideQrCode() {\n    if (this.overlay && this.overlay.parentElement) {\n      this.overlay.parentElement.removeChild(this.overlay);\n      this.overlay = null;\n    }\n  }\n}\nvar loop = new LoopSDK();\nexport { loop, MessageType };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}