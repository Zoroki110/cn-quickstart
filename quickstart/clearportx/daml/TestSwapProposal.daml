module TestSwapProposal where

import Daml.Script
import AMM.Pool
import AMM.SwapRequest
import Token.Token
import DA.Time (seconds, addRelTime)

-- Test du swap avec le pattern Proposal-Accept
testSwapWithProposal : Script ()
testSwapWithProposal = script do
  -- Setup parties
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerUSDC <- allocateParty "IssuerUSDC"
  issuerETH <- allocateParty "IssuerETH"
  alice <- allocateParty "Alice"

  -- Créer pool (ETH-USDC)
  pool <- submit poolOperator $ createCmd Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30  -- 0.3% fee
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 0.0  -- No LP tracking in legacy tests
    reserveA = 10.0      -- 10 ETH
    reserveB = 20000.0   -- 20,000 USDC
    protocolFeeReceiver = clearportx
    tokenACid = None
    tokenBCid = None
    maxInBps = 10000
    maxOutBps = 5000

  -- Créer tokens de liquidité pour le pool
  -- Token a signatory issuer, donc submit issuer
  poolETH <- submit issuerETH $ createCmd Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 10.0

  poolUSDC <- submit issuerUSDC $ createCmd Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 20000.0

  -- Update pool to link the tokens
  updatedPool <- submit poolParty $ exerciseCmd pool ArchiveAndUpdateReserves with
    updatedReserveA = 10.0
    updatedReserveB = 20000.0
    updatedTokenACid = Some poolETH
    updatedTokenBCid = Some poolUSDC

  -- Token pour Alice (100 USDC)
  -- Issuer creates token for Alice
  aliceUSDC <- submit issuerUSDC $ createCmd Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 100.0

  debug "Initial setup complete: Pool has 10 ETH and 20000 USDC, Alice has 100 USDC"

  now <- getTime
  let deadline = addRelTime now (seconds 60)

  -- TX 1: Alice crée une SwapRequest
  swapRequest <- submit alice $ createCmd SwapRequest with
    trader = alice
    poolCid = updatedPool
    poolParty = poolParty
    poolOperator = poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = seconds 120
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 100.0
    outputSymbol = "ETH"
    minOutput = 0.0  -- Pas de slippage protection pour le test
    deadline = deadline
    maxPriceImpactBps = 5000  -- Accepter jusqu'à 100% de price impact

  debug "TX 1 complete: SwapRequest created"

  -- TX 2: Alice prépare le swap (transfert USDC au pool)
  -- submit alice ONLY because PrepareSwap has controller trader
  -- poolParty just receives the tokens
  (swapReady, _) <- submit alice $
    exerciseCmd swapRequest PrepareSwap with protocolFeeReceiver = clearportx

  debug "TX 2 complete: Alice transferred 100 USDC to pool, SwapReady created"

  -- TX 3: Pool exécute le swap (transfert ETH à Alice)
  -- submit poolParty ONLY because ExecuteSwap has controller poolParty
  -- alice just receives the ETH tokens
  receiptCid <- submit poolParty $
    exerciseCmd swapReady ExecuteSwap

  debug "TX 3 complete: Pool transferred ETH to Alice"

  -- Vérifier le résultat
  Some receipt <- queryContractId alice receiptCid
  ethToken <- queryContractId alice receipt.outputTokenCid
  case ethToken of
    None -> assertFail "ETH token not found"
    Some token -> do
      debug $ "✅ Swap successful! Alice received " <> show token.amount <> " ETH"

      -- Vérifier la formule x*y=k
      -- rA = 10, rB = 20000, amountIn = 100, fee = 0.3%
      -- amountInFee = 100 * 0.997 = 99.7
      -- amountOut = (99.7 * 20000) / (10 + 99.7) = 1994000 / 10099.7 ≈ 0.0497...
      -- Mais attendez, les symboles sont inversés !
      -- Input = USDC (symbolB), Output = ETH (symbolA)
      -- Donc : rin = rB = 20000, rout = rA = 10
      -- amountOut = (99.7 * 10) / (20000 + 99.7) = 997 / 20099.7 ≈ 0.0496...

      assert (token.amount > 0.04 && token.amount < 0.05)
      debug $ "✅ Amount is correct (expected ~0.0496 ETH)"

  return ()
