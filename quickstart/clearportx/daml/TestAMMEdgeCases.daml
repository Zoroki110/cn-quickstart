module TestAMMEdgeCases where

import Daml.Script
import DA.Time
import qualified Token.Token as T
import qualified AMM.Pool as P
import qualified AMM.SwapRequest as SR
import qualified AMM.Receipt as R

-- Test suite for AMM edge cases and robustness
-- Tests boundary conditions, extreme values, and error handling

-- Test 1: Minimum viable swap (smallest possible amount)
testMinimalSwap : Script ()
testMinimalSwap = script do
  -- Setup parties
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  -- Create pool
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 0.0
    reserveA = 1000.0  -- Matches pool liquidity below
    reserveB = 2000000.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  -- Large liquidity pool: 1000 ETH, 2,000,000 USDC
  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 1000.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 2000000.0

  -- Update pool to link tokens
  updatedPool <- submit poolParty $ exerciseCmd pool P.ArchiveAndUpdateReserves with
    updatedReserveA = 1000.0
    updatedReserveB = 2000000.0
    updatedTokenACid = Some poolETH
    updatedTokenBCid = Some poolUSDC

  -- Alice has tiny amount: 0.01 USDC (1 cent)
  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 0.01

  now <- getTime
  let deadline = addRelTime now (seconds 60)

  -- Create swap request
  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = updatedPool
    poolParty = poolParty
    poolOperator = poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = seconds 120
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 0.01
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = deadline
    maxPriceImpactBps = 5000

  -- Execute swap
  (swapReady, _) <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap with protocolFeeReceiver = clearportx
  receiptCid <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap

  -- Verify we got some ETH (even if tiny)
  Some receipt <- queryContractId alice receiptCid
  ethToken <- queryContractId alice receipt.outputTokenCid
  case ethToken of
    None -> assertFail "ETH token not found"
    Some token -> do
      assertMsg "Should receive positive ETH" (token.amount > 0.0)
      debug $ "✅ Minimal swap successful: " <> show token.amount <> " ETH"

  return ()


-- Test 2: Large swap (significant pool impact)
testLargeSwap : Script ()
testLargeSwap = script do
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 0.0
    reserveA = 10.0  -- Small pool: 10 ETH
    reserveB = 20000.0  -- 20,000 USDC
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  -- Small pool: 10 ETH, 20,000 USDC
  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 10.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 20000.0

  -- Update pool to link tokens
  updatedPool <- submit poolParty $ exerciseCmd pool P.ArchiveAndUpdateReserves with
    updatedReserveA = 10.0
    updatedReserveB = 20000.0
    updatedTokenACid = Some poolETH
    updatedTokenBCid = Some poolUSDC

  -- Alice wants to swap large amount: 8,000 USDC (40% of pool!)
  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 8000.0

  now <- getTime
  let deadline = addRelTime now (seconds 60)

  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = updatedPool
    poolParty = poolParty
    poolOperator = poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = seconds 120
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 8000.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = deadline
    maxPriceImpactBps = 5000  -- Accept high impact (50%) - large swap causes ~44% impact

  (swapReady, _) <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap with protocolFeeReceiver = clearportx
  receiptCid <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap

  Some receipt <- queryContractId alice receiptCid
  ethToken <- queryContractId alice receipt.outputTokenCid
  case ethToken of
    None -> assertFail "ETH token not found"
    Some token -> do
      -- Calculate expected: (8000 * 0.997 * 10) / (20000 + 8000 * 0.997)
      -- = 79760 / 27976 = 2.851 ETH
      let expected = 2.851
      let tolerance = 0.01  -- 1% tolerance
      assertMsg "Amount should be close to expected"
        (abs(token.amount - expected) < tolerance)
      debug $ "✅ Large swap successful: " <> show token.amount <> " ETH (expected ~" <> show expected <> ")"

  return ()


-- Test 3: Exact balance swap (spend entire token)
testExactBalanceSwap : Script ()
testExactBalanceSwap = script do
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 0.0
    reserveA = 10.0  -- 10 ETH
    reserveB = 20000.0  -- 20,000 USDC
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 10.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 20000.0

  -- Update pool to link tokens
  updatedPool <- submit poolParty $ exerciseCmd pool P.ArchiveAndUpdateReserves with
    updatedReserveA = 10.0
    updatedReserveB = 20000.0
    updatedTokenACid = Some poolETH
    updatedTokenBCid = Some poolUSDC

  -- Alice has exactly 100 USDC and swaps ALL of it
  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 100.0

  now <- getTime
  let deadline = addRelTime now (seconds 60)

  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = updatedPool
    poolParty = poolParty
    poolOperator = poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = seconds 120
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 100.0  -- Exact balance!
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = deadline
    maxPriceImpactBps = 5000

  (swapReady, _) <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap with protocolFeeReceiver = clearportx
  receiptCid <- submit poolParty $ exerciseCmd swapReady SR.ExecuteSwap

  Some receipt <- queryContractId alice receiptCid

  -- Verify no USDC remainder for Alice
  aliceTokens <- query @T.Token alice
  let aliceUSDCTokens = filter (\(_cid, token) ->
        token.owner == alice && token.symbol == "USDC") aliceTokens
  assertMsg "Alice should have no USDC left" (length aliceUSDCTokens == 0)

  -- Verify Alice got ETH
  ethToken <- queryContractId alice receipt.outputTokenCid
  case ethToken of
    None -> assertFail "ETH token not found"
    Some token -> do
      assertMsg "Should receive ETH" (token.amount > 0.0)
      debug $ "✅ Exact balance swap successful: " <> show token.amount <> " ETH"

  return ()


-- Test 4: Slippage protection (minOutput enforcement)
testSlippageProtection : Script ()
testSlippageProtection = script do
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 0.0
    reserveA = 10.0  -- 10 ETH
    reserveB = 20000.0  -- 20,000 USDC
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 10.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 20000.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 100.0

  now <- getTime
  let deadline = addRelTime now (seconds 60)

  -- Expected output: ~0.0496 ETH
  -- Set minOutput to UNREALISTIC 1.0 ETH (should fail!)
  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty = poolParty
    poolOperator = poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = seconds 120
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 100.0
    outputSymbol = "ETH"
    minOutput = 1.0  -- Way too high!
    deadline = deadline
    maxPriceImpactBps = 5000

  (swapReady, _) <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap with protocolFeeReceiver = clearportx

  -- This should FAIL with "Min output not met"
  submitMustFail poolParty $ exerciseCmd swapReady SR.ExecuteSwap

  debug "✅ Slippage protection working: swap correctly rejected"
  return ()


-- Test 5: Deadline enforcement
testDeadlineExpired : Script ()
testDeadlineExpired = script do
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 0.0
    reserveA = 10.0  -- 10 ETH
    reserveB = 20000.0  -- 20,000 USDC
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 10.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 20000.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 100.0

  now <- getTime
  let deadline = addRelTime now (seconds 5)  -- Very short deadline!

  swapRequest <- submit alice $ createCmd SR.SwapRequest with
    trader = alice
    poolCid = pool
    poolParty = poolParty
    poolOperator = poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = seconds 120
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 100.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = deadline
    maxPriceImpactBps = 5000

  (swapReady, _) <- submit alice $ exerciseCmd swapRequest SR.PrepareSwap with protocolFeeReceiver = clearportx

  -- Wait 10 seconds (past deadline)
  passTime (seconds 10)

  -- This should FAIL with "Swap expired"
  submitMustFail poolParty $ exerciseCmd swapReady SR.ExecuteSwap

  debug "✅ Deadline enforcement working: expired swap rejected"
  return ()
