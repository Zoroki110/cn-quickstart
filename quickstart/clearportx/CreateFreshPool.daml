module CreateFreshPool where

import DA.Time (days)
import Daml.Script
import qualified Token.Token as T
import qualified LPToken.LPToken as LP
import qualified AMM.Pool as P
import qualified AMM.PoolAnnouncement as PA

-- Create a brand new ETH-USDC pool with fresh tokens
-- This will have NO stale token CIDs (tokenACid=None, tokenBCid=None initially)
createFreshPool : Script ()
createFreshPool = script do
  -- Get the app_provider party
  appProvider <- allocatePartyWithHint "app_provider" (PartyIdHint "app_provider")

  -- Determine the party ID from Canton (this will be set via command line)
  let poolOperator = appProvider
  let poolParty = appProvider
  let lpIssuer = appProvider
  let issuerETH = appProvider
  let issuerUSDC = appProvider
  let protocolFeeReceiver = appProvider

  debug "Creating fresh ETH-USDC pool with NO stale canonicals..."

  -- Create an EMPTY pool with ZERO reserves and NO tokens
  -- This is the ONLY way to avoid the stale canonical problem
  poolCid <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30  -- 0.3% fee
    poolId = "ETH-USDC-FRESH"
    maxTTL = days 365
    totalLPSupply = 0.0    -- ZERO LP supply - empty pool
    reserveA = 0.0         -- ZERO reserves
    reserveB = 0.0         -- ZERO reserves
    tokenACid = None       -- NO token CIDs initially - avoids stale canonical bug!
    tokenBCid = None       -- NO token CIDs initially
    protocolFeeReceiver = protocolFeeReceiver
    maxInBps = 10000       -- Allow up to 100% of reserve as input
    maxOutBps = 5000       -- Allow up to 50% of reserve as output

  debug $ "âœ… Created EMPTY fresh pool: " <> show poolCid
  debug "Pool has ZERO reserves and NO token CIDs (None/None)"
  debug "First AddLiquidity will bootstrap the pool with fresh canonicals"
  debug "This pool is IMMUNE to stale canonical bugs!"

  return ()
