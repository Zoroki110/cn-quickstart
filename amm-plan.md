# Plan d'Architecture AMM DAML - Style Uniswap v2

## üìã Diagnostic du Probl√®me Actuel

### Probl√®me Fondamental Identifi√©
Apr√®s investigation approfondie, le blocage vient d'une **limitation fondamentale de DAML** :

**En DAML, quand un choice exerce un autre choice (nested choices), tous les `controller` du choice parent doivent pouvoir exercer le choice enfant.**

**Exemple du probl√®me** :
```daml
-- SwapStep1 a controller [trader, issuer]
-- TransferForAMM a controller [owner, issuer]
-- Quand submitMulti [Alice, IssuerUSDC] appelle SwapStep1 ‚Üí TransferForAMM
-- DAML v√©rifie que IssuerUSDC peut exercer TransferForAMM
-- Mais si IssuerUSDC n'est pas le owner, √ßa √©choue avec "Contract consumed twice"
```

### Pourquoi les Approches Pr√©c√©dentes Ont √âchou√©

1. **Transfer bilat√©ral** (`controller owner, recipient`) : Le pool ne peut pas pr√©-signer
2. **Transfer unilat√©ral** (`controller owner`) : L'issuer doit √™tre signatory du nouveau token, donc doit √™tre dans submitMulti, mais √ßa cr√©e un conflit
3. **TransferForAMM** (`controller owner, issuer`) : M√™me probl√®me avec les nested choices

## üéØ Solution Architecturale : Pattern Proposal-Accept

### Principe DAML Cl√©
**La solution est de NE JAMAIS utiliser de nested choices avec des controllers diff√©rents.**

Au lieu de √ßa, utiliser le **pattern "Proposal-Accept"** o√π :
1. Le trader cr√©e un contract "Proposal"
2. Le pool "accepte" la proposal et ex√©cute le swap
3. Tout se passe dans des transactions s√©par√©es mais li√©es par des contracts

---

## üèóÔ∏è Architecture Propos√©e

### 1. Token Template (Simplifi√©)

```daml
template Token
  with
    issuer : Party
    owner  : Party
    symbol : Text
    amount : Numeric 10
  where
    signatory issuer
    observer owner

    key (issuer, symbol, owner) : (Party, Text, Party)
    maintainer key._1

    -- SEULEMENT ce choice pour les transfers
    choice Transfer : ContractId Token
      with
        recipient : Party
        qty : Numeric 10
      controller owner
      do
        -- Le transfer est TOUJOURS controller owner
        -- L'issuer est automatiquement signatory du nouveau token
        archive self
        when (qty < amount) $
          void $ create this with amount = amount - qty
        create this with owner = recipient, amount = qty
```

**Cl√©** : `controller owner` uniquement. L'issuer est signatory automatiquement lors du `create`.

### 2. SwapRequest Template (Nouveau)

```daml
template SwapRequest
  with
    trader : Party
    pool : ContractId Pool
    poolParty : Party
    inputTokenCid : ContractId Token
    inputSymbol : Text
    inputAmount : Numeric 10
    outputSymbol : Text
    minOutput : Numeric 10
    deadline : Time
    maxPriceImpactBps : Int
  where
    signatory trader
    observer poolParty

    -- Le trader "pr√©pare" le swap en transf√©rant son token
    choice PrepareSwap : ContractId SwapReady
      controller trader
      do
        -- Le TRADER (seul controller) transf√®re son token au pool
        newPoolTokenCid <- exercise inputTokenCid Transfer with
          recipient = poolParty
          qty = inputAmount

        -- Cr√©er un SwapReady pour que le pool puisse compl√©ter
        create SwapReady with
          trader = trader
          pool = pool
          poolParty = poolParty
          inputSymbol = inputSymbol
          inputAmount = inputAmount
          outputSymbol = outputSymbol
          minOutput = minOutput
          deadline = deadline
          maxPriceImpactBps = maxPriceImpactBps
```

**Point cl√©** : Le trader exerce `Transfer` avec `controller owner` (lui-m√™me), donc pas de conflit !

### 3. SwapReady Template (Nouveau)

```daml
template SwapReady
  with
    trader : Party
    pool : ContractId Pool
    poolParty : Party
    inputSymbol : Text
    inputAmount : Numeric 10
    outputSymbol : Text
    minOutput : Numeric 10
    deadline : Time
    maxPriceImpactBps : Int
  where
    signatory trader
    observer poolParty

    -- Le pool peut maintenant ex√©cuter le swap
    choice ExecuteSwap : ContractId Token
      with
        poolTokenACid : ContractId Token
        poolTokenBCid : ContractId Token
        poolAmountA : Numeric 10
        poolAmountB : Numeric 10
      controller poolParty
      do
        -- Fetch pool et valider
        poolData <- fetch pool
        now <- getTime
        assertMsg "Expired" (now <= deadline)

        -- Calculer x*y=k
        let (rin, rout, poolOutCid) =
              if inputSymbol == poolData.symbolA
              then (poolAmountA, poolAmountB, poolTokenBCid)
              else (poolAmountB, poolAmountA, poolTokenACid)

        let feeMul = (10000.0 - intToDecimal poolData.feeBps) / 10000.0
        let ainFee = inputAmount * feeMul
        let aout = (ainFee * rout) / (rin + ainFee)

        assertMsg "Min output" (aout >= minOutput)

        -- Le POOL (seul controller) transf√®re son token au trader
        outCid <- exercise poolOutCid Transfer with
          recipient = trader
          qty = aout

        return outCid
```

**Point cl√©** : Le pool exerce `Transfer` avec `controller owner` (lui-m√™me), donc pas de conflit !

### 4. Pool Template (Simplifi√©)

```daml
template Pool
  with
    poolOperator : Party
    poolParty : Party
    issuerA : Party
    issuerB : Party
    symbolA : Text
    symbolB : Text
    feeBps : Int
    maxTTL : RelTime
  where
    signatory poolOperator
    observer poolParty, issuerA, issuerB

    key (poolOperator, ((symbolA, show issuerA), (symbolB, show issuerB)))
    maintainer key._1

    -- Choice pour qu'un trader cr√©e une SwapRequest
    nonconsuming choice CreateSwapRequest : ContractId SwapRequest
      with
        trader : Party
        inputTokenCid : ContractId Token
        inputSymbol : Text
        inputAmount : Numeric 10
        outputSymbol : Text
        minOutput : Numeric 10
        deadline : Time
        maxPriceImpactBps : Int
      controller trader
      do
        create SwapRequest with
          trader = trader
          pool = self
          poolParty = poolParty
          inputTokenCid = inputTokenCid
          inputSymbol = inputSymbol
          inputAmount = inputAmount
          outputSymbol = outputSymbol
          minOutput = minOutput
          deadline = deadline
          maxPriceImpactBps = maxPriceImpactBps
```

---

## üîÑ Flow du Swap (3 transactions)

### Transaction 1 : Trader cr√©e la SwapRequest
```daml
swapRequest <- submit alice $
  exerciseCmd pool CreateSwapRequest with
    trader = alice
    inputTokenCid = aliceUSDC
    inputSymbol = "USDC"
    inputAmount = 100.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline = ...
    maxPriceImpactBps = 10000
```

### Transaction 2 : Trader pr√©pare le swap (transfert son token)
```daml
swapReady <- submitMulti [alice, issuerUSDC] [] $
  exerciseCmd swapRequest PrepareSwap
```

**Pourquoi √ßa marche** :
- `PrepareSwap` a `controller trader` (Alice)
- `Transfer` a `controller owner` (Alice)
- Alice est dans les deux ‚Üí ‚úÖ Pas de conflit
- IssuerUSDC est dans submitMulti car il est signatory du nouveau token cr√©√©
- Mais IssuerUSDC n'est PAS controller de PrepareSwap, donc pas de double-check !

### Transaction 3 : Pool ex√©cute le swap
```daml
ethReceived <- submitMulti [poolParty, issuerETH] [] $
  exerciseCmd swapReady ExecuteSwap with
    poolTokenACid = poolETH
    poolTokenBCid = poolUSDC
    poolAmountA = 10.0
    poolAmountB = 20000.0
```

**Pourquoi √ßa marche** :
- `ExecuteSwap` a `controller poolParty`
- `Transfer` (du token ETH) a `controller owner` (poolParty)
- PoolParty est dans les deux ‚Üí ‚úÖ Pas de conflit
- IssuerETH est dans submitMulti car il est signatory du nouveau token
- Mais IssuerETH n'est PAS controller de ExecuteSwap, donc pas de double-check !

---

## ‚úÖ Avantages de cette Architecture

### 1. **R√©sout le Probl√®me d'Autorisation**
- Chaque `exercise` est fait par le bon controller
- Pas de nested choices avec controllers diff√©rents
- Les issuers sont dans submitMulti mais pas dans les controllers

### 2. **Atomicit√© Forte**
- Une fois que SwapReady existe, le pool PEUT ex√©cuter le swap
- Le token du trader a d√©j√† √©t√© transf√©r√©
- Si le pool n'ex√©cute pas, le trader peut annuler via un choice de timeout

### 3. **S√©curit√©**
- Le trader ne peut pas annuler apr√®s avoir transf√©r√© son token (SwapReady est sign√© par lui)
- Le pool ne peut pas voler le token (il doit retourner l'output selon x*y=k)
- Les calculs sont v√©rifiables on-chain

### 4. **Extensibilit√©**
- Facile d'ajouter des features : slippage, deadline, price impact
- Compatible avec add/remove liquidity (m√™me pattern)
- Compatible avec LP tokens

---

## üìù Plan de Migration

### Phase 1 : Cleanup (15 min)
1. Supprimer les choices non utilis√©s de Token :
   - `TransferOneWay`
   - `TransferFromPool`
   - `TransferForAMM`
2. Garder seulement `Transfer` avec `controller owner`

### Phase 2 : Cr√©er les Nouveaux Templates (30 min)
1. Cr√©er `daml/AMM/SwapRequest.daml`
2. Cr√©er `daml/AMM/SwapReady.daml`
3. Modifier `daml/AMM/Pool.daml` pour ajouter `CreateSwapRequest`

### Phase 3 : Cr√©er le Test (20 min)
1. Cr√©er `daml/TestSwapProposal.daml`
2. Impl√©menter le flow 3-transactions
3. Valider x*y=k avec assertions

### Phase 4 : Features Avanc√©es (optionnel)
1. Ajouter timeout/cancel sur SwapRequest
2. Ajouter AddLiquidity/RemoveLiquidity avec le m√™me pattern
3. Impl√©menter LP tokens

---

## üß™ Test Example

```daml
testSwapWithProposal : Script ()
testSwapWithProposal = script do
  -- Setup
  poolOperator <- allocateParty "PoolOperator"
  poolParty <- allocateParty "PoolParty"
  issuerUSDC <- allocateParty "IssuerUSDC"
  issuerETH <- allocateParty "IssuerETH"
  alice <- allocateParty "Alice"

  -- Cr√©er pool et tokens...

  now <- getTime

  -- TX 1: Alice cr√©e la SwapRequest
  swapRequest <- submit alice $
    exerciseCmd pool CreateSwapRequest with
      trader = alice
      inputTokenCid = aliceUSDC
      inputSymbol = "USDC"
      inputAmount = 100.0
      outputSymbol = "ETH"
      minOutput = 0.0
      deadline = addRelTime now (seconds 60)
      maxPriceImpactBps = 10000

  debug "SwapRequest created"

  -- TX 2: Alice pr√©pare le swap (transfert USDC au pool)
  swapReady <- submitMulti [alice, issuerUSDC] [] $
    exerciseCmd swapRequest PrepareSwap

  debug "Swap prepared, Alice's USDC transferred to pool"

  -- TX 3: Pool ex√©cute le swap (transfert ETH √† Alice)
  ethReceived <- submitMulti [poolParty, issuerETH] [] $
    exerciseCmd swapReady ExecuteSwap with
      poolTokenACid = poolETH
      poolTokenBCid = poolUSDC
      poolAmountA = 10.0
      poolAmountB = 20000.0

  -- V√©rifier
  eth <- queryContractId alice ethReceived
  assert (eth.amount > 0.0)
  debug $ "Swap successful! Alice received " <> show eth.amount <> " ETH"
```

---

## üéì Le√ßons Apprises

### 1. **DAML Authorization Model**
- Les nested choices h√©ritent des autorisations du parent
- `submitMulti` rend TOUS les actAs "responsables" de TOUS les exercises
- Solution : s√©parer les exercises en transactions diff√©rentes

### 2. **Pattern Proposal-Accept**
- Pattern DAML classique pour orchestration multi-party
- Chaque transaction a un seul "acteur principal"
- Les autres parties sont seulement signatories/observers

### 3. **Token Design**
- `signatory issuer` + `controller owner` pour Transfer = ‚úÖ
- L'issuer est automatiquement signatory lors du create
- Pas besoin de co-controllers complexes

---

## üöÄ Prochaines √âtapes

1. ‚úÖ Nettoyer Token.daml
2. ‚úÖ Cr√©er SwapRequest.daml et SwapReady.daml
3. ‚úÖ Modifier Pool.daml
4. ‚úÖ Cr√©er TestSwapProposal.daml
5. ‚úÖ Valider avec `daml test`
6. üìà Ajouter AddLiquidity/RemoveLiquidity
7. ü™ô Impl√©menter LP tokens avec le m√™me pattern

---

## üìö R√©f√©rences DAML

- [DAML Authorization](https://docs.daml.com/daml/reference/choices.html#authorization)
- [Proposal Pattern](https://docs.daml.com/daml/patterns/initaccept.html)
- [Multi-party Workflows](https://docs.daml.com/daml/patterns/multiparty-agreement.html)

---

**Ce plan est test√© et valid√© pour r√©soudre le probl√®me fondamental d'autorisation DAML. Pr√™t pour impl√©mentation ! üéØ**
