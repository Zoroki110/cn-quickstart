module AMM.Pool where

import qualified Token.Token as T
import qualified LPToken.LPToken as LP
import qualified AMM.Types as Types
import DA.Time (RelTime)
import DA.Action (void, when)
import DA.Math (sqrt)

{-
  POOL TEMPLATE WITH LIQUIDITY PROVISION

  DESIGN CHANGES (Phase 1):
  1. Added totalLPSupply, reserveA, reserveB to track pool state
  2. Direct AddLiquidity/RemoveLiquidity choices (no request templates)
  3. Multi-party controllers: provider, poolParty, lpIssuer
  4. Slippage protection: minLPTokens, minAmountA, minAmountB
  5. Archive-and-recreate pattern to update reserves

  KEY FORMULA:
  - First LP: lpTokens = sqrt(amountA * amountB)
  - Subsequent: lpTokens = min(amountA * totalSupply / reserveA, amountB * totalSupply / reserveB)
-}

template Pool
  with
    poolOperator : Party
    poolParty : Party
    lpIssuer : Party
    issuerA : Party
    issuerB : Party
    symbolA : Text
    symbolB : Text
    feeBps : Int
    poolId : Text
    maxTTL : RelTime
    totalLPSupply : Numeric 10  -- Total LP tokens minted
    reserveA : Numeric 10       -- Current reserve of tokenA
    reserveB : Numeric 10       -- Current reserve of tokenB
  where
    signatory poolOperator
    observer poolParty, lpIssuer, issuerA, issuerB

    key (poolOperator, ((symbolA, show issuerA), (symbolB, show issuerB))) : (Party, ((Text, Text), (Text, Text)))
    maintainer key._1

    ensure
      (symbolA, show issuerA) < (symbolB, show issuerB) &&
      totalLPSupply >= 0.0 &&
      reserveA >= 0.0 &&
      reserveB >= 0.0 &&
      -- HIGH-4 FIX: If pool has LP tokens, it MUST have reserves
      (totalLPSupply == 0.0 || (reserveA > 0.0 && reserveB > 0.0)) &&
      -- If pool has reserves, it must have LP tokens (unless initial state)
      ((reserveA == 0.0 && reserveB == 0.0) || totalLPSupply >= 0.0)

    -- Add liquidity: deposit tokens A & B, receive LP tokens
    choice AddLiquidity : (ContractId LP.LPToken, ContractId Pool)
      with
        provider : Party
        tokenACid : ContractId T.Token
        tokenBCid : ContractId T.Token
        amountA : Numeric 10
        amountB : Numeric 10
        minLPTokens : Numeric 10  -- Slippage protection
        deadline : Time
      controller provider, poolParty, lpIssuer
      do
        -- Deadline check
        now <- getTime
        assertMsg "Deadline passed" (now <= deadline)

        -- MEDIUM-2 FIX: Enforce minimum liquidity to prevent dust/griefing attacks
        assertMsg ("Minimum liquidity not met for token A (min: " <> show Types.minLiquidity <> ")")
          (amountA >= Types.minLiquidity)
        assertMsg ("Minimum liquidity not met for token B (min: " <> show Types.minLiquidity <> ")")
          (amountB >= Types.minLiquidity)

        -- Calculate LP tokens to mint
        let lpTokensToMint = if totalLPSupply == 0.0
              then sqrt (amountA * amountB)  -- First LP: geometric mean
              else
                let shareA = amountA * totalLPSupply / reserveA
                    shareB = amountB * totalLPSupply / reserveB
                in min shareA shareB  -- Subsequent: proportional to reserves

        -- Slippage protection
        assertMsg "Slippage: LP tokens below minimum" (lpTokensToMint >= minLPTokens)

        -- Transfer tokens to pool
        -- Token.Transfer has controller owner (provider), so provider authorizes
        _ <- exercise tokenACid T.Transfer with recipient = poolParty, qty = amountA
        _ <- exercise tokenBCid T.Transfer with recipient = poolParty, qty = amountB

        -- Mint LP tokens (lpIssuer creates token for provider)
        lpToken <- create LP.LPToken with
          issuer = lpIssuer
          owner = provider
          poolId = poolId
          amount = lpTokensToMint

        -- Update pool reserves (choice is consuming, auto-archives)
        newPool <- create this with
          totalLPSupply = totalLPSupply + lpTokensToMint
          reserveA = reserveA + amountA
          reserveB = reserveB + amountB

        return (lpToken, newPool)

    -- Remove liquidity: burn LP tokens, receive tokens A & B
    choice RemoveLiquidity : (ContractId T.Token, ContractId T.Token, ContractId Pool)
      with
        provider : Party
        lpTokenCid : ContractId LP.LPToken
        lpTokenAmount : Numeric 10
        minAmountA : Numeric 10  -- Slippage protection
        minAmountB : Numeric 10  -- Slippage protection
        poolTokenACid : ContractId T.Token  -- Pool's tokenA holdings
        poolTokenBCid : ContractId T.Token  -- Pool's tokenB holdings
        deadline : Time
      controller provider, poolParty, lpIssuer
      do
        -- Deadline check
        now <- getTime
        assertMsg "Deadline passed" (now <= deadline)

        -- Positive amount
        assertMsg "Positive LP amount" (lpTokenAmount > 0.0)
        assertMsg "Pool has supply" (totalLPSupply > 0.0)

        -- Calculate tokens to return (proportional to LP share)
        let shareRatio = lpTokenAmount / totalLPSupply
        let amountAOut = reserveA * shareRatio
        let amountBOut = reserveB * shareRatio

        -- Slippage protection
        assertMsg "Slippage: amountA below minimum" (amountAOut >= minAmountA)
        assertMsg "Slippage: amountB below minimum" (amountBOut >= minAmountB)

        -- Burn LP tokens
        -- LP.Burn has controller owner (provider), so provider authorizes
        _ <- exercise lpTokenCid LP.Burn with qty = lpTokenAmount

        -- Transfer tokens from pool to provider
        -- Token.Transfer has controller owner (poolParty), so poolParty authorizes
        tokenAOut <- exercise poolTokenACid T.Transfer with recipient = provider, qty = amountAOut
        tokenBOut <- exercise poolTokenBCid T.Transfer with recipient = provider, qty = amountBOut

        -- Update pool reserves (choice is consuming, auto-archives)
        newPool <- create this with
          totalLPSupply = totalLPSupply - lpTokenAmount
          reserveA = reserveA - amountAOut
          reserveB = reserveB - amountBOut

        return (tokenAOut, tokenBOut, newPool)

    -- Legacy choices (kept for backward compatibility with existing swap tests)
    nonconsuming choice GetReservesForPool : (Numeric 10, Numeric 10)
      controller poolParty
      do
        return (reserveA, reserveB)

    nonconsuming choice GetSupply : Numeric 10
      controller lpIssuer
      do
        return totalLPSupply

    -- Get spot price (instantaneous exchange rate)
    -- Returns (priceOfA, priceOfB) where:
    -- - priceOfA = how much B you get for 1 A (e.g., 1 ETH = 2000 USDC)
    -- - priceOfB = how much A you get for 1 B (e.g., 1 USDC = 0.0005 ETH)
    -- Note: This is the mid-market price BEFORE any swap impact
    nonconsuming choice GetSpotPrice : (Numeric 10, Numeric 10)
      controller poolOperator
      do
        assertMsg "Pool has no liquidity" (reserveA > 0.0 && reserveB > 0.0)
        let priceOfA = reserveB / reserveA  -- Price of A in terms of B
        let priceOfB = reserveA / reserveB  -- Price of B in terms of A
        return (priceOfA, priceOfB)

    -- CRITICAL-3 FIX: Reconcile reserves with actual token balances
    -- This nonconsuming choice allows verification that stored reserves
    -- match the actual token holdings, preventing state inconsistencies
    nonconsuming choice VerifyReserves : (Bool, Text)
      with
        poolTokenACid : ContractId T.Token
        poolTokenBCid : ContractId T.Token
      controller poolOperator
      do
        -- Fetch actual token amounts held by pool
        tokenA <- fetch poolTokenACid
        tokenB <- fetch poolTokenBCid

        -- Verify tokens belong to poolParty
        assertMsg "Token A not owned by pool" (tokenA.owner == poolParty)
        assertMsg "Token B not owned by pool" (tokenB.owner == poolParty)
        assertMsg "Token A symbol mismatch" (tokenA.symbol == symbolA)
        assertMsg "Token B symbol mismatch" (tokenB.symbol == symbolB)

        -- Check if reserves match (with small tolerance for rounding)
        let tolerance = 0.0000001
        let reserveAMatches = abs(tokenA.amount - reserveA) < tolerance
        let reserveBMatches = abs(tokenB.amount - reserveB) < tolerance
        let allMatch = reserveAMatches && reserveBMatches

        -- Build status message
        let statusMsg = if allMatch
              then "Reserves verified: " <> show reserveA <> " " <> symbolA <> ", " <> show reserveB <> " " <> symbolB
              else "RESERVE MISMATCH! Stored: (" <> show reserveA <> ", " <> show reserveB <>
                   ") vs Actual: (" <> show tokenA.amount <> ", " <> show tokenB.amount <> ")"

        return (allMatch, statusMsg)