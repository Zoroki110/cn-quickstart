{"ast":null,"code":"import _objectSpread from\"/root/cn-quickstart/quickstart/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";var _BUILD_INFO$features;// ClearportX Backend API Service\n// Connects to Spring Boot backend at http://localhost:8080\nimport axios from'axios';import{getAccessToken,getPartyId}from'./auth';import{BUILD_INFO}from'../config/build-info';import{getActiveWalletParty,getAuthToken}from'../api/client';const runtimeBackendUrl=typeof window!=='undefined'&&window.__BACKEND_URL__||undefined;const BACKEND_URL=process.env.REACT_APP_BACKEND_API_URL||(BUILD_INFO===null||BUILD_INFO===void 0?void 0:(_BUILD_INFO$features=BUILD_INFO.features)===null||_BUILD_INFO$features===void 0?void 0:_BUILD_INFO$features.backendUrl)||runtimeBackendUrl||'http://localhost:8080';/**\n * Map frontend party names to Canton ledger party IDs\n * This allows using friendly names like \"alice\" in the frontend\n * while using the real Canton party IDs in backend calls\n */const DEVNET_PARTY=process.env.REACT_APP_PARTY_ID||'ClearportX-DEX-1::122081f2b8e29cbe57d1037a18e6f70e57530773b3a4d1bea6bab981b7a76e943b37';const PARTY_MAPPING={'alice@clearportx':DEVNET_PARTY,'alice':DEVNET_PARTY,'bob':DEVNET_PARTY,'AppProvider':DEVNET_PARTY,'app-provider':DEVNET_PARTY};const FALLBACK_TRANSACTIONS=[];/**\n * Map frontend party name to Canton party ID\n */function mapPartyToBackend(frontendParty){return PARTY_MAPPING[frontendParty]||frontendParty;}export class BackendApiService{constructor(){this.client=void 0;this.client=axios.create({baseURL:BACKEND_URL,timeout:30000,headers:{'Content-Type':'application/json','ngrok-skip-browser-warning':'true'// Skip ngrok warning page\n}});// JWT and X-Party interceptor\nthis.client.interceptors.request.use(config=>{var _config$url;const walletToken=getAuthToken();const token=walletToken||getAccessToken();const walletPartyId=getActiveWalletParty();const party=walletPartyId||getPartyId()||DEVNET_PARTY;const publicEndpoints=['/api/pools','/api/health','/api/health/ledger','/actuator/health','/api/debug/','/api/clearportx/debug/'];const url=(_config$url=config.url)!==null&&_config$url!==void 0?_config$url:'';const isPublicEndpoint=publicEndpoints.some(endpoint=>url.includes(endpoint));if(isPublicEndpoint){// Force public calls to stay unauthenticated to avoid 401s when logged out.\ndelete config.headers.Authorization;}else if(token){config.headers.Authorization=\"Bearer \".concat(token);console.log('ðŸ” Adding JWT to request:',config.url);}else{console.warn('âš ï¸ No JWT token found for protected endpoint:',config.url);}if(party){config.headers['X-Party']=party;console.log('ðŸ‘¤ Adding X-Party header:',party.substring(0,30)+'...');}return config;});// Retry on 429 (rate limit) only; 409 handled by request() wrapper\nthis.client.interceptors.response.use(response=>response,async error=>{var _error$response;if(((_error$response=error.response)===null||_error$response===void 0?void 0:_error$response.status)===429){const retryAfter=parseInt(error.response.headers['retry-after']||'3',10);const waitMs=isNaN(retryAfter)?3000:retryAfter*1000;console.log(\"\\u26A0\\uFE0F  Rate limited, retrying after \".concat(Math.round(waitMs/1000),\"s...\"));await new Promise(resolve=>setTimeout(resolve,waitMs));// Retry the original request\nreturn this.client.request(error.config);}throw error;});}hasJwt(){const walletToken=getAuthToken();if(walletToken){return true;}const token=getAccessToken();return!!token&&token!=='devnet-mock-token';}// Resolve a fresh pool CID for a given poolId by choosing a pool whose canonical token CIDs are alive for poolParty\nasync resolveFreshPoolCidById(poolId){try{var _cidsRes$data,_poolPartyTokensRes$d;const appParty=this.currentParty();// Resolve poolParty from poolId\nconst parties=await this.client.post('/api/debug/pool-parties',{poolId}).then(r=>{var _r$data;return(_r$data=r.data)===null||_r$data===void 0?void 0:_r$data.parties;}).catch(()=>null);const poolParty=parties===null||parties===void 0?void 0:parties.poolParty;if(!poolParty)return null;// Fetch all pools visible to appParty\nconst cidsRes=await this.client.get('/api/clearportx/debug/party-acs',{params:{template:'AMM.Pool.Pool'},headers:{'X-Party':appParty}});const poolCids=((_cidsRes$data=cidsRes.data)===null||_cidsRes$data===void 0?void 0:_cidsRes$data.cids)||[];// Fetch poolParty tokens once\nconst poolPartyTokensRes=await this.client.get('/api/clearportx/debug/party-acs',{params:{template:'Token.Token.Token'},headers:{'X-Party':poolParty}}).catch(()=>null);const poolPartyTokenCidSet=new Set((poolPartyTokensRes===null||poolPartyTokensRes===void 0?void 0:(_poolPartyTokensRes$d=poolPartyTokensRes.data)===null||_poolPartyTokensRes$d===void 0?void 0:_poolPartyTokensRes$d.cids)||[]);const emptyPools=[];const aliveCanonPools=[];for(const cid of poolCids){try{const meta=await this.client.get('/api/clearportx/debug/pool-by-cid',{params:{cid},headers:{'X-Party':appParty}}).then(r=>r.data);if(!(meta!==null&&meta!==void 0&&meta.success))continue;if(meta.poolId!==poolId)continue;const ca=meta.tokenACid;const cb=meta.tokenBCid;if(!ca&&!cb)emptyPools.push(cid);else if(ca&&cb&&poolPartyTokenCidSet.has(ca)&&poolPartyTokenCidSet.has(cb))aliveCanonPools.push(cid);}catch(_unused){// ignore and continue\n}}if(emptyPools.length>0)return emptyPools[0];if(aliveCanonPools.length>0)return aliveCanonPools[0];return null;}catch(_unused2){return null;}}// Sleep helper for pacing (DevNet-friendly)\nasync sleep(ms){return new Promise(resolve=>setTimeout(resolve,ms));}currentParty(){return getActiveWalletParty()||getPartyId()||DEVNET_PARTY;}// Expose current acting party to UI (for consistent token refresh)\ngetCurrentParty(){return this.currentParty();}// Always resolve a fresh, party-visible CID for a poolId (server guarantees visibility)\nasync resolveAndGrant(poolId,party){var _BUILD_INFO$features2;const res=await this.request(()=>this.client.post('/api/debug/resolve-and-grant',{poolId,party},{headers:{'X-Party':party}}));if(!(res!==null&&res!==void 0&&res.success)||!(res!==null&&res!==void 0&&res.poolCid)){throw new Error(\"Resolver failed for \".concat(poolId));}let cid=res.poolCid;const resolvedPkg=res.packageId;// Prefer latest AMM package when multiple pool instances exist\nconst preferredPkgPrefix=(process.env.REACT_APP_AMM_POOL_PACKAGE_ID||'').trim()||((BUILD_INFO===null||BUILD_INFO===void 0?void 0:(_BUILD_INFO$features2=BUILD_INFO.features)===null||_BUILD_INFO$features2===void 0?void 0:_BUILD_INFO$features2.ammPackageId)||'').trim()||'';try{if(preferredPkgPrefix&&(!resolvedPkg||!(resolvedPkg!==null&&resolvedPkg!==void 0&&resolvedPkg.toLowerCase().startsWith(preferredPkgPrefix.toLowerCase())))){// Scan party-visible pools for the same poolId and pick the one with preferred packageId\nconst rows=await this.fetchPoolsForParty(party);const sameId=rows.filter(r=>r.poolId===poolId);for(const row of sameId){try{const ti=await this.request(()=>this.client.get('/api/debug/pool/template-id',{params:{cid:row.poolCid},headers:{'X-Party':party}}));const pkg=(ti===null||ti===void 0?void 0:ti.packageId)||'';if(pkg&&pkg.toLowerCase().startsWith(preferredPkgPrefix.toLowerCase())){cid=row.poolCid;break;}}catch(_unused3){// ignore and continue\n}}}}catch(_unused4){// best-effort preference; keep resolver selection if anything fails\n}return{poolCid:cid,poolId:res.poolId,packageId:resolvedPkg};}// Centralized request wrapper with single paced 409 retry\nasync request(call){try{const res=await call();return res.data;}catch(e){var _err$response,_err$response2;const err=e;const status=(_err$response=err.response)===null||_err$response===void 0?void 0:_err$response.status;const body=((_err$response2=err.response)===null||_err$response2===void 0?void 0:_err$response2.data)||{};if(status===409){const retryMs=typeof body.retry_after_ms==='number'&&body.retry_after_ms>0?body.retry_after_ms:3500;console.log(\"\\u26A0\\uFE0F  409 Stale/Visibility, retrying once after \".concat(Math.round(retryMs/1000),\"s...\"));await this.sleep(retryMs);const res2=await call();return res2.data;}const domain={code:body.code||'INTERNAL',message:body.message||body.error||err.message||'Internal error',retryAfterMs:body.retry_after_ms,httpStatus:status};throw domain;}}// Use backend summary of pools visible to a party (includes poolCid and reserves)\nasync fetchPoolsForParty(party){try{// Prefer POST to match backend behavior; fallback to GET for compatibility\nlet list=[];try{const resPost=await this.client.post('/api/debug/pools-for-party',{party});list=Array.isArray(resPost.data)?resPost.data:[];}catch(_unused5){const resGet=await this.client.get('/api/debug/pools-for-party',{params:{party}});list=Array.isArray(resGet.data)?resGet.data:[];}return list;}catch(_unused6){return[];}}// Directory mapping (poolId -> latest poolCid); maintained by backend on updates\nasync getDirectoryLatestCid(poolId){try{var _res$data;const res=await this.client.get('/api/clearportx/debug/directory');const mapping=((_res$data=res.data)===null||_res$data===void 0?void 0:_res$data.mapping)||{};const entry=mapping[poolId];const cid=(entry===null||entry===void 0?void 0:entry.poolCid)||null;return cid;}catch(_unused7){return null;}}// Ensure chosen poolCid is visible to acting party; grant if needed; return (possibly) updated CID\nasync ensurePoolCidVisible(poolCid,poolId,party){try{const probe=await this.request(()=>this.client.get('/api/clearportx/debug/pool/fetch-cid',{params:{cid:poolCid},headers:{'X-Party':party}}));if((probe===null||probe===void 0?void 0:probe.visible)===true)return poolCid;}catch(_unused8){// fall through to grant\n}// Do NOT attempt grant over remote. Pick a party-visible CID for same poolId or by pair.\ntry{const rows=await this.fetchPoolsForParty(party);const sameId=rows.find(r=>r.poolId===poolId);if(sameId)return sameId.poolCid;const m=(poolId||'').toUpperCase().match(/([A-Z]+)-([A-Z]+)/);if(m&&m.length>=3){const[,a,b]=m;const byPair=rows.filter(r=>r.symbolA===a&&r.symbolB===b||r.symbolA===b&&r.symbolB===a);if(byPair.length>0){const chosen=[...byPair].sort((x,y)=>parseFloat(y.reserveA)*parseFloat(y.reserveB)-parseFloat(x.reserveA)*parseFloat(x.reserveB))[0];return chosen.poolCid;}}}catch(_unused9){// ignore\n}// Last resort: return original and let caller retry candidates\nreturn poolCid;}// Choose pool CID for a poolId: prefer empty pool (0/0) for first add; else pick highest TVL\nasync resolvePoolCidForIdPreferEmpty(poolId){const party=this.currentParty();const pools=await this.fetchPoolsForParty(party);const forId=pools.filter(p=>p.poolId===poolId);if(forId.length===0)return null;const empties=forId.filter(p=>parseFloat(p.reserveA)===0&&parseFloat(p.reserveB)===0);if(empties.length>0)return empties[0].poolCid;// pick by TVL proxy (reserveA*reserveB) descending\nconst sorted=[...forId].sort((a,b)=>{const ta=parseFloat(a.reserveA)*parseFloat(a.reserveB);const tb=parseFloat(b.reserveA)*parseFloat(b.reserveB);return tb-ta;});return sorted[0].poolCid;}async resolvePoolCid(poolId){return this.resolvePoolCidForIdPreferEmpty(poolId);}/**\n   * Health check - verify backend is running and synced\n   */async healthCheck(){try{const res=await this.client.get('/api/health/ledger');return res.data;}catch(error){console.error('Health check failed:',error);// Return a default response indicating the backend is down\nreturn{status:'DOWN',env:'unknown',darVersion:'unknown',atomicSwapAvailable:false,poolsActive:0,synced:false};}}/**\n   * Get all active pools from holding-pools endpoint (single source of truth).\n   */async getPools(){try{const res=await this.client.get('/api/holding-pools');const rows=Array.isArray(res.data)?res.data:[];const pools=rows.map(row=>this.mapHoldingPool(row));return this.normalizePools(pools);}catch(err){console.error('holding-pools fetch failed',err);return[];}}async getHoldingPool(poolCid){try{const res=await this.client.get(\"/api/holding-pools/\".concat(poolCid));return res.data;}catch(err){console.error('holding-pool fetch failed',err);return null;}}async loadPartyScopedPools(){var _BUILD_INFO$features3;const party=this.currentParty();const partyRows=await this.fetchPoolsForParty(party);if(partyRows.length===0){return[];}let directoryMap={};try{var _dirRes$data;const dirRes=await this.client.get('/api/clearportx/debug/directory');directoryMap=((_dirRes$data=dirRes.data)===null||_dirRes$data===void 0?void 0:_dirRes$data.mapping)||{};}catch(_unused0){directoryMap={};}const preferredPkgPrefix=(process.env.REACT_APP_AMM_POOL_PACKAGE_ID||'').trim()||((BUILD_INFO===null||BUILD_INFO===void 0?void 0:(_BUILD_INFO$features3=BUILD_INFO.features)===null||_BUILD_INFO$features3===void 0?void 0:_BUILD_INFO$features3.ammPackageId)||'').trim();const groups=new Map();for(const row of partyRows){const key=[String(row.symbolA),String(row.symbolB)].sort().join('/');const arr=groups.get(key)||[];arr.push(row);groups.set(key,arr);}const chosenRows=[];const groupedValues=Array.from(groups.values());for(const rows of groupedValues){let picked=null;if(!picked&&preferredPkgPrefix){for(const r of rows){try{const ti=await this.request(()=>this.client.get('/api/debug/pool/template-id',{params:{cid:r.poolCid},headers:{'X-Party':party}}));const pkg=(ti===null||ti===void 0?void 0:ti.packageId)||'';if(pkg&&pkg.toLowerCase().startsWith(String(preferredPkgPrefix).toLowerCase())){picked=r;break;}}catch(_unused1){// ignore and continue\n}}}if(!picked){const latestMatches=[];for(const r of rows){var _directoryMap$r$poolI;const latest=(_directoryMap$r$poolI=directoryMap[r.poolId])===null||_directoryMap$r$poolI===void 0?void 0:_directoryMap$r$poolI.poolCid;if(latest&&latest===r.poolCid){latestMatches.push(r);}}if(latestMatches.length>0){picked=[...latestMatches].sort((a,b)=>parseFloat(b.reserveA)*parseFloat(b.reserveB)-parseFloat(a.reserveA)*parseFloat(a.reserveB))[0];}}if(!picked){picked=[...rows].sort((a,b)=>parseFloat(b.reserveA)*parseFloat(b.reserveB)-parseFloat(a.reserveA)*parseFloat(a.reserveB))[0];}if(picked){chosenRows.push(picked);}}return chosenRows.map(row=>this.mapPartyPool(row));}normalizePools(pools){if(!Array.isArray(pools)||pools.length===0){return[];}const activePools=pools.filter(pool=>pool.reserveA>0&&pool.reserveB>0);if(activePools.length===0){return[...pools];}const pairToBest={};for(const pool of activePools){const pairKey=[pool.tokenA.symbol,pool.tokenB.symbol].sort().join('/');const tvl=pool.reserveA*pool.reserveB;const current=pairToBest[pairKey];if(!current||tvl>current.reserveA*current.reserveB){pairToBest[pairKey]=pool;}}return Object.values(pairToBest).sort((a,b)=>{const tvlA=a.reserveA*a.reserveB;const tvlB=b.reserveA*b.reserveB;return tvlB-tvlA;});}/**\n   * Get tokens owned by a party\n   * Maps frontend party names (like 'alice') to Canton party IDs\n   */async getTokens(party){const cantonParty=mapPartyToBackend(party);console.log(\"Getting tokens for \".concat(party,\" (mapped to \").concat(cantonParty,\")\"));try{// Prefer authenticated wallet endpoint; fallback to debug or legacy public tokens\nlet res;try{res=await this.client.get(\"/api/wallet/tokens/\".concat(cantonParty));}catch(e){var _e$response;const status=e===null||e===void 0?void 0:(_e$response=e.response)===null||_e$response===void 0?void 0:_e$response.status;if(status===401||status===403||status===404){// Dev fallback: debug wallet tokens by query param\ntry{res=await this.client.get(\"/api/debug/wallet/tokens\",{params:{party:cantonParty}});}catch(_unused10){// Last resort: legacy tokens (includes canonicals)\nres=await this.client.get(\"/api/tokens/\".concat(cantonParty));}}else{throw e;}}// Ensure res.data is an array\nconst tokenData=Array.isArray(res.data)?res.data:[];// Map all tokens\nlet allTokens=tokenData.map(data=>this.mapToken(data));// Dev-only heuristic: exclude giant faucet mints when unauthenticated\nif(!this.hasJwt()){allTokens=allTokens.filter(t=>(t.balance||0)<100000);}const aggregatedTokens=this.aggregateTokensBySymbol(allTokens).filter(token=>(token.balance||0)>0);console.log(\"Aggregated \".concat(allTokens.length,\" tokens into \").concat(aggregatedTokens.length,\" unique tokens\"));return aggregatedTokens;}catch(error){console.error('Error loading tokens:',error);return[];}}/**\n   * Wallet-only tokens (exclude pool canonical tokens)\n   */async getWalletTokens(party){const cantonParty=mapPartyToBackend(party);console.log(\"Getting wallet tokens for \".concat(party,\" (mapped to \").concat(cantonParty,\")\"));try{const res=await this.client.get(\"/api/wallet/tokens/\".concat(cantonParty));const tokenData=Array.isArray(res.data)?res.data:[];const aggregated=this.aggregateTokensBySymbol(tokenData.map(data=>this.mapToken(data)));console.log(\"Wallet tokens aggregated into \".concat(aggregated.length,\" entries\"));return aggregated;}catch(error){console.error('Error loading wallet tokens:',error);return this.getTokens(party);}}async getLpTokens(party){const cantonParty=mapPartyToBackend(party);console.log(\"Getting LP tokens for \".concat(party,\" (mapped to \").concat(cantonParty,\")\"));try{const res=await this.client.get(\"/api/wallet/lp-tokens/\".concat(cantonParty));const rows=Array.isArray(res.data)?res.data:[];const mapped=rows.map(row=>({poolId:row.poolId||row.pool_id||'',amount:parseFloat(row.amount||row.balance||'0'),contractId:row.contractId||row.cid||'',owner:row.owner||row.party||undefined})).filter(lp=>lp.poolId&&Number.isFinite(lp.amount)&&lp.amount>0);console.log(\"Fetched \".concat(mapped.length,\" LP token positions\"));return mapped;}catch(error){console.error('Error loading LP tokens:',error);return[];}}async getLpPositions(party,poolCid){const cantonParty=mapPartyToBackend(party);console.log(\"Getting LP positions for \".concat(party,\" (mapped to \").concat(cantonParty,\")\"));try{const res=await this.client.get('/api/lp/positions',{params:poolCid?{ownerParty:cantonParty,poolCid}:{ownerParty:cantonParty}});const rows=Array.isArray(res.data)?res.data:[];const mapped=rows.map(row=>{var _ref,_row$lpBalance,_row$reserveA,_row$reserveB,_row$updatedAt;return{poolCid:row.poolCid||row.pool_id||'',lpBalance:(_ref=(_row$lpBalance=row.lpBalance)!==null&&_row$lpBalance!==void 0?_row$lpBalance:row.balance)!==null&&_ref!==void 0?_ref:'0',shareBps:typeof row.shareBps==='number'?row.shareBps:row.shareBps?Number(row.shareBps):undefined,reserveA:(_row$reserveA=row.reserveA)!==null&&_row$reserveA!==void 0?_row$reserveA:undefined,reserveB:(_row$reserveB=row.reserveB)!==null&&_row$reserveB!==void 0?_row$reserveB:undefined,updatedAt:(_row$updatedAt=row.updatedAt)!==null&&_row$updatedAt!==void 0?_row$updatedAt:undefined};}).filter(pos=>pos.poolCid&&pos.lpBalance);console.log(\"Fetched \".concat(mapped.length,\" LP positions\"),mapped[0]?{first:mapped[0]}:'');return mapped;}catch(error){console.error('Error loading LP positions:',error);return[];}}/**\n   * Get pool CID for a given pool by matching token symbols\n   * Fetches pool CIDs from the backend and finds matching pool\n   */async getPoolCidBySymbols(tokenASymbol,tokenBSymbol){try{var _res$data2;// Get the party ID\nconst party=getPartyId()||DEVNET_PARTY;// Fetch all pools visible to this party\nconst res=await this.client.get('/api/clearportx/debug/party-acs',{params:{template:'AMM.Pool.Pool'},headers:{'X-Party':party}});const poolCids=((_res$data2=res.data)===null||_res$data2===void 0?void 0:_res$data2.cids)||[];console.log(\"Found \".concat(poolCids.length,\" pool CIDs for party\"));// For each pool CID, fetch details to find matching symbols\nfor(const cid of poolCids){try{const poolRes=await this.client.get('/api/clearportx/debug/pool-by-cid',{params:{cid},headers:{'X-Party':party}});const poolData=poolRes.data;if(poolData.success&&(poolData.symbolA===tokenASymbol&&poolData.symbolB===tokenBSymbol||poolData.symbolA===tokenBSymbol&&poolData.symbolB===tokenASymbol)){console.log(\"Found matching pool: \".concat(poolData.poolId,\" with CID: \").concat(cid));return cid;}}catch(error){console.error(\"Error fetching pool details for CID \".concat(cid,\":\"),error);}}console.warn(\"No pool found for \".concat(tokenASymbol,\"/\").concat(tokenBSymbol));return null;}catch(error){console.error('Error fetching pool CIDs:',error);return null;}}/**\n   * Execute swap via debug endpoint (JWT-aware)\n   */async executeAtomicSwap(params){var _params$minOutput,_ref2,_ref3,_swapResponse$resolve,_ref4,_swapResponse$command;const party=this.currentParty();const resolvedPoolId=params.poolId||\"\".concat(params.inputSymbol,\"-\").concat(params.outputSymbol);const{poolCid}=await this.resolveAndGrant(resolvedPoolId,party);const minOutputStr=(_params$minOutput=params.minOutput)!==null&&_params$minOutput!==void 0?_params$minOutput:'0';const body={poolCid,poolId:resolvedPoolId,inputSymbol:params.inputSymbol,outputSymbol:params.outputSymbol,amountIn:params.inputAmount,minOutput:minOutputStr};const swapResponse=await this.request(()=>this.client.post('/api/clearportx/debug/swap-by-cid',body,{headers:{'X-Party':party}}));const rawResolvedOutput=(_ref2=(_ref3=(_swapResponse$resolve=swapResponse===null||swapResponse===void 0?void 0:swapResponse.resolvedOutput)!==null&&_swapResponse$resolve!==void 0?_swapResponse$resolve:swapResponse===null||swapResponse===void 0?void 0:swapResponse.amountOut)!==null&&_ref3!==void 0?_ref3:swapResponse===null||swapResponse===void 0?void 0:swapResponse.minOutput)!==null&&_ref2!==void 0?_ref2:'0';const numericResolved=Number(rawResolvedOutput);const amountOut=Number.isFinite(numericResolved)?numericResolved.toString():String(rawResolvedOutput!==null&&rawResolvedOutput!==void 0?rawResolvedOutput:'0');return{receiptCid:(_ref4=(_swapResponse$command=swapResponse===null||swapResponse===void 0?void 0:swapResponse.commandId)!==null&&_swapResponse$command!==void 0?_swapResponse$command:swapResponse===null||swapResponse===void 0?void 0:swapResponse.outputTokenCid)!==null&&_ref4!==void 0?_ref4:'',trader:party,inputSymbol:params.inputSymbol,outputSymbol:params.outputSymbol,amountIn:params.inputAmount,amountOut,timestamp:new Date().toISOString()};}/**\n   * Get pool CID for a given pool ID\n   * Fetches pool CIDs from the backend and finds matching pool by ID\n   */async getPoolCidById(poolId){try{var _res$data3;// Get the party ID\nconst party=getPartyId()||DEVNET_PARTY;// Fetch all pools visible to this party\nconst res=await this.client.get('/api/clearportx/debug/party-acs',{params:{template:'AMM.Pool.Pool'},headers:{'X-Party':party}});const poolCids=((_res$data3=res.data)===null||_res$data3===void 0?void 0:_res$data3.cids)||[];console.log(\"Found \".concat(poolCids.length,\" pool CIDs for party, looking for poolId: \").concat(poolId));// For each pool CID, fetch details to find matching pool ID\nfor(const cid of poolCids){try{const poolRes=await this.client.get('/api/clearportx/debug/pool-by-cid',{params:{cid},headers:{'X-Party':party}});const poolData=poolRes.data;// Check if pool ID matches (partial match since frontend may have simplified IDs)\nif(poolData.success&&(poolData.poolId===poolId||poolData.poolId.includes(poolId)||poolId.includes(poolData.poolId))){console.log(\"Found matching pool by ID: \".concat(poolData.poolId,\" with CID: \").concat(cid));return cid;}}catch(error){console.error(\"Error fetching pool details for CID \".concat(cid,\":\"),error);}}// If not found by ID, try by symbols extracted from the pool ID\n// Pool IDs often have format like \"ETH-USDC-01\" or \"p0-gv-eth-usdc-225946\"\nconst symbols=poolId.toUpperCase().match(/([A-Z]+)-([A-Z]+)/);if(symbols&&symbols.length>=3){const symbolA=symbols[1];const symbolB=symbols[2];console.log(\"Trying to find pool by symbols: \".concat(symbolA,\"/\").concat(symbolB));return this.getPoolCidBySymbols(symbolA,symbolB);}console.warn(\"No pool found for poolId: \".concat(poolId));return null;}catch(error){console.error('Error fetching pool CID by ID:',error);return null;}}/**\n   * Add liquidity to a pool\n   */async addLiquidity(params){if(!this.hasJwt()){var _res$lpTokenCid,_res$lpAmount;const payload={poolId:params.poolId,amountA:params.amountA.toString(),amountB:params.amountB.toString(),minLPTokens:params.minLPTokens.toString()};console.log('Adding liquidity (auto-resolve pool) with:',payload);const res=await this.request(()=>this.client.post('/api/clearportx/debug/add-liquidity-by-cid',payload));return{lpTokenCid:(_res$lpTokenCid=res===null||res===void 0?void 0:res.lpTokenCid)!==null&&_res$lpTokenCid!==void 0?_res$lpTokenCid:'',lpAmount:(_res$lpAmount=res===null||res===void 0?void 0:res.lpAmount)!==null&&_res$lpAmount!==void 0?_res$lpAmount:params.minLPTokens,historyEntryId:res===null||res===void 0?void 0:res.historyEntryId};}const res=await this.client.post('/api/liquidity/add',params);return res.data;}/**\n   * Add liquidity by explicit pool CID (CID-first path)\n   */async addLiquidityByCid(params){var _res$lpTokenCid2,_res$lpAmount2;const party=this.currentParty();const poolId=params.poolId||'';const visibleCid=await this.ensurePoolCidVisible(params.poolCid,poolId,party);const body={poolCid:visibleCid,poolId,amountA:params.amountA,amountB:params.amountB,minLPTokens:params.minLPTokens};const res=await this.request(()=>this.client.post('/api/clearportx/debug/add-liquidity-by-cid',body));return{lpTokenCid:(_res$lpTokenCid2=res===null||res===void 0?void 0:res.lpTokenCid)!==null&&_res$lpTokenCid2!==void 0?_res$lpTokenCid2:'',lpAmount:(_res$lpAmount2=res===null||res===void 0?void 0:res.lpAmount)!==null&&_res$lpAmount2!==void 0?_res$lpAmount2:params.minLPTokens,historyEntryId:res===null||res===void 0?void 0:res.historyEntryId};}/**\n   * Remove liquidity from a pool\n   */async removeLiquidity(params){const res=await this.client.post('/api/liquidity/remove',params);return res.data;}/**\n   * Calculate swap quote (off-chain estimation)\n   * Use this to show estimated output before executing swap\n   */async calculateSwapQuote(params){// Bind the quote to the exact resolver-selected pool CID to avoid mismatch\nconst party=this.currentParty();const resolvedPoolId=params.poolId||\"\".concat(params.inputSymbol,\"-\").concat(params.outputSymbol);const{poolCid}=await this.resolveAndGrant(resolvedPoolId,party);const poolMeta=await this.request(()=>this.client.get('/api/clearportx/debug/pool-by-cid',{params:{cid:poolCid},headers:{'X-Party':party}}));if(!(poolMeta!==null&&poolMeta!==void 0&&poolMeta.success)){throw new Error('Pool not visible for party');}const symbolA=poolMeta.symbolA;const symbolB=poolMeta.symbolB;const reserveA=parseFloat(poolMeta.reserveA);const reserveB=parseFloat(poolMeta.reserveB);const isAtoB=params.inputSymbol===symbolA&&params.outputSymbol===symbolB;const isBtoA=params.inputSymbol===symbolB&&params.outputSymbol===symbolA;if(!isAtoB&&!isBtoA){throw new Error('Symbol mismatch for selected pool');}const inputAmount=parseFloat(params.inputAmount);// Choose reserves based on trade direction (input -> output)\nconst reserveIn=isAtoB?reserveA:reserveB;const reserveOut=isAtoB?reserveB:reserveA;const feeRate=0.003;// 0.30%\nconst feeBps=feeRate*10000;const feeAmount=inputAmount*feeBps/10000;const inputAfterFee=inputAmount-feeAmount;const outputAmount=inputAfterFee*reserveOut/(reserveIn+inputAfterFee);const priceBefore=reserveOut/reserveIn;const priceAfter=(reserveOut-outputAmount)/(reserveIn+inputAmount);const priceImpact=Math.abs((priceAfter-priceBefore)/priceBefore)*100;return{inputAmount,outputAmount,priceImpact,fee:feeAmount,route:[params.inputSymbol,params.outputSymbol],slippage:0.5};}// Helper: Generate idempotency key for swap\ngenerateIdempotencyKey(){return\"swap-\".concat(Date.now(),\"-\").concat(Math.random().toString(36).substr(2,9));}// Helper: Map backend pool DTO to frontend PoolInfo\nmapPool(data){var _ref5,_data$reserveA,_ref6,_data$reserveB,_ref7,_data$totalLPSupply,_data$feeRate,_data$volume24h;// Legacy mapper (kept for compatibility if called elsewhere)\nconst tokenA=data.tokenA||{symbol:data.symbolA,name:data.symbolA,decimals:10};const tokenB=data.tokenB||{symbol:data.symbolB,name:data.symbolB,decimals:10};const displayA=this.displaySymbol(tokenA.symbol);const displayB=this.displaySymbol(tokenB.symbol);return{contractId:data.poolId||data.contractId||'',poolId:data.poolId||data.contractId||'',tokenA:{symbol:displayA,name:displayA,decimals:tokenA.decimals,balance:0,contractId:'',logoUrl:this.getTokenLogo(displayA)},tokenB:{symbol:displayB,name:displayB,decimals:tokenB.decimals,balance:0,contractId:'',logoUrl:this.getTokenLogo(displayB)},reserveA:parseFloat((_ref5=(_data$reserveA=data.reserveA)!==null&&_data$reserveA!==void 0?_data$reserveA:data.reserveAmountA)!==null&&_ref5!==void 0?_ref5:0),reserveB:parseFloat((_ref6=(_data$reserveB=data.reserveB)!==null&&_data$reserveB!==void 0?_data$reserveB:data.reserveAmountB)!==null&&_ref6!==void 0?_ref6:0),totalLiquidity:parseFloat((_ref7=(_data$totalLPSupply=data.totalLPSupply)!==null&&_data$totalLPSupply!==void 0?_data$totalLPSupply:data.lpSupply)!==null&&_ref7!==void 0?_ref7:0),feeRate:(_data$feeRate=data.feeRate)!==null&&_data$feeRate!==void 0?_data$feeRate:data.feeBps?Number(data.feeBps)/10000:0.003,apr:0,volume24h:parseFloat((_data$volume24h=data.volume24h)!==null&&_data$volume24h!==void 0?_data$volume24h:0)};}mapHoldingPool(row){var _row$instrumentA,_row$instrumentB,_row$reserveAmountA,_row$reserveAmountB,_row$lpSupply;const symA=this.displaySymbol(((_row$instrumentA=row.instrumentA)===null||_row$instrumentA===void 0?void 0:_row$instrumentA.id)||'A');const symB=this.displaySymbol(((_row$instrumentB=row.instrumentB)===null||_row$instrumentB===void 0?void 0:_row$instrumentB.id)||'B');const tokenA={symbol:symA,name:symA,decimals:10};const tokenB={symbol:symB,name:symB,decimals:10};const feeRate=row.feeBps?Number(row.feeBps)/10000:0.003;return{contractId:row.contractId||'',poolId:row.contractId||'',tokenA:{symbol:tokenA.symbol,name:tokenA.name,decimals:tokenA.decimals,balance:0,contractId:'',logoUrl:this.getTokenLogo(tokenA.symbol)},tokenB:{symbol:tokenB.symbol,name:tokenB.name,decimals:tokenB.decimals,balance:0,contractId:'',logoUrl:this.getTokenLogo(tokenB.symbol)},reserveA:parseFloat((_row$reserveAmountA=row.reserveAmountA)!==null&&_row$reserveAmountA!==void 0?_row$reserveAmountA:0),reserveB:parseFloat((_row$reserveAmountB=row.reserveAmountB)!==null&&_row$reserveAmountB!==void 0?_row$reserveAmountB:0),totalLiquidity:parseFloat((_row$lpSupply=row.lpSupply)!==null&&_row$lpSupply!==void 0?_row$lpSupply:0),feeRate,apr:0,volume24h:0};}displaySymbol(symbol){return symbol==='Amulet'?'CC':symbol;}// Map party-scoped row to PoolInfo (row contains poolId, poolCid, symbolA/B, reserveA/B)\nmapPartyPool(row){const tokenA={symbol:row.symbolA,name:row.symbolA,decimals:10};const tokenB={symbol:row.symbolB,name:row.symbolB,decimals:10};return{// contractId keeps poolId for routing consistency in UI\ncontractId:row.poolId||'',poolId:row.poolId||'',tokenA:{symbol:tokenA.symbol,name:tokenA.name,decimals:tokenA.decimals,balance:0,contractId:'',logoUrl:this.getTokenLogo(tokenA.symbol)},tokenB:{symbol:tokenB.symbol,name:tokenB.name,decimals:tokenB.decimals,balance:0,contractId:'',logoUrl:this.getTokenLogo(tokenB.symbol)},reserveA:parseFloat(row.reserveA||'0'),reserveB:parseFloat(row.reserveB||'0'),totalLiquidity:parseFloat(row.totalLPSupply||row.totalLiquidity||'0'),feeRate:0.003,apr:0,volume24h:0};}// Helper: Map backend token DTO to frontend TokenInfo\nmapToken(data){return{symbol:data.symbol,name:data.name||data.symbol,decimals:data.decimals||10,balance:parseFloat(data.amount||data.quantity||'0'),contractId:data.contractId||'',logoUrl:this.getTokenLogo(data.symbol)};}aggregateTokensBySymbol(tokens){const tokenMap=new Map();for(const token of tokens){const existing=tokenMap.get(token.symbol);if(existing){existing.balance=(existing.balance||0)+(token.balance||0);}else{tokenMap.set(token.symbol,_objectSpread({},token));}}return Array.from(tokenMap.values()).sort((a,b)=>(b.balance||0)-(a.balance||0));}// Helper: Get token logo URL\ngetTokenLogo(symbol){var _symbol$toUpperCase,_process$env$PUBLIC_U;const upper=(symbol===null||symbol===void 0?void 0:(_symbol$toUpperCase=symbol.toUpperCase)===null||_symbol$toUpperCase===void 0?void 0:_symbol$toUpperCase.call(symbol))||symbol;const basePath=\"\".concat((_process$env$PUBLIC_U=process.env.PUBLIC_URL)!==null&&_process$env$PUBLIC_U!==void 0?_process$env$PUBLIC_U:'',\"/tokens\");const logos={CBTC:\"\".concat(basePath,\"/cbtc.png\"),CC:\"\".concat(basePath,\"/cc.svg\"),CANTON:\"\".concat(basePath,\"/cc.svg\"),ETH:'https://cryptologos.cc/logos/ethereum-eth-logo.png',USDC:'https://cryptologos.cc/logos/usd-coin-usdc-logo.png',BTC:'https://cryptologos.cc/logos/bitcoin-btc-logo.png',USDT:'https://cryptologos.cc/logos/tether-usdt-logo.png'};return logos[upper]||'';}async getTransactionHistory(){try{const res=await this.client.get('/api/transactions/recent',{params:{limit:1000}});const rows=Array.isArray(res.data)?res.data:[];if(!rows.length){return FALLBACK_TRANSACTIONS;}return rows.map(row=>this.normalizeTransactionHistoryEntry(row));}catch(error){console.warn('Falling back to demo transaction history payload:',error);return FALLBACK_TRANSACTIONS;}}normalizeTransactionHistoryEntry(entry){var _ref8,_entry$amountADesired,_entry$amountADesired2,_entry$amountA,_ref9,_entry$amountBDesired,_entry$amountBDesired2,_entry$amountB,_entry$minLpAmount$to,_entry$minLpAmount,_entry$minAmountLp,_entry$lpMintedAmount,_entry$lpMintedAmount2,_entry$lpMintedAmount3;const fallbackId=(entry===null||entry===void 0?void 0:entry.id)||(entry===null||entry===void 0?void 0:entry.transactionId)||\"tx-\".concat(Date.now());return{id:fallbackId,title:(entry===null||entry===void 0?void 0:entry.title)||this.inferTransactionTitle(entry===null||entry===void 0?void 0:entry.type),type:(entry===null||entry===void 0?void 0:entry.type)||'UNKNOWN',status:(entry===null||entry===void 0?void 0:entry.status)||'pending',createdAt:(entry===null||entry===void 0?void 0:entry.createdAt)||(entry===null||entry===void 0?void 0:entry.timestamp)||new Date().toISOString(),expiresAt:entry===null||entry===void 0?void 0:entry.expiresAt,tokenA:(entry===null||entry===void 0?void 0:entry.tokenA)||(entry===null||entry===void 0?void 0:entry.symbolA)||'',tokenB:(entry===null||entry===void 0?void 0:entry.tokenB)||(entry===null||entry===void 0?void 0:entry.symbolB)||'',amountADesired:(_ref8=(_entry$amountADesired=entry===null||entry===void 0?void 0:(_entry$amountADesired2=entry.amountADesired)===null||_entry$amountADesired2===void 0?void 0:_entry$amountADesired2.toString())!==null&&_entry$amountADesired!==void 0?_entry$amountADesired:entry===null||entry===void 0?void 0:(_entry$amountA=entry.amountA)===null||_entry$amountA===void 0?void 0:_entry$amountA.toString())!==null&&_ref8!==void 0?_ref8:'0',amountBDesired:(_ref9=(_entry$amountBDesired=entry===null||entry===void 0?void 0:(_entry$amountBDesired2=entry.amountBDesired)===null||_entry$amountBDesired2===void 0?void 0:_entry$amountBDesired2.toString())!==null&&_entry$amountBDesired!==void 0?_entry$amountBDesired:entry===null||entry===void 0?void 0:(_entry$amountB=entry.amountB)===null||_entry$amountB===void 0?void 0:_entry$amountB.toString())!==null&&_ref9!==void 0?_ref9:'0',minLpAmount:(_entry$minLpAmount$to=entry===null||entry===void 0?void 0:(_entry$minLpAmount=entry.minLpAmount)===null||_entry$minLpAmount===void 0?void 0:_entry$minLpAmount.toString())!==null&&_entry$minLpAmount$to!==void 0?_entry$minLpAmount$to:entry===null||entry===void 0?void 0:(_entry$minAmountLp=entry.minAmountLp)===null||_entry$minAmountLp===void 0?void 0:_entry$minAmountLp.toString(),lpTokenSymbol:entry===null||entry===void 0?void 0:entry.lpTokenSymbol,lpMintedAmount:(_entry$lpMintedAmount=entry===null||entry===void 0?void 0:(_entry$lpMintedAmount2=entry.lpMintedAmount)===null||_entry$lpMintedAmount2===void 0?void 0:(_entry$lpMintedAmount3=_entry$lpMintedAmount2.toString)===null||_entry$lpMintedAmount3===void 0?void 0:_entry$lpMintedAmount3.call(_entry$lpMintedAmount2))!==null&&_entry$lpMintedAmount!==void 0?_entry$lpMintedAmount:entry===null||entry===void 0?void 0:entry.lpMintedAmount,contractId:(entry===null||entry===void 0?void 0:entry.contractId)||(entry===null||entry===void 0?void 0:entry.cid)||'',eventTimeline:Array.isArray(entry===null||entry===void 0?void 0:entry.eventTimeline)&&(entry===null||entry===void 0?void 0:entry.eventTimeline.length)>0?entry.eventTimeline.map((item,index)=>({id:(item===null||item===void 0?void 0:item.id)||\"\".concat(fallbackId,\"-evt-\").concat(index),title:(item===null||item===void 0?void 0:item.title)||'Ledger Event',description:(item===null||item===void 0?void 0:item.description)||'',status:(item===null||item===void 0?void 0:item.status)||'completed',timestamp:item===null||item===void 0?void 0:item.timestamp})):[{id:\"\".concat(fallbackId,\"-evt-0\"),title:'Ledger Event',description:'Event recorded on Canton ledger.',status:'completed',timestamp:(entry===null||entry===void 0?void 0:entry.createdAt)||new Date().toISOString()}]};}inferTransactionTitle(type){switch(type){case'ADD_LIQUIDITY':return'AddLiquidity Transaction';case'SWAP':return'Swap Transaction';case'POOL_CREATION':return'Pool Creation Transaction';case'TOKEN_MINT':return'Token Mint Transaction';default:return'Ledger Transaction';}}/**\n   * Select a CBTC/Token Standard holding with polling support.\n   * Uses the backend's HoldingSelectorService for UTXO selection.\n   *\n   * @param params Selection criteria\n   * @returns Selected holding info or null if not found within timeout\n   */async selectHolding(params){try{var _params$timeoutSecond,_params$pollIntervalM,_data$amount;const body={ownerParty:params.ownerParty,instrumentAdmin:params.instrumentAdmin,instrumentId:params.instrumentId,minAmount:params.minAmount||\"0\",timeoutSeconds:(_params$timeoutSecond=params.timeoutSeconds)!==null&&_params$timeoutSecond!==void 0?_params$timeoutSecond:30,pollIntervalMs:(_params$pollIntervalM=params.pollIntervalMs)!==null&&_params$pollIntervalM!==void 0?_params$pollIntervalM:2000};console.log(\"[BackendApi] Selecting holding with params:\",body);const res=await this.client.post('/api/devnet/holdings/select',body);const data=res.data;console.log(\"[BackendApi] Holding selection result:\",data);return{found:data.found===true,holdingCid:data.holdingCid||null,instrumentAdmin:data.instrumentAdmin||null,instrumentId:data.instrumentId||null,amount:((_data$amount=data.amount)===null||_data$amount===void 0?void 0:_data$amount.toString())||null,owner:data.owner||null,attempts:data.attempts||1,elapsedMs:data.elapsedMs||0,error:data.error||null};}catch(error){var _error$response2,_error$response2$data;const message=(error===null||error===void 0?void 0:(_error$response2=error.response)===null||_error$response2===void 0?void 0:(_error$response2$data=_error$response2.data)===null||_error$response2$data===void 0?void 0:_error$response2$data.message)||(error===null||error===void 0?void 0:error.message)||String(error);console.error(\"[BackendApi] Holding selection failed:\",message);return{found:false,holdingCid:null,instrumentAdmin:null,instrumentId:null,amount:null,owner:null,attempts:1,elapsedMs:0,error:message};}}/**\n   * Get incoming CBTC TransferOffers for a receiver party.\n   * These are offers that can be accepted via Loop SDK.\n   */async getCbtcOffers(receiverParty){try{console.log(\"[BackendApi] Fetching CBTC offers for receiver:\",receiverParty);const res=await this.client.get('/api/devnet/cbtc/offers',{params:{receiverParty}});const offers=Array.isArray(res.data)?res.data:[];console.log(\"[BackendApi] Found \".concat(offers.length,\" CBTC offers\"));return offers.map(o=>{var _o$amount;return{contractId:o.contractId||\"\",sender:o.sender||\"\",receiver:o.receiver||\"\",amount:((_o$amount=o.amount)===null||_o$amount===void 0?void 0:_o$amount.toString())||\"0\",reason:o.reason||null,executeBefore:o.executeBefore||null,instrumentId:o.instrumentId||\"\",instrumentAdmin:o.instrumentAdmin||\"\",rawTemplateId:o.rawTemplateId||\"\",transferInstructionId:o.transferInstructionId||null,packageId:o.packageId||null};});}catch(error){console.error(\"[BackendApi] Failed to get CBTC offers:\",error);return[];}}/**\n   * Accept a CBTC offer via backend registry-powered acceptance.\n   */async acceptCbtcOffer(offerCid,actAsParty){try{const res=await this.client.post(\"/api/devnet/cbtc/offers/\".concat(offerCid,\"/accept\"),{actAsParty});return res.data;}catch(error){var _error$response3,_error$response3$data;const message=(error===null||error===void 0?void 0:(_error$response3=error.response)===null||_error$response3===void 0?void 0:(_error$response3$data=_error$response3.data)===null||_error$response3$data===void 0?void 0:_error$response3$data.message)||(error===null||error===void 0?void 0:error.message)||String(error);console.error(\"[BackendApi] CBTC accept failed:\",message);return{requestId:\"unknown\",offerCid,transferInstructionId:null,actAsParty:actAsParty||\"\",ok:false,classification:\"NETWORK\",rawError:message,hint:\"Backend accept endpoint failed\",ledgerUpdateId:null};}}/**\n   * Get CBTC holdings (UTXOs) for a party.\n   * Useful for discovering available CBTC before/after acceptance.\n   */async getCbtcHoldings(party){try{const encodedParty=encodeURIComponent(party);const res=await this.client.get(\"/api/holdings/\".concat(encodedParty,\"/utxos\"));const utxos=Array.isArray(res.data)?res.data:[];// Filter for CBTC holdings (instrumentId = \"CBTC\")\nreturn utxos.filter(u=>u.instrumentId===\"CBTC\").map(u=>{var _u$amount;return{contractId:u.contractId||\"\",instrumentAdmin:u.instrumentAdmin||\"\",instrumentId:u.instrumentId||\"\",amount:((_u$amount=u.amount)===null||_u$amount===void 0?void 0:_u$amount.toString())||\"0\",owner:u.owner||\"\"};});}catch(error){console.error(\"[BackendApi] Failed to get CBTC holdings:\",error);return[];}}async createDevnetPayout(instrument,payload){try{const res=await this.client.post(\"/api/devnet/payout/\".concat(instrument),payload);return res.data;}catch(error){var _error$response4,_data$error;const data=error===null||error===void 0?void 0:(_error$response4=error.response)===null||_error$response4===void 0?void 0:_error$response4.data;const message=(data===null||data===void 0?void 0:(_data$error=data.error)===null||_data$error===void 0?void 0:_data$error.message)||(error===null||error===void 0?void 0:error.message)||String(error);return data||{ok:false,error:{message}};}}async getHoldingUtxos(party){let ownerOnly=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;try{const encodedParty=encodeURIComponent(party);const res=await this.client.get(\"/api/holdings/\".concat(encodedParty,\"/utxos\"),{params:{ownerOnly}});return res.data;}catch(error){var _error$response5;const data=error===null||error===void 0?void 0:(_error$response5=error.response)===null||_error$response5===void 0?void 0:_error$response5.data;const message=(data===null||data===void 0?void 0:data.message)||(error===null||error===void 0?void 0:error.message)||String(error);return data||{ok:false,error:{message}};}}async getOutgoingTransferInstructions(params){try{const res=await this.client.get('/api/devnet/transfer-instructions/outgoing',{params});return res.data;}catch(error){var _error$response6,_data$error2;const data=error===null||error===void 0?void 0:(_error$response6=error.response)===null||_error$response6===void 0?void 0:_error$response6.data;const message=(data===null||data===void 0?void 0:(_data$error2=data.error)===null||_data$error2===void 0?void 0:_data$error2.message)||(error===null||error===void 0?void 0:error.message)||String(error);return data||{ok:false,error:{message}};}}async consumeDevnetSwap(payload){try{const res=await this.client.post('/api/devnet/swap/consume',payload);return res.data;}catch(error){var _error$response7,_data$error3;const data=error===null||error===void 0?void 0:(_error$response7=error.response)===null||_error$response7===void 0?void 0:_error$response7.data;const message=(data===null||data===void 0?void 0:(_data$error3=data.error)===null||_data$error3===void 0?void 0:_data$error3.message)||(error===null||error===void 0?void 0:error.message)||String(error);return data||{ok:false,error:{message}};}}async consumeDevnetLiquidity(payload){try{const res=await this.client.post('/api/devnet/liquidity/consume',payload);return res.data;}catch(error){var _error$response8,_data$error4;const data=error===null||error===void 0?void 0:(_error$response8=error.response)===null||_error$response8===void 0?void 0:_error$response8.data;const message=(data===null||data===void 0?void 0:(_data$error4=data.error)===null||_data$error4===void 0?void 0:_data$error4.message)||(error===null||error===void 0?void 0:error.message)||String(error);return data||{ok:false,error:{message}};}}async inspectDevnetLiquidity(requestId,poolCid){try{const res=await this.client.get('/api/devnet/liquidity/inspect',{params:poolCid?{requestId,poolCid}:{requestId}});return res.data;}catch(error){var _error$response9,_data$error5;const data=error===null||error===void 0?void 0:(_error$response9=error.response)===null||_error$response9===void 0?void 0:_error$response9.data;const message=(data===null||data===void 0?void 0:(_data$error5=data.error)===null||_data$error5===void 0?void 0:_data$error5.message)||(error===null||error===void 0?void 0:error.message)||String(error);return data||{ok:false,error:{message}};}}async getDevnetSwapTransferInstruction(requestId){try{const res=await this.client.get('/api/devnet/swap/transfer-instruction',{params:{requestId}});return res.data;}catch(error){var _error$response0,_data$error6;const data=error===null||error===void 0?void 0:(_error$response0=error.response)===null||_error$response0===void 0?void 0:_error$response0.data;const message=(data===null||data===void 0?void 0:(_data$error6=data.error)===null||_data$error6===void 0?void 0:_data$error6.message)||(error===null||error===void 0?void 0:error.message)||String(error);return data||{ok:false,error:{message}};}}async getDevnetSwapIntent(requestId){try{const res=await this.client.get('/api/devnet/swap/intent',{params:{requestId}});return res.data;}catch(error){var _error$response1,_data$error7;const data=error===null||error===void 0?void 0:(_error$response1=error.response)===null||_error$response1===void 0?void 0:_error$response1.data;const message=(data===null||data===void 0?void 0:(_data$error7=data.error)===null||_data$error7===void 0?void 0:_data$error7.message)||(error===null||error===void 0?void 0:error.message)||String(error);return data||{ok:false,error:{message}};}}async inspectDevnetSwap(requestId){try{const res=await this.client.get('/api/devnet/swap/inspect',{params:{requestId}});return res.data;}catch(error){var _error$response10,_data$error8;const data=error===null||error===void 0?void 0:(_error$response10=error.response)===null||_error$response10===void 0?void 0:_error$response10.data;const message=(data===null||data===void 0?void 0:(_data$error8=data.error)===null||_data$error8===void 0?void 0:_data$error8.message)||(error===null||error===void 0?void 0:error.message)||String(error);return data||{ok:false,error:{message}};}}}// Export singleton instance\nexport const backendApi=new BackendApiService();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}