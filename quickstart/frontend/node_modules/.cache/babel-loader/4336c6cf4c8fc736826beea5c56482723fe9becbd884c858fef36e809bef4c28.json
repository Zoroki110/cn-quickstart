{"ast":null,"code":"// @ts-check\n/**\n * @import {Acr, KeycloakAccountOptions, KeycloakAdapter, KeycloakConfig, KeycloakError, KeycloakFlow, KeycloakInitOptions, KeycloakLoginOptions, KeycloakLogoutOptions, KeycloakPkceMethod, KeycloakProfile, KeycloakRegisterOptions, KeycloakResourceAccess, KeycloakResponseMode, KeycloakResponseType, KeycloakRoles, KeycloakTokenParsed, OpenIdProviderMetadata} from \"./keycloak.ts\"\n */\n/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst CONTENT_TYPE_JSON = 'application/json';\n\n/**\n * @typedef {Object} Endpoints\n * @property {() => string} authorize\n * @property {() => string} token\n * @property {() => string} logout\n * @property {() => string} checkSessionIframe\n * @property {() => string=} thirdPartyCookiesIframe\n * @property {() => string} register\n * @property {() => string} userinfo\n */\n\n/**\n * @typedef {Object} LoginIframe\n * @property {boolean} enable\n * @property {((error: Error | null, value?: boolean) => void)[]} callbackList\n * @property {number} interval\n * @property {HTMLIFrameElement=} iframe\n * @property {string=} iframeOrigin\n */\n\nexport default class Keycloak {\n  /** @type {Pick<PromiseWithResolvers<boolean>, 'resolve' | 'reject'>[]} */\n  #refreshQueue = [];\n  /** @type {KeycloakAdapter} */\n  #adapter;\n  /** @type {boolean} */\n  #useNonce = true;\n  /** @type {CallbackStorage} */\n  #callbackStorage;\n  #logInfo = this.#createLogger(console.info);\n  #logWarn = this.#createLogger(console.warn);\n  /** @type {LoginIframe} */\n  #loginIframe = {\n    enable: true,\n    callbackList: [],\n    interval: 5\n  };\n\n  /** @type {KeycloakConfig} config */\n  #config;\n  didInitialize = false;\n  authenticated = false;\n  loginRequired = false;\n  /** @type {KeycloakResponseMode} */\n  responseMode = 'fragment';\n  /** @type {KeycloakResponseType} */\n  responseType = 'code';\n  /** @type {KeycloakFlow} */\n  flow = 'standard';\n  /** @type {number?} */\n  timeSkew = null;\n  /** @type {string=} */\n  redirectUri;\n  /** @type {string=} */\n  silentCheckSsoRedirectUri;\n  /** @type {boolean} */\n  silentCheckSsoFallback = true;\n  /** @type {KeycloakPkceMethod} */\n  pkceMethod = 'S256';\n  enableLogging = false;\n  /** @type {'GET' | 'POST'} */\n  logoutMethod = 'GET';\n  /** @type {string=} */\n  scope;\n  messageReceiveTimeout = 10000;\n  /** @type {string=} */\n  idToken;\n  /** @type {KeycloakTokenParsed=} */\n  idTokenParsed;\n  /** @type {string=} */\n  token;\n  /** @type {KeycloakTokenParsed=} */\n  tokenParsed;\n  /** @type {string=} */\n  refreshToken;\n  /** @type {KeycloakTokenParsed=} */\n  refreshTokenParsed;\n  /** @type {string=} */\n  clientId;\n  /** @type {string=} */\n  sessionId;\n  /** @type {string=} */\n  subject;\n  /** @type {string=} */\n  authServerUrl;\n  /** @type {string=} */\n  realm;\n  /** @type {KeycloakRoles=} */\n  realmAccess;\n  /** @type {KeycloakResourceAccess=} */\n  resourceAccess;\n  /** @type {KeycloakProfile=} */\n  profile;\n  /** @type {{}=} */\n  userInfo;\n  /** @type {Endpoints} */\n  endpoints;\n  /** @type {number=} */\n  tokenTimeoutHandle;\n  /** @type {() => void=} */\n  onAuthSuccess;\n  /** @type {(errorData?: KeycloakError) => void=} */\n  onAuthError;\n  /** @type {() => void=} */\n  onAuthRefreshSuccess;\n  /** @type {() => void=} */\n  onAuthRefreshError;\n  /** @type {() => void=} */\n  onTokenExpired;\n  /** @type {() => void=} */\n  onAuthLogout;\n  /** @type {(authenticated: boolean) => void=} */\n  onReady;\n  /** @type {(status: 'success' | 'cancelled' | 'error', action: string) => void=} */\n  onActionUpdate;\n\n  /**\n   * @param {KeycloakConfig} config\n   */\n  constructor(config) {\n    if (typeof config !== 'string' && !isObject(config)) {\n      throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\");\n    }\n    if (isObject(config)) {\n      const requiredProperties = 'oidcProvider' in config ? ['clientId'] : ['url', 'realm', 'clientId'];\n      for (const property of requiredProperties) {\n        if (!(property in config)) {\n          throw new Error(`The configuration object is missing the required '${property}' property.`);\n        }\n      }\n    }\n    if (!globalThis.isSecureContext) {\n      this.#logWarn(\"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\n\" + 'Continuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\n' + 'For more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts');\n    }\n    this.#config = config;\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<boolean>}\n   */\n  async init(initOptions = {}) {\n    if (this.didInitialize) {\n      throw new Error(\"A 'Keycloak' instance can only be initialized once.\");\n    }\n    this.didInitialize = true;\n    this.#callbackStorage = createCallbackStorage();\n    const adapters = ['default', 'cordova', 'cordova-native'];\n    if (typeof initOptions.adapter === 'string' && adapters.includes(initOptions.adapter)) {\n      this.#adapter = this.#loadAdapter(initOptions.adapter);\n    } else if (typeof initOptions.adapter === 'object') {\n      this.#adapter = initOptions.adapter;\n    } else if ('Cordova' in window || 'cordova' in window) {\n      this.#adapter = this.#loadAdapter('cordova');\n    } else {\n      this.#adapter = this.#loadAdapter('default');\n    }\n    if (typeof initOptions.useNonce !== 'undefined') {\n      this.#useNonce = initOptions.useNonce;\n    }\n    if (typeof initOptions.checkLoginIframe !== 'undefined') {\n      this.#loginIframe.enable = initOptions.checkLoginIframe;\n    }\n    if (initOptions.checkLoginIframeInterval) {\n      this.#loginIframe.interval = initOptions.checkLoginIframeInterval;\n    }\n    if (initOptions.onLoad === 'login-required') {\n      this.loginRequired = true;\n    }\n    if (initOptions.responseMode) {\n      if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') {\n        this.responseMode = initOptions.responseMode;\n      } else {\n        throw new Error('Invalid value for responseMode');\n      }\n    }\n    if (initOptions.flow) {\n      switch (initOptions.flow) {\n        case 'standard':\n          this.responseType = 'code';\n          break;\n        case 'implicit':\n          this.responseType = 'id_token token';\n          break;\n        case 'hybrid':\n          this.responseType = 'code id_token token';\n          break;\n        default:\n          throw new Error('Invalid value for flow');\n      }\n      this.flow = initOptions.flow;\n    }\n    if (typeof initOptions.timeSkew === 'number') {\n      this.timeSkew = initOptions.timeSkew;\n    }\n    if (initOptions.redirectUri) {\n      this.redirectUri = initOptions.redirectUri;\n    }\n    if (initOptions.silentCheckSsoRedirectUri) {\n      this.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri;\n    }\n    if (typeof initOptions.silentCheckSsoFallback === 'boolean') {\n      this.silentCheckSsoFallback = initOptions.silentCheckSsoFallback;\n    }\n    if (typeof initOptions.pkceMethod !== 'undefined') {\n      if (initOptions.pkceMethod !== 'S256' && initOptions.pkceMethod !== false) {\n        throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`);\n      }\n      this.pkceMethod = initOptions.pkceMethod;\n    }\n    if (typeof initOptions.enableLogging === 'boolean') {\n      this.enableLogging = initOptions.enableLogging;\n    }\n    if (initOptions.logoutMethod === 'POST') {\n      this.logoutMethod = 'POST';\n    }\n    if (typeof initOptions.scope === 'string') {\n      this.scope = initOptions.scope;\n    }\n    if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) {\n      this.messageReceiveTimeout = initOptions.messageReceiveTimeout;\n    }\n    await this.#loadConfig();\n    await this.#check3pCookiesSupported();\n    await this.#processInit(initOptions);\n    this.onReady?.(this.authenticated);\n    return this.authenticated;\n  }\n\n  /**\n   * @param {\"default\" | \"cordova\" | \"cordova-native\"} type\n   * @returns {KeycloakAdapter}\n   */\n  #loadAdapter(type) {\n    if (type === 'default') {\n      return this.#loadDefaultAdapter();\n    }\n    if (type === 'cordova') {\n      this.#loginIframe.enable = false;\n      return this.#loadCordovaAdapter();\n    }\n    if (type === 'cordova-native') {\n      this.#loginIframe.enable = false;\n      return this.#loadCordovaNativeAdapter();\n    }\n    throw new Error('invalid adapter type: ' + type);\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadDefaultAdapter() {\n    /** @type {KeycloakAdapter['redirectUri']}{} */\n    const redirectUri = options => {\n      return options?.redirectUri || this.redirectUri || globalThis.location.href;\n    };\n    return {\n      login: async options => {\n        window.location.assign(await this.createLoginUrl(options));\n        return await new Promise(() => {});\n      },\n      logout: async options => {\n        const logoutMethod = options?.logoutMethod ?? this.logoutMethod;\n        if (logoutMethod === 'GET') {\n          window.location.replace(this.createLogoutUrl(options));\n          return;\n        }\n\n        // Create form to send POST request.\n        const form = document.createElement('form');\n        form.setAttribute('method', 'POST');\n        form.setAttribute('action', this.createLogoutUrl(options));\n        form.style.display = 'none';\n\n        // Add data to form as hidden input fields.\n        const data = {\n          id_token_hint: this.idToken,\n          client_id: this.clientId,\n          post_logout_redirect_uri: redirectUri(options)\n        };\n        for (const [name, value] of Object.entries(data)) {\n          const input = document.createElement('input');\n          input.setAttribute('type', 'hidden');\n          input.setAttribute('name', name);\n          input.setAttribute('value', /** @type {string} */value);\n          form.appendChild(input);\n        }\n\n        // Append form to page and submit it to perform logout and redirect.\n        document.body.appendChild(form);\n        form.submit();\n      },\n      register: async options => {\n        window.location.assign(await this.createRegisterUrl(options));\n        return await new Promise(() => {});\n      },\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl();\n        if (typeof accountUrl !== 'undefined') {\n          window.location.href = accountUrl;\n        } else {\n          throw new Error('Not supported by the OIDC server');\n        }\n        return await new Promise(() => {});\n      },\n      redirectUri\n    };\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadCordovaAdapter() {\n    /**\n     * @param {string} loginUrl\n     * @param {string} target\n     * @param {string} options\n     * @returns {WindowProxy | null}\n     */\n    const cordovaOpenWindowWrapper = (loginUrl, target, options) => {\n      if (window.cordova && window.cordova.InAppBrowser) {\n        // Use inappbrowser for IOS and Android if available\n        return window.cordova.InAppBrowser.open(loginUrl, target, options);\n      } else {\n        return window.open(loginUrl, target, options);\n      }\n    };\n    const shallowCloneCordovaOptions = userOptions => {\n      if (userOptions && userOptions.cordovaOptions) {\n        return Object.keys(userOptions.cordovaOptions).reduce((options, optionName) => {\n          options[optionName] = userOptions.cordovaOptions[optionName];\n          return options;\n        }, {});\n      } else {\n        return {};\n      }\n    };\n    const formatCordovaOptions = cordovaOptions => {\n      return Object.keys(cordovaOptions).reduce((options, optionName) => {\n        options.push(optionName + '=' + cordovaOptions[optionName]);\n        return options;\n      }, []).join(',');\n    };\n    const createCordovaOptions = userOptions => {\n      const cordovaOptions = shallowCloneCordovaOptions(userOptions);\n      cordovaOptions.location = 'no';\n      if (userOptions && userOptions.prompt === 'none') {\n        cordovaOptions.hidden = 'yes';\n      }\n      return formatCordovaOptions(cordovaOptions);\n    };\n    const getCordovaRedirectUri = () => {\n      return this.redirectUri || 'http://localhost';\n    };\n    return {\n      login: async options => {\n        const cordovaOptions = createCordovaOptions(options);\n        const loginUrl = await this.createLoginUrl(options);\n        const ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions);\n        let completed = false;\n        let closed = false;\n        function closeBrowser() {\n          closed = true;\n          ref.close();\n        }\n        ;\n        return await new Promise((resolve, reject) => {\n          ref.addEventListener('loadstart', async event => {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              const callback = this.#parseCallback(event.url);\n              try {\n                await this.#processCallback(callback);\n                resolve();\n              } catch (error) {\n                reject(error);\n              }\n              closeBrowser();\n              completed = true;\n            }\n          });\n          ref.addEventListener('loaderror', async event => {\n            if (!completed) {\n              if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n                const callback = this.#parseCallback(event.url);\n                try {\n                  await this.#processCallback(callback);\n                  resolve();\n                } catch (error) {\n                  reject(error);\n                }\n                closeBrowser();\n                completed = true;\n              } else {\n                reject(new Error('Unable to process login.'));\n                closeBrowser();\n              }\n            }\n          });\n          ref.addEventListener('exit', function (event) {\n            if (!closed) {\n              reject(new Error('User closed the login window.'));\n            }\n          });\n        });\n      },\n      logout: async options => {\n        const logoutUrl = this.createLogoutUrl(options);\n        const ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes');\n        let error = false;\n        ref.addEventListener('loadstart', event => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close();\n          }\n        });\n        ref.addEventListener('loaderror', event => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close();\n          } else {\n            error = true;\n            ref.close();\n          }\n        });\n        await new Promise((resolve, reject) => {\n          ref.addEventListener('exit', () => {\n            if (error) {\n              reject(new Error('User closed the login window.'));\n            } else {\n              this.clearToken();\n              resolve();\n            }\n          });\n        });\n      },\n      register: async options => {\n        const registerUrl = await this.createRegisterUrl();\n        const cordovaOptions = createCordovaOptions(options);\n        const ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions);\n\n        /** @type {Promise<void>} */\n        const promise = new Promise((resolve, reject) => {\n          ref.addEventListener('loadstart', async event => {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              ref.close();\n              const oauth = this.#parseCallback(event.url);\n              try {\n                await this.#processCallback(oauth);\n                resolve();\n              } catch (error) {\n                reject(error);\n              }\n            }\n          });\n        });\n        await promise;\n      },\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl();\n        if (typeof accountUrl !== 'undefined') {\n          const ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no');\n          ref.addEventListener('loadstart', function (event) {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              ref.close();\n            }\n          });\n        } else {\n          throw new Error('Not supported by the OIDC server');\n        }\n      },\n      redirectUri: () => {\n        return getCordovaRedirectUri();\n      }\n    };\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadCordovaNativeAdapter() {\n    /* global universalLinks */\n    return {\n      login: async options => {\n        const loginUrl = await this.createLoginUrl(options);\n        await new Promise((resolve, reject) => {\n          universalLinks.subscribe('keycloak', async event => {\n            universalLinks.unsubscribe('keycloak');\n            window.cordova.plugins.browsertab.close();\n            const oauth = this.#parseCallback(event.url);\n            try {\n              await this.#processCallback(oauth);\n              resolve();\n            } catch (error) {\n              reject(error);\n            }\n          });\n          window.cordova.plugins.browsertab.openUrl(loginUrl);\n        });\n      },\n      logout: async options => {\n        const logoutUrl = this.createLogoutUrl(options);\n        await new Promise(resolve => {\n          universalLinks.subscribe('keycloak', () => {\n            universalLinks.unsubscribe('keycloak');\n            window.cordova.plugins.browsertab.close();\n            this.clearToken();\n            resolve();\n          });\n          window.cordova.plugins.browsertab.openUrl(logoutUrl);\n        });\n      },\n      register: async options => {\n        const registerUrl = await this.createRegisterUrl(options);\n        await new Promise((resolve, reject) => {\n          universalLinks.subscribe('keycloak', async event => {\n            universalLinks.unsubscribe('keycloak');\n            window.cordova.plugins.browsertab.close();\n            const oauth = this.#parseCallback(event.url);\n            try {\n              await this.#processCallback(oauth);\n              resolve();\n            } catch (error) {\n              reject(error);\n            }\n          });\n          window.cordova.plugins.browsertab.openUrl(registerUrl);\n        });\n      },\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl();\n        if (typeof accountUrl !== 'undefined') {\n          window.cordova.plugins.browsertab.openUrl(accountUrl);\n        } else {\n          throw new Error('Not supported by the OIDC server');\n        }\n      },\n      redirectUri: options => {\n        if (options && options.redirectUri) {\n          return options.redirectUri;\n        } else if (this.redirectUri) {\n          return this.redirectUri;\n        } else {\n          return 'http://localhost';\n        }\n      }\n    };\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #loadConfig() {\n    if (typeof this.#config === 'string') {\n      const jsonConfig = await fetchJsonConfig(this.#config);\n      this.authServerUrl = jsonConfig['auth-server-url'];\n      this.realm = jsonConfig.realm;\n      this.clientId = jsonConfig.resource;\n      this.#setupEndpoints();\n    } else {\n      this.clientId = this.#config.clientId;\n      if ('oidcProvider' in this.#config) {\n        await this.#loadOidcConfig(this.#config.oidcProvider);\n      } else {\n        this.authServerUrl = this.#config.url;\n        this.realm = this.#config.realm;\n        this.#setupEndpoints();\n      }\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  #setupEndpoints() {\n    this.endpoints = {\n      authorize: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/auth';\n      },\n      token: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/token';\n      },\n      logout: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/logout';\n      },\n      checkSessionIframe: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/login-status-iframe.html';\n      },\n      thirdPartyCookiesIframe: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/3p-cookies/step1.html';\n      },\n      register: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/registrations';\n      },\n      userinfo: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/userinfo';\n      }\n    };\n  }\n\n  /**\n   * @param {string | OpenIdProviderMetadata} oidcProvider\n   * @returns {Promise<void>}\n   */\n  async #loadOidcConfig(oidcProvider) {\n    if (typeof oidcProvider === 'string') {\n      const url = `${stripTrailingSlash(oidcProvider)}/.well-known/openid-configuration`;\n      const openIdConfig = await fetchOpenIdConfig(url);\n      this.#setupOidcEndpoints(openIdConfig);\n    } else {\n      this.#setupOidcEndpoints(oidcProvider);\n    }\n  }\n\n  /**\n   * @param {OpenIdProviderMetadata} config\n   * @returns {void}\n   */\n  #setupOidcEndpoints(config) {\n    this.endpoints = {\n      authorize() {\n        return config.authorization_endpoint;\n      },\n      token() {\n        return config.token_endpoint;\n      },\n      logout() {\n        if (!config.end_session_endpoint) {\n          throw new Error('Not supported by the OIDC server');\n        }\n        return config.end_session_endpoint;\n      },\n      checkSessionIframe() {\n        if (!config.check_session_iframe) {\n          throw new Error('Not supported by the OIDC server');\n        }\n        return config.check_session_iframe;\n      },\n      register() {\n        throw new Error('Redirection to \"Register user\" page not supported in standard OIDC mode');\n      },\n      userinfo() {\n        if (!config.userinfo_endpoint) {\n          throw new Error('Not supported by the OIDC server');\n        }\n        return config.userinfo_endpoint;\n      }\n    };\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #check3pCookiesSupported() {\n    if (!this.#loginIframe.enable && !this.silentCheckSsoRedirectUri || typeof this.endpoints.thirdPartyCookiesIframe !== 'function') {\n      return;\n    }\n    const iframe = document.createElement('iframe');\n    iframe.setAttribute('src', this.endpoints.thirdPartyCookiesIframe());\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n    iframe.setAttribute('title', 'keycloak-3p-check-iframe');\n    iframe.style.display = 'none';\n    document.body.appendChild(iframe);\n\n    /** @type {Promise<void>} */\n    const promise = new Promise(resolve => {\n      /**\n       * @param {MessageEvent} event\n       */\n      const messageCallback = event => {\n        if (iframe.contentWindow !== event.source) {\n          return;\n        }\n        if (event.data !== 'supported' && event.data !== 'unsupported') {\n          return;\n        } else if (event.data === 'unsupported') {\n          this.#logWarn('[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n' + ' - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n' + ' - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\n' + 'For more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers');\n          this.#loginIframe.enable = false;\n          if (this.silentCheckSsoFallback) {\n            this.silentCheckSsoRedirectUri = undefined;\n          }\n        }\n        document.body.removeChild(iframe);\n        window.removeEventListener('message', messageCallback);\n        resolve();\n      };\n      window.addEventListener('message', messageCallback, false);\n    });\n    return await applyTimeoutToPromise(promise, this.messageReceiveTimeout, 'Timeout when waiting for 3rd party check iframe message.');\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<void>}\n   */\n  async #processInit(initOptions) {\n    const callback = this.#parseCallback(window.location.href);\n    if (callback?.redirectUri) {\n      window.history.replaceState(window.history.state, '', callback.redirectUri);\n    }\n    if (callback && callback.valid) {\n      await this.#setupCheckLoginIframe();\n      await this.#processCallback(callback);\n      return;\n    }\n\n    /** @param {boolean} prompt */\n    const doLogin = async prompt => {\n      /** @type {KeycloakLoginOptions} */\n      const options = {};\n      if (!prompt) {\n        options.prompt = 'none';\n      }\n      if (initOptions.locale) {\n        options.locale = initOptions.locale;\n      }\n      await this.login(options);\n    };\n    const onLoad = async () => {\n      switch (initOptions.onLoad) {\n        case 'check-sso':\n          if (this.#loginIframe.enable) {\n            await this.#setupCheckLoginIframe();\n            const unchanged = await this.#checkLoginIframe();\n            if (!unchanged) {\n              this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false);\n            }\n          } else {\n            this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false);\n          }\n          break;\n        case 'login-required':\n          await doLogin(true);\n          break;\n        default:\n          throw new Error('Invalid value for onLoad');\n      }\n    };\n    if (initOptions.token && initOptions.refreshToken) {\n      this.#setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken);\n      if (this.#loginIframe.enable) {\n        await this.#setupCheckLoginIframe();\n        const unchanged = await this.#checkLoginIframe();\n        if (unchanged) {\n          this.onAuthSuccess?.();\n          this.#scheduleCheckIframe();\n        }\n      } else {\n        try {\n          await this.updateToken(-1);\n          this.onAuthSuccess?.();\n        } catch (error) {\n          this.onAuthError?.();\n          if (initOptions.onLoad) {\n            await onLoad();\n          } else {\n            throw error;\n          }\n        }\n      }\n    } else if (initOptions.onLoad) {\n      await onLoad();\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #setupCheckLoginIframe() {\n    if (!this.#loginIframe.enable || this.#loginIframe.iframe) {\n      return;\n    }\n    const iframe = document.createElement('iframe');\n    this.#loginIframe.iframe = iframe;\n    iframe.setAttribute('src', this.endpoints.checkSessionIframe());\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n    iframe.setAttribute('title', 'keycloak-session-iframe');\n    iframe.style.display = 'none';\n    document.body.appendChild(iframe);\n\n    /**\n     * @param {MessageEvent} event\n     */\n    const messageCallback = event => {\n      if (event.origin !== this.#loginIframe.iframeOrigin || this.#loginIframe.iframe?.contentWindow !== event.source) {\n        return;\n      }\n      if (!(event.data === 'unchanged' || event.data === 'changed' || event.data === 'error')) {\n        return;\n      }\n      if (event.data !== 'unchanged') {\n        this.clearToken();\n      }\n      const callbacks = this.#loginIframe.callbackList;\n      this.#loginIframe.callbackList = [];\n      for (const callback of callbacks.reverse()) {\n        if (event.data === 'error') {\n          callback(new Error('Error while checking login iframe'));\n        } else {\n          callback(null, event.data === 'unchanged');\n        }\n      }\n    };\n    window.addEventListener('message', messageCallback, false);\n\n    /** @type {Promise<void>} */\n    const promise = new Promise(resolve => {\n      iframe.addEventListener('load', () => {\n        const authUrl = this.endpoints.authorize();\n        if (authUrl.startsWith('/')) {\n          this.#loginIframe.iframeOrigin = globalThis.location.origin;\n        } else {\n          this.#loginIframe.iframeOrigin = new URL(authUrl).origin;\n        }\n        resolve();\n      });\n    });\n    await promise;\n  }\n\n  /**\n   * @returns {Promise<boolean | undefined>}\n   */\n  async #checkLoginIframe() {\n    if (!this.#loginIframe.iframe || !this.#loginIframe.iframeOrigin) {\n      return;\n    }\n    const message = `${this.clientId} ${this.sessionId ? this.sessionId : ''}`;\n    const origin = this.#loginIframe.iframeOrigin;\n\n    /** @type {Promise<boolean>} */\n    const promise = new Promise((resolve, reject) => {\n      /** @type {(error: Error | null, value?: boolean) => void} */\n      const callback = (error, result) => error ? reject(error) : resolve(/** @type {boolean} */result);\n      this.#loginIframe.callbackList.push(callback);\n      if (this.#loginIframe.callbackList.length === 1) {\n        this.#loginIframe.iframe?.contentWindow?.postMessage(message, origin);\n      }\n    });\n    return await promise;\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #checkSsoSilently() {\n    const iframe = document.createElement('iframe');\n    const src = await this.createLoginUrl({\n      prompt: 'none',\n      redirectUri: this.silentCheckSsoRedirectUri\n    });\n    iframe.setAttribute('src', src);\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n    iframe.setAttribute('title', 'keycloak-silent-check-sso');\n    iframe.style.display = 'none';\n    document.body.appendChild(iframe);\n    return await new Promise((resolve, reject) => {\n      /**\n       * @param {MessageEvent} event\n       */\n      const messageCallback = async event => {\n        if (event.origin !== window.location.origin || iframe.contentWindow !== event.source) {\n          return;\n        }\n        const oauth = this.#parseCallback(event.data);\n        try {\n          await this.#processCallback(oauth);\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n        document.body.removeChild(iframe);\n        window.removeEventListener('message', messageCallback);\n      };\n      window.addEventListener('message', messageCallback);\n    });\n  }\n  /**\n   * @param {string} url\n   */\n  #parseCallback(url) {\n    const oauth = this.#parseCallbackUrl(url);\n    if (!oauth) {\n      return;\n    }\n    const oauthState = this.#callbackStorage.get(oauth.state);\n    if (oauthState) {\n      oauth.valid = true;\n      oauth.redirectUri = oauthState.redirectUri;\n      oauth.storedNonce = oauthState.nonce;\n      oauth.prompt = oauthState.prompt;\n      oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;\n      oauth.loginOptions = oauthState.loginOptions;\n    }\n    return oauth;\n  }\n\n  /**\n   * @param {string} urlString\n   */\n  #parseCallbackUrl(urlString) {\n    let supportedParams = [];\n    switch (this.flow) {\n      case 'standard':\n        supportedParams = ['code', 'state', 'session_state', 'kc_action_status', 'kc_action', 'iss'];\n        break;\n      case 'implicit':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss'];\n        break;\n      case 'hybrid':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'code', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss'];\n        break;\n    }\n    supportedParams.push('error');\n    supportedParams.push('error_description');\n    supportedParams.push('error_uri');\n    const url = new URL(urlString);\n    let redirectUri = '';\n    let parsed;\n    if (this.responseMode === 'query' && url.searchParams.size > 0) {\n      parsed = this.#parseCallbackParams(url.search, supportedParams);\n      url.search = parsed.paramsString;\n      redirectUri = url.toString();\n    } else if (this.responseMode === 'fragment' && url.hash.length > 0) {\n      parsed = this.#parseCallbackParams(url.hash.substring(1), supportedParams);\n      url.hash = '';\n      redirectUri = url.toString();\n    }\n    if (parsed?.oauthParams) {\n      if (this.flow === 'standard' || this.flow === 'hybrid') {\n        if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.redirectUri = redirectUri;\n          return parsed.oauthParams;\n        }\n      } else if (this.flow === 'implicit') {\n        if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.redirectUri = redirectUri;\n          return parsed.oauthParams;\n        }\n      }\n    }\n  }\n\n  /**\n   * @typedef {Object} ParsedCallbackParams\n   * @property {string} paramsString\n   * @property {Record<string, string | undefined>} oauthParams\n   */\n\n  /**\n   * @param {string} paramsString\n   * @param {string[]} supportedParams\n   * @returns {ParsedCallbackParams}\n   */\n  #parseCallbackParams(paramsString, supportedParams) {\n    const params = new URLSearchParams(paramsString);\n    /** @type {Record<string, string>} */\n    const oauthParams = {};\n    for (const [key, value] of Array.from(params.entries())) {\n      if (supportedParams.includes(key)) {\n        oauthParams[key] = value;\n        params.delete(key);\n      }\n    }\n    return {\n      paramsString: params.toString(),\n      oauthParams\n    };\n  }\n  async #processCallback(oauth) {\n    const {\n      code,\n      error,\n      prompt\n    } = oauth;\n    let timeLocal = new Date().getTime();\n\n    /**\n     * @param {string} accessToken\n     * @param {string=} refreshToken\n     * @param {string=} idToken\n     */\n    const authSuccess = (accessToken, refreshToken, idToken) => {\n      timeLocal = (timeLocal + new Date().getTime()) / 2;\n      this.#setToken(accessToken, refreshToken, idToken, timeLocal);\n      if (this.#useNonce && this.idTokenParsed && this.idTokenParsed.nonce !== oauth.storedNonce) {\n        this.#logInfo('[KEYCLOAK] Invalid nonce, clearing token');\n        this.clearToken();\n        throw new Error('Invalid nonce.');\n      }\n    };\n    if (oauth.kc_action_status) {\n      this.onActionUpdate && this.onActionUpdate(oauth.kc_action_status, oauth.kc_action);\n    }\n    if (error) {\n      if (prompt !== 'none') {\n        if (oauth.error_description && oauth.error_description === 'authentication_expired') {\n          await this.login(oauth.loginOptions);\n        } else {\n          const errorData = {\n            error,\n            error_description: oauth.error_description\n          };\n          this.onAuthError?.(errorData);\n          throw errorData;\n        }\n      }\n      return;\n    } else if (this.flow !== 'standard' && (oauth.access_token || oauth.id_token)) {\n      authSuccess(oauth.access_token, undefined, oauth.id_token);\n      this.onAuthSuccess?.();\n    }\n    if (this.flow !== 'implicit' && code) {\n      try {\n        const response = await fetchAccessToken(this.endpoints.token(), code, /** @type {string} */this.clientId, oauth.redirectUri, oauth.pkceCodeVerifier);\n        authSuccess(response.access_token, response.refresh_token, response.id_token);\n        if (this.flow === 'standard') {\n          this.onAuthSuccess?.();\n        }\n        this.#scheduleCheckIframe();\n      } catch (error) {\n        this.onAuthError?.();\n        throw error;\n      }\n    }\n  }\n  async #scheduleCheckIframe() {\n    if (this.#loginIframe.enable && this.token) {\n      await waitForTimeout(this.#loginIframe.interval * 1000);\n      const unchanged = await this.#checkLoginIframe();\n      if (unchanged) {\n        await this.#scheduleCheckIframe();\n      }\n    }\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<void>}\n   */\n  login(options) {\n    return this.#adapter.login(options);\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<string>}\n   */\n  async createLoginUrl(options) {\n    const state = createUUID();\n    const nonce = createUUID();\n    const redirectUri = this.#adapter.redirectUri(options);\n    /** @type {CallbackState} */\n    const callbackState = {\n      state,\n      nonce,\n      redirectUri,\n      loginOptions: options\n    };\n    if (options?.prompt) {\n      callbackState.prompt = options.prompt;\n    }\n    const url = options?.action === 'register' ? this.endpoints.register() : this.endpoints.authorize();\n    let scope = options?.scope || this.scope;\n    const scopeValues = scope ? scope.split(' ') : [];\n\n    // Ensure the 'openid' scope is always included.\n    if (!scopeValues.includes('openid')) {\n      scopeValues.unshift('openid');\n    }\n    scope = scopeValues.join(' ');\n    const params = new URLSearchParams([['client_id', (/** @type {string} */this.clientId)],\n    // The endpoint URI MUST NOT include a fragment component.\n    // https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2\n    ['redirect_uri', stripHash(redirectUri)], ['state', state], ['response_mode', this.responseMode], ['response_type', this.responseType], ['scope', scope]]);\n    if (this.#useNonce) {\n      params.append('nonce', nonce);\n    }\n    if (options?.prompt) {\n      params.append('prompt', options.prompt);\n    }\n    if (typeof options?.maxAge === 'number') {\n      params.append('max_age', options.maxAge.toString());\n    }\n    if (options?.loginHint) {\n      params.append('login_hint', options.loginHint);\n    }\n    if (options?.idpHint) {\n      params.append('kc_idp_hint', options.idpHint);\n    }\n    if (options?.action && options.action !== 'register') {\n      params.append('kc_action', options.action);\n    }\n    if (options?.locale) {\n      params.append('ui_locales', options.locale);\n    }\n    if (options?.acr) {\n      params.append('claims', buildClaimsParameter(options.acr));\n    }\n    if (options?.acrValues) {\n      params.append('acr_values', options.acrValues);\n    }\n    if (this.pkceMethod) {\n      try {\n        const codeVerifier = generateCodeVerifier(96);\n        const pkceChallenge = await generatePkceChallenge(this.pkceMethod, codeVerifier);\n        callbackState.pkceCodeVerifier = codeVerifier;\n        params.append('code_challenge', pkceChallenge);\n        params.append('code_challenge_method', this.pkceMethod);\n      } catch (error) {\n        throw new Error('Failed to generate PKCE challenge.', {\n          cause: error\n        });\n      }\n    }\n    this.#callbackStorage.add(callbackState);\n    return `${url}?${params.toString()}`;\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {Promise<void>}\n   */\n  logout(options) {\n    return this.#adapter.logout(options);\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {string}\n   */\n  createLogoutUrl(options) {\n    const logoutMethod = options?.logoutMethod ?? this.logoutMethod;\n    const url = this.endpoints.logout();\n    if (logoutMethod === 'POST') {\n      return url;\n    }\n    const params = new URLSearchParams([['client_id', (/** @type {string} */this.clientId)], ['post_logout_redirect_uri', this.#adapter.redirectUri(options)]]);\n    if (this.idToken) {\n      params.append('id_token_hint', this.idToken);\n    }\n    return `${url}?${params.toString()}`;\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<void>}\n   */\n  register(options) {\n    return this.#adapter.register(options);\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<string>}\n   */\n  createRegisterUrl(options) {\n    return this.createLoginUrl({\n      ...options,\n      action: 'register'\n    });\n  }\n\n  /**\n   * @param {KeycloakAccountOptions} [options]\n   * @returns {string}\n   */\n  createAccountUrl(options) {\n    const url = this.#getRealmUrl();\n    if (!url) {\n      throw new Error('Unable to create account URL, make sure the adapter is not configured using a generic OIDC provider.');\n    }\n    const params = new URLSearchParams([['referrer', (/** @type {string} */this.clientId)], ['referrer_uri', this.#adapter.redirectUri(options)]]);\n    return `${url}/account?${params.toString()}`;\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  accountManagement() {\n    return this.#adapter.accountManagement();\n  }\n\n  /**\n   * @param {string} role\n   * @returns {boolean}\n   */\n  hasRealmRole(role) {\n    const access = this.realmAccess;\n    return !!access && access.roles.indexOf(role) >= 0;\n  }\n\n  /**\n   * @param {string} role\n   * @param {string} [resource]\n   * @returns {boolean}\n   */\n  hasResourceRole(role, resource) {\n    if (!this.resourceAccess) {\n      return false;\n    }\n    const access = this.resourceAccess[resource || (/** @type {string} */this.clientId)];\n    return !!access && access.roles.indexOf(role) >= 0;\n  }\n\n  /**\n   * @returns {Promise<KeycloakProfile>}\n   */\n  async loadUserProfile() {\n    const realmUrl = this.#getRealmUrl();\n    if (!realmUrl) {\n      throw new Error('Unable to load user profile, make sure the adapter is not configured using a generic OIDC provider.');\n    }\n    const url = `${realmUrl}/account`;\n    /** @type {KeycloakProfile} */\n    const profile = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    });\n    return this.profile = profile;\n  }\n\n  /**\n   * @returns {Promise<{}>}\n   */\n  async loadUserInfo() {\n    const url = this.endpoints.userinfo();\n    /** @type {{}} */\n    const userInfo = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    });\n    return this.userInfo = userInfo;\n  }\n\n  /**\n   * @param {number} [minValidity]\n   * @returns {boolean}\n   */\n  isTokenExpired(minValidity) {\n    if (!this.tokenParsed || !this.refreshToken && this.flow !== 'implicit') {\n      throw new Error('Not authenticated');\n    }\n    if (this.timeSkew == null) {\n      this.#logInfo('[KEYCLOAK] Unable to determine if token is expired as timeskew is not set');\n      return true;\n    }\n    if (typeof this.tokenParsed.exp !== 'number') {\n      return false;\n    }\n    let expiresIn = this.tokenParsed.exp - Math.ceil(new Date().getTime() / 1000) + this.timeSkew;\n    if (minValidity) {\n      if (isNaN(minValidity)) {\n        throw new Error('Invalid minValidity');\n      }\n      expiresIn -= minValidity;\n    }\n    return expiresIn < 0;\n  }\n\n  /**\n   * @param {number} minValidity\n   * @returns {Promise<boolean>}\n   */\n  async updateToken(minValidity) {\n    if (!this.refreshToken) {\n      throw new Error('Unable to update token, no refresh token available.');\n    }\n    minValidity = minValidity || 5;\n    if (this.#loginIframe.enable) {\n      await this.#checkLoginIframe();\n    }\n    let refreshToken = false;\n    if (minValidity === -1) {\n      refreshToken = true;\n      this.#logInfo('[KEYCLOAK] Refreshing token: forced refresh');\n    } else if (!this.tokenParsed || this.isTokenExpired(minValidity)) {\n      refreshToken = true;\n      this.#logInfo('[KEYCLOAK] Refreshing token: token expired');\n    }\n    if (!refreshToken) {\n      return false;\n    }\n\n    /** @type {PromiseWithResolvers<boolean>} */\n    const {\n      promise,\n      resolve,\n      reject\n    } = Promise.withResolvers();\n    this.#refreshQueue.push({\n      resolve,\n      reject\n    });\n    if (this.#refreshQueue.length === 1) {\n      const url = this.endpoints.token();\n      let timeLocal = new Date().getTime();\n      try {\n        const response = await fetchRefreshToken(url, this.refreshToken, /** @type {string} */this.clientId);\n        this.#logInfo('[KEYCLOAK] Token refreshed');\n        timeLocal = (timeLocal + new Date().getTime()) / 2;\n        this.#setToken(response.access_token, response.refresh_token, response.id_token, timeLocal);\n        this.onAuthRefreshSuccess?.();\n        for (let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop()) {\n          p.resolve(true);\n        }\n      } catch (error) {\n        this.#logWarn('[KEYCLOAK] Failed to refresh token');\n        if (error instanceof NetworkError && error.response.status === 400) {\n          this.clearToken();\n        }\n        this.onAuthRefreshError?.();\n        for (let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop()) {\n          p.reject(error);\n        }\n      }\n    }\n    return await promise;\n  }\n  clearToken() {\n    if (this.token) {\n      this.#setToken();\n      this.onAuthLogout?.();\n      if (this.loginRequired) {\n        this.login();\n      }\n    }\n  }\n\n  /**\n   * @param {string} [token]\n   * @param {string} [refreshToken]\n   * @param {string} [idToken]\n   * @param {number} [timeLocal]\n   */\n  #setToken(token, refreshToken, idToken, timeLocal) {\n    if (this.tokenTimeoutHandle) {\n      clearTimeout(this.tokenTimeoutHandle);\n      this.tokenTimeoutHandle = undefined;\n    }\n    if (refreshToken) {\n      this.refreshToken = refreshToken;\n      this.refreshTokenParsed = decodeToken(refreshToken);\n    } else {\n      delete this.refreshToken;\n      delete this.refreshTokenParsed;\n    }\n    if (idToken) {\n      this.idToken = idToken;\n      this.idTokenParsed = decodeToken(idToken);\n    } else {\n      delete this.idToken;\n      delete this.idTokenParsed;\n    }\n    if (token) {\n      this.token = token;\n      this.tokenParsed = decodeToken(token);\n      this.sessionId = this.tokenParsed.sid;\n      this.authenticated = true;\n      this.subject = this.tokenParsed.sub;\n      this.realmAccess = this.tokenParsed.realm_access;\n      this.resourceAccess = this.tokenParsed.resource_access;\n      if (timeLocal) {\n        this.timeSkew = Math.floor(timeLocal / 1000) - this.tokenParsed.iat;\n      }\n      if (this.timeSkew !== null) {\n        this.#logInfo('[KEYCLOAK] Estimated time difference between browser and server is ' + this.timeSkew + ' seconds');\n        if (this.onTokenExpired) {\n          const expiresIn = (this.tokenParsed.exp - new Date().getTime() / 1000 + this.timeSkew) * 1000;\n          this.#logInfo('[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s');\n          if (expiresIn <= 0) {\n            this.onTokenExpired();\n          } else {\n            this.tokenTimeoutHandle = window.setTimeout(this.onTokenExpired, expiresIn);\n          }\n        }\n      }\n    } else {\n      delete this.token;\n      delete this.tokenParsed;\n      delete this.subject;\n      delete this.realmAccess;\n      delete this.resourceAccess;\n      this.authenticated = false;\n    }\n  }\n\n  /**\n   * @returns {string=}\n   */\n  #getRealmUrl() {\n    if (typeof this.authServerUrl === 'undefined') {\n      return;\n    }\n    return `${stripTrailingSlash(this.authServerUrl)}/realms/${encodeURIComponent(/** @type {string} */this.realm)}`;\n  }\n\n  /**\n   * @param {Function} fn\n   * @returns {(message: string) => void}\n   */\n  #createLogger(fn) {\n    return message => {\n      if (this.enableLogging) {\n        fn.call(console, message);\n      }\n    };\n  }\n}\n\n/**\n * @returns {string}\n */\nfunction createUUID() {\n  if (typeof crypto === 'undefined' || typeof crypto.randomUUID === 'undefined') {\n    throw new Error('Web Crypto API is not available.');\n  }\n  return crypto.randomUUID();\n}\n\n/**\n * @param {Acr} requestedAcr\n * @returns {string}\n */\nfunction buildClaimsParameter(requestedAcr) {\n  return JSON.stringify({\n    id_token: {\n      acr: requestedAcr\n    }\n  });\n}\n\n/**\n * @param {number} len\n * @returns {string}\n */\nfunction generateCodeVerifier(len) {\n  return generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n}\n\n/**\n * @param {string} pkceMethod\n * @param {string} codeVerifier\n * @returns {Promise<string>}\n */\nasync function generatePkceChallenge(pkceMethod, codeVerifier) {\n  if (pkceMethod !== 'S256') {\n    throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`);\n  }\n\n  // hash codeVerifier, then encode as url-safe base64 without padding\n  const hashBytes = new Uint8Array(await sha256Digest(codeVerifier));\n  const encodedHash = bytesToBase64(hashBytes).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  return encodedHash;\n}\n\n/**\n * @param {number} len\n * @param {string} alphabet\n * @returns {string}\n */\nfunction generateRandomString(len, alphabet) {\n  const randomData = generateRandomData(len);\n  const chars = new Array(len);\n  for (let i = 0; i < len; i++) {\n    chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);\n  }\n  return String.fromCharCode.apply(null, chars);\n}\n\n/**\n * @param {number} len\n * @returns {Uint8Array<ArrayBuffer>}\n */\nfunction generateRandomData(len) {\n  if (typeof crypto === 'undefined' || typeof crypto.getRandomValues === 'undefined') {\n    throw new Error('Web Crypto API is not available.');\n  }\n  return crypto.getRandomValues(new Uint8Array(len));\n}\n\n/**\n * Function to extend existing native Promise with timeout\n *\n * @template T\n * @param {Promise<T>} promise\n * @param {number} timeout\n * @param {string} errorMessage\n * @returns {Promise<T>}\n */\nfunction applyTimeoutToPromise(promise, timeout, errorMessage) {\n  /** @type {number} */\n  let timeoutHandle;\n  const timeoutPromise = new Promise(function (resolve, reject) {\n    timeoutHandle = window.setTimeout(function () {\n      reject(new Error(errorMessage || 'Promise is not settled within timeout of ' + timeout + 'ms'));\n    }, timeout);\n  });\n  return Promise.race([promise, timeoutPromise]).finally(function () {\n    clearTimeout(timeoutHandle);\n  });\n}\n\n/**\n * @returns {CallbackStorage}\n */\nfunction createCallbackStorage() {\n  try {\n    return new LocalStorage();\n  } catch (err) {\n    return new CookieStorage();\n  }\n}\nconst STORAGE_KEY_PREFIX = 'kc-callback-';\n\n/**\n * @typedef {Object} CallbackState\n * @property {string} state\n * @property {string} nonce\n * @property {string} redirectUri\n * @property {KeycloakLoginOptions} [loginOptions]\n * @property {KeycloakLoginOptions['prompt']} [prompt]\n * @property {string} [pkceCodeVerifier]\n */\n\n/**\n * @typedef {Object} CallbackStorage\n * @property {(state?: string) => CallbackState | null} get\n * @property {(state: CallbackState) => void} add\n */\n\n/**\n * @implements {CallbackStorage}\n */\nclass LocalStorage {\n  constructor() {\n    globalThis.localStorage.setItem('kc-test', 'test');\n    globalThis.localStorage.removeItem('kc-test');\n  }\n\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get(state) {\n    if (!state) {\n      return null;\n    }\n    this.#clearInvalidValues();\n    const key = STORAGE_KEY_PREFIX + state;\n    const value = globalThis.localStorage.getItem(key);\n    if (value) {\n      globalThis.localStorage.removeItem(key);\n      return JSON.parse(value);\n    }\n    return null;\n  }\n  /**\n   * @param {CallbackState} state\n   */\n  add(state) {\n    this.#clearInvalidValues();\n    const key = STORAGE_KEY_PREFIX + state.state;\n    const value = JSON.stringify({\n      ...state,\n      // Set the expiry time to 1 hour from now.\n      expires: Date.now() + 60 * 60 * 1000\n    });\n    try {\n      globalThis.localStorage.setItem(key, value);\n    } catch (error) {\n      // If the storage is full, clear all known values and try again.\n      this.#clearAllValues();\n      globalThis.localStorage.setItem(key, value);\n    }\n  }\n  /**\n   * Clears all values from local storage that are no longer valid.\n   */\n  #clearInvalidValues() {\n    const currentTime = Date.now();\n    for (const [key, value] of this.#getStoredEntries()) {\n      // Attempt to parse the expiry time from the value.\n      const expiry = this.#parseExpiry(value);\n\n      // Discard the value if it is malformed or expired.\n      if (expiry === null || expiry < currentTime) {\n        globalThis.localStorage.removeItem(key);\n      }\n    }\n  }\n\n  /**\n   * Clears all known values from local storage.\n   */\n  #clearAllValues() {\n    for (const [key] of this.#getStoredEntries()) {\n      globalThis.localStorage.removeItem(key);\n    }\n  }\n\n  /**\n   * Gets all entries stored in local storage that are known to be managed by this class.\n   * @returns {[string, string][]} An array of key-value pairs.\n   */\n  #getStoredEntries() {\n    return Object.entries(globalThis.localStorage).filter(([key]) => key.startsWith(STORAGE_KEY_PREFIX));\n  }\n\n  /**\n   * Parses the expiry time from a value stored in local storage.\n   * @param {string} value\n   * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n   */\n  #parseExpiry(value) {\n    let parsedValue;\n\n    // Attempt to parse the value as JSON.\n    try {\n      parsedValue = JSON.parse(value);\n    } catch (error) {\n      return null;\n    }\n\n    // Attempt to extract the 'expires' property.\n    if (isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') {\n      return parsedValue.expires;\n    }\n    return null;\n  }\n}\n\n/**\n * @implements {CallbackStorage}\n */\nclass CookieStorage {\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get(state) {\n    if (!state) {\n      return null;\n    }\n    const value = this.#getCookie(STORAGE_KEY_PREFIX + state);\n    this.#setCookie(STORAGE_KEY_PREFIX + state, '', this.#cookieExpiration(-100));\n    if (value) {\n      return JSON.parse(value);\n    }\n    return null;\n  }\n\n  /**\n   * @param {CallbackState} state\n   */\n  add(state) {\n    this.#setCookie(STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), this.#cookieExpiration(60));\n  }\n\n  /**\n   * @param {string} key\n   * @returns\n   */\n  #getCookie(key) {\n    const name = key + '=';\n    const ca = document.cookie.split(';');\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1);\n      }\n      if (c.indexOf(name) === 0) {\n        return c.substring(name.length, c.length);\n      }\n    }\n    return '';\n  }\n\n  /**\n   * @param {string} key\n   * @param {string} value\n   * @param {Date} expirationDate\n   */\n  #setCookie(key, value, expirationDate) {\n    const cookie = key + '=' + value + '; ' + 'expires=' + expirationDate.toUTCString() + '; ';\n    document.cookie = cookie;\n  }\n\n  /**\n   * @param {number} minutes\n   * @returns {Date}\n   */\n  #cookieExpiration(minutes) {\n    const exp = new Date();\n    exp.setTime(exp.getTime() + minutes * 60 * 1000);\n    return exp;\n  }\n}\n\n/**\n * @param {Uint8Array<ArrayBuffer>} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */\nfunction bytesToBase64(bytes) {\n  const binString = String.fromCodePoint(...bytes);\n  return btoa(binString);\n}\n\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */\nasync function sha256Digest(message) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  if (typeof crypto === 'undefined' || typeof crypto.subtle === 'undefined') {\n    throw new Error('Web Crypto API is not available.');\n  }\n  return await crypto.subtle.digest('SHA-256', data);\n}\n\n/**\n * @param {string} token\n * @returns {KeycloakTokenParsed}\n */\nfunction decodeToken(token) {\n  const [, payload] = token.split('.');\n  if (typeof payload !== 'string') {\n    throw new Error('Unable to decode token, payload not found.');\n  }\n  let decoded;\n  try {\n    decoded = base64UrlDecode(payload);\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid Base64URL value.', {\n      cause: error\n    });\n  }\n  try {\n    return JSON.parse(decoded);\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid JSON value.', {\n      cause: error\n    });\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction base64UrlDecode(input) {\n  let output = input.replaceAll('-', '+').replaceAll('_', '/');\n  switch (output.length % 4) {\n    case 0:\n      break;\n    case 2:\n      output += '==';\n      break;\n    case 3:\n      output += '=';\n      break;\n    default:\n      throw new Error('Input is not of the correct length.');\n  }\n  try {\n    return b64DecodeUnicode(output);\n  } catch (error) {\n    return atob(output);\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction b64DecodeUnicode(input) {\n  return decodeURIComponent(atob(input).replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase();\n    if (code.length < 2) {\n      code = '0' + code;\n    }\n    return '%' + code;\n  }));\n}\n\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */\nfunction isObject(input) {\n  return typeof input === 'object' && input !== null;\n}\n\n/**\n * @typedef {Object} JsonConfig The JSON version of the adapter configuration.\n * @property {string} auth-server-url The URL of the authentication server.\n * @property {string} realm The name of the realm.\n * @property {string} resource The name of the resource, usually the client ID.\n */\n\n/**\n * Fetch the adapter configuration from the given URL.\n * @param {string} url\n * @returns {Promise<JsonConfig>}\n */\nasync function fetchJsonConfig(url) {\n  return await fetchJSON(url);\n}\n\n/**\n * Fetch the OpenID configuration from the given URL.\n * @param {string} url\n * @returns {Promise<OpenIdProviderMetadata>}\n */\nasync function fetchOpenIdConfig(url) {\n  return await fetchJSON(url);\n}\n\n/**\n * @typedef {Object} AccessTokenResponse The successful token response from the authorization server, based on the {@link https://datatracker.ietf.org/doc/html/rfc6749#section-5.1 OAuth 2.0 Authorization Framework specification}.\n * @property {string} access_token The access token issued by the authorization server.\n * @property {string} token_type The type of the token issued by the authorization server.\n * @property {number} [expires_in] The lifetime in seconds of the access token.\n * @property {string} [refresh_token] The refresh token issued by the authorization server.\n * @property {string} [id_token] The ID token issued by the authorization server, if requested.\n * @property {string} [scope] The scope of the access token.\n */\n\n/**\n * Fetch the access token from the given URL.\n * @param {string} url\n * @param {string} code\n * @param {string} clientId\n * @param {string} redirectUri\n * @param {string} [pkceCodeVerifier]\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchAccessToken(url, code, clientId, redirectUri, pkceCodeVerifier) {\n  const body = new URLSearchParams([['code', code], ['grant_type', 'authorization_code'], ['client_id', clientId], ['redirect_uri', stripHash(redirectUri)]]);\n  if (pkceCodeVerifier) {\n    body.append('code_verifier', pkceCodeVerifier);\n  }\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  });\n}\n\n/**\n * Fetch the refresh token from the given URL.\n * @param {string} url\n * @param {string} refreshToken\n * @param {string} clientId\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchRefreshToken(url, refreshToken, clientId) {\n  const body = new URLSearchParams([['grant_type', 'refresh_token'], ['refresh_token', refreshToken], ['client_id', clientId]]);\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  });\n}\n\n/**\n * @template [T=unknown]\n * @param {string} url\n * @param {RequestInit} init\n * @returns {Promise<T>}\n */\nasync function fetchJSON(url, init = {}) {\n  const headers = new Headers(init.headers);\n  headers.set('Accept', CONTENT_TYPE_JSON);\n  const response = await fetchWithErrorHandling(url, {\n    ...init,\n    headers\n  });\n  return await response.json();\n}\n\n/**\n * @param {string} url\n * @param {RequestInit} [init]\n * @returns {Promise<Response>}\n */\nasync function fetchWithErrorHandling(url, init) {\n  const response = await fetch(url, init);\n  if (!response.ok) {\n    throw new NetworkError('Server responded with an invalid status.', {\n      response\n    });\n  }\n  return response;\n}\n\n/**\n * @param {string} [token]\n * @returns {[string, string]}\n */\nfunction buildAuthorizationHeader(token) {\n  if (!token) {\n    throw new Error('Unable to build authorization header, token is not set, make sure the user is authenticated.');\n  }\n  return ['Authorization', `bearer ${token}`];\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripTrailingSlash(url) {\n  return url.endsWith('/') ? url.slice(0, -1) : url;\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripHash(url) {\n  const parsedUrl = new URL(url);\n  parsedUrl.hash = '';\n  return parsedUrl.toString();\n}\n\n/**\n * @typedef {Object} NetworkErrorOptionsProperties\n * @property {Response} response\n * @typedef {ErrorOptions & NetworkErrorOptionsProperties} NetworkErrorOptions\n */\n\nexport class NetworkError extends Error {\n  /** @type {Response} */\n  response;\n\n  /**\n   * @param {string} message\n   * @param {NetworkErrorOptions} options\n   */\n  constructor(message, options) {\n    super(message, options);\n    this.response = options.response;\n  }\n}\n\n/**\n * @param {number} delay\n * @returns {Promise<void>}\n */\nconst waitForTimeout = delay => new Promise(resolve => setTimeout(resolve, delay));","map":{"version":3,"names":["CONTENT_TYPE_JSON","Keycloak","refreshQueue","adapter","useNonce","callbackStorage","logInfo","createLogger","console","info","logWarn","warn","loginIframe","enable","callbackList","interval","config","didInitialize","authenticated","loginRequired","responseMode","responseType","flow","timeSkew","redirectUri","silentCheckSsoRedirectUri","silentCheckSsoFallback","pkceMethod","enableLogging","logoutMethod","scope","messageReceiveTimeout","idToken","idTokenParsed","token","tokenParsed","refreshToken","refreshTokenParsed","clientId","sessionId","subject","authServerUrl","realm","realmAccess","resourceAccess","profile","userInfo","endpoints","tokenTimeoutHandle","onAuthSuccess","onAuthError","onAuthRefreshSuccess","onAuthRefreshError","onTokenExpired","onAuthLogout","onReady","onActionUpdate","constructor","isObject","Error","requiredProperties","property","globalThis","isSecureContext","init","initOptions","createCallbackStorage","adapters","includes","loadAdapter","window","checkLoginIframe","checkLoginIframeInterval","onLoad","TypeError","loadConfig","check3pCookiesSupported","processInit","#loadAdapter","type","loadDefaultAdapter","loadCordovaAdapter","loadCordovaNativeAdapter","#loadDefaultAdapter","options","location","href","login","assign","createLoginUrl","Promise","logout","replace","createLogoutUrl","form","document","createElement","setAttribute","style","display","data","id_token_hint","client_id","post_logout_redirect_uri","name","value","Object","entries","input","appendChild","body","submit","register","createRegisterUrl","accountManagement","accountUrl","createAccountUrl","#loadCordovaAdapter","cordovaOpenWindowWrapper","loginUrl","target","cordova","InAppBrowser","open","shallowCloneCordovaOptions","userOptions","cordovaOptions","keys","reduce","optionName","formatCordovaOptions","push","join","createCordovaOptions","prompt","hidden","getCordovaRedirectUri","ref","completed","closed","closeBrowser","close","resolve","reject","addEventListener","event","url","indexOf","callback","parseCallback","processCallback","error","logoutUrl","clearToken","registerUrl","promise","oauth","#loadCordovaNativeAdapter","universalLinks","subscribe","unsubscribe","plugins","browsertab","openUrl","#loadConfig","jsonConfig","fetchJsonConfig","resource","setupEndpoints","loadOidcConfig","oidcProvider","#setupEndpoints","authorize","getRealmUrl","checkSessionIframe","thirdPartyCookiesIframe","userinfo","#loadOidcConfig","stripTrailingSlash","openIdConfig","fetchOpenIdConfig","setupOidcEndpoints","#setupOidcEndpoints","authorization_endpoint","token_endpoint","end_session_endpoint","check_session_iframe","userinfo_endpoint","#check3pCookiesSupported","iframe","messageCallback","contentWindow","source","undefined","removeChild","removeEventListener","applyTimeoutToPromise","#processInit","history","replaceState","state","valid","setupCheckLoginIframe","doLogin","locale","unchanged","checkSsoSilently","setToken","scheduleCheckIframe","updateToken","#setupCheckLoginIframe","origin","iframeOrigin","callbacks","reverse","authUrl","startsWith","URL","#checkLoginIframe","message","result","length","postMessage","#checkSsoSilently","src","#parseCallback","parseCallbackUrl","oauthState","get","storedNonce","nonce","pkceCodeVerifier","loginOptions","#parseCallbackUrl","urlString","supportedParams","parsed","searchParams","size","parseCallbackParams","search","paramsString","toString","hash","substring","oauthParams","code","access_token","#parseCallbackParams","params","URLSearchParams","key","Array","from","delete","#processCallback","timeLocal","Date","getTime","authSuccess","accessToken","kc_action_status","kc_action","error_description","errorData","id_token","response","fetchAccessToken","refresh_token","#scheduleCheckIframe","waitForTimeout","createUUID","callbackState","action","scopeValues","split","unshift","stripHash","append","maxAge","loginHint","idpHint","acr","buildClaimsParameter","acrValues","codeVerifier","generateCodeVerifier","pkceChallenge","generatePkceChallenge","cause","add","hasRealmRole","role","access","roles","hasResourceRole","loadUserProfile","realmUrl","fetchJSON","headers","buildAuthorizationHeader","loadUserInfo","isTokenExpired","minValidity","exp","expiresIn","Math","ceil","isNaN","withResolvers","fetchRefreshToken","p","pop","NetworkError","status","#setToken","clearTimeout","decodeToken","sid","sub","realm_access","resource_access","floor","iat","round","setTimeout","#getRealmUrl","encodeURIComponent","#createLogger","fn","call","crypto","randomUUID","requestedAcr","JSON","stringify","len","generateRandomString","hashBytes","Uint8Array","sha256Digest","encodedHash","bytesToBase64","alphabet","randomData","generateRandomData","chars","i","charCodeAt","String","fromCharCode","apply","getRandomValues","timeout","errorMessage","timeoutHandle","timeoutPromise","race","finally","LocalStorage","err","CookieStorage","STORAGE_KEY_PREFIX","localStorage","setItem","removeItem","clearInvalidValues","getItem","parse","expires","now","clearAllValues","#clearInvalidValues","currentTime","getStoredEntries","expiry","parseExpiry","#clearAllValues","#getStoredEntries","filter","#parseExpiry","parsedValue","getCookie","setCookie","cookieExpiration","#getCookie","ca","cookie","c","charAt","#setCookie","expirationDate","toUTCString","#cookieExpiration","minutes","setTime","bytes","binString","fromCodePoint","btoa","encoder","TextEncoder","encode","subtle","digest","payload","decoded","base64UrlDecode","output","replaceAll","b64DecodeUnicode","atob","decodeURIComponent","m","toUpperCase","method","credentials","Headers","set","fetchWithErrorHandling","json","fetch","ok","endsWith","slice","parsedUrl","delay"],"sources":["/root/canton-website/app/node_modules/keycloak-js/lib/keycloak.js"],"sourcesContent":["// @ts-check\n/**\n * @import {Acr, KeycloakAccountOptions, KeycloakAdapter, KeycloakConfig, KeycloakError, KeycloakFlow, KeycloakInitOptions, KeycloakLoginOptions, KeycloakLogoutOptions, KeycloakPkceMethod, KeycloakProfile, KeycloakRegisterOptions, KeycloakResourceAccess, KeycloakResponseMode, KeycloakResponseType, KeycloakRoles, KeycloakTokenParsed, OpenIdProviderMetadata} from \"./keycloak.ts\"\n */\n/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst CONTENT_TYPE_JSON = 'application/json'\n\n/**\n * @typedef {Object} Endpoints\n * @property {() => string} authorize\n * @property {() => string} token\n * @property {() => string} logout\n * @property {() => string} checkSessionIframe\n * @property {() => string=} thirdPartyCookiesIframe\n * @property {() => string} register\n * @property {() => string} userinfo\n */\n\n/**\n * @typedef {Object} LoginIframe\n * @property {boolean} enable\n * @property {((error: Error | null, value?: boolean) => void)[]} callbackList\n * @property {number} interval\n * @property {HTMLIFrameElement=} iframe\n * @property {string=} iframeOrigin\n */\n\nexport default class Keycloak {\n  /** @type {Pick<PromiseWithResolvers<boolean>, 'resolve' | 'reject'>[]} */\n  #refreshQueue = []\n  /** @type {KeycloakAdapter} */\n  #adapter\n  /** @type {boolean} */\n  #useNonce = true\n  /** @type {CallbackStorage} */\n  #callbackStorage\n  #logInfo = this.#createLogger(console.info)\n  #logWarn = this.#createLogger(console.warn)\n  /** @type {LoginIframe} */\n  #loginIframe = {\n    enable: true,\n    callbackList: [],\n    interval: 5\n  }\n\n  /** @type {KeycloakConfig} config */\n  #config\n  didInitialize = false\n  authenticated = false\n  loginRequired = false\n  /** @type {KeycloakResponseMode} */\n  responseMode = 'fragment'\n  /** @type {KeycloakResponseType} */\n  responseType = 'code'\n  /** @type {KeycloakFlow} */\n  flow = 'standard'\n  /** @type {number?} */\n  timeSkew = null\n  /** @type {string=} */\n  redirectUri\n  /** @type {string=} */\n  silentCheckSsoRedirectUri\n  /** @type {boolean} */\n  silentCheckSsoFallback = true\n  /** @type {KeycloakPkceMethod} */\n  pkceMethod = 'S256'\n  enableLogging = false\n  /** @type {'GET' | 'POST'} */\n  logoutMethod = 'GET'\n  /** @type {string=} */\n  scope\n  messageReceiveTimeout = 10000\n  /** @type {string=} */\n  idToken\n  /** @type {KeycloakTokenParsed=} */\n  idTokenParsed\n  /** @type {string=} */\n  token\n  /** @type {KeycloakTokenParsed=} */\n  tokenParsed\n  /** @type {string=} */\n  refreshToken\n  /** @type {KeycloakTokenParsed=} */\n  refreshTokenParsed\n  /** @type {string=} */\n  clientId\n  /** @type {string=} */\n  sessionId\n  /** @type {string=} */\n  subject\n  /** @type {string=} */\n  authServerUrl\n  /** @type {string=} */\n  realm\n  /** @type {KeycloakRoles=} */\n  realmAccess\n  /** @type {KeycloakResourceAccess=} */\n  resourceAccess\n  /** @type {KeycloakProfile=} */\n  profile\n  /** @type {{}=} */\n  userInfo\n  /** @type {Endpoints} */\n  endpoints\n  /** @type {number=} */\n  tokenTimeoutHandle\n  /** @type {() => void=} */\n  onAuthSuccess\n  /** @type {(errorData?: KeycloakError) => void=} */\n  onAuthError\n  /** @type {() => void=} */\n  onAuthRefreshSuccess\n  /** @type {() => void=} */\n  onAuthRefreshError\n  /** @type {() => void=} */\n  onTokenExpired\n  /** @type {() => void=} */\n  onAuthLogout\n  /** @type {(authenticated: boolean) => void=} */\n  onReady\n  /** @type {(status: 'success' | 'cancelled' | 'error', action: string) => void=} */\n  onActionUpdate\n\n  /**\n   * @param {KeycloakConfig} config\n   */\n  constructor (config) {\n    if (typeof config !== 'string' && !isObject(config)) {\n      throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\")\n    }\n\n    if (isObject(config)) {\n      const requiredProperties = 'oidcProvider' in config\n        ? ['clientId']\n        : ['url', 'realm', 'clientId']\n\n      for (const property of requiredProperties) {\n        if (!(property in config)) {\n          throw new Error(`The configuration object is missing the required '${property}' property.`)\n        }\n      }\n    }\n\n    if (!globalThis.isSecureContext) {\n      this.#logWarn(\n        \"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\n\" +\n                'Continuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\n' +\n                'For more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts'\n      )\n    }\n\n    this.#config = config\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<boolean>}\n   */\n  async init (initOptions = {}) {\n    if (this.didInitialize) {\n      throw new Error(\"A 'Keycloak' instance can only be initialized once.\")\n    }\n\n    this.didInitialize = true\n    this.#callbackStorage = createCallbackStorage()\n\n    const adapters = ['default', 'cordova', 'cordova-native']\n\n    if (typeof initOptions.adapter === 'string' && adapters.includes(initOptions.adapter)) {\n      this.#adapter = this.#loadAdapter(initOptions.adapter)\n    } else if (typeof initOptions.adapter === 'object') {\n      this.#adapter = initOptions.adapter\n    } else if ('Cordova' in window || 'cordova' in window) {\n      this.#adapter = this.#loadAdapter('cordova')\n    } else {\n      this.#adapter = this.#loadAdapter('default')\n    }\n\n    if (typeof initOptions.useNonce !== 'undefined') {\n      this.#useNonce = initOptions.useNonce\n    }\n\n    if (typeof initOptions.checkLoginIframe !== 'undefined') {\n      this.#loginIframe.enable = initOptions.checkLoginIframe\n    }\n\n    if (initOptions.checkLoginIframeInterval) {\n      this.#loginIframe.interval = initOptions.checkLoginIframeInterval\n    }\n\n    if (initOptions.onLoad === 'login-required') {\n      this.loginRequired = true\n    }\n\n    if (initOptions.responseMode) {\n      if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') {\n        this.responseMode = initOptions.responseMode\n      } else {\n        throw new Error('Invalid value for responseMode')\n      }\n    }\n\n    if (initOptions.flow) {\n      switch (initOptions.flow) {\n        case 'standard':\n          this.responseType = 'code'\n          break\n        case 'implicit':\n          this.responseType = 'id_token token'\n          break\n        case 'hybrid':\n          this.responseType = 'code id_token token'\n          break\n        default:\n          throw new Error('Invalid value for flow')\n      }\n      this.flow = initOptions.flow\n    }\n\n    if (typeof initOptions.timeSkew === 'number') {\n      this.timeSkew = initOptions.timeSkew\n    }\n\n    if (initOptions.redirectUri) {\n      this.redirectUri = initOptions.redirectUri\n    }\n\n    if (initOptions.silentCheckSsoRedirectUri) {\n      this.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri\n    }\n\n    if (typeof initOptions.silentCheckSsoFallback === 'boolean') {\n      this.silentCheckSsoFallback = initOptions.silentCheckSsoFallback\n    }\n\n    if (typeof initOptions.pkceMethod !== 'undefined') {\n      if (initOptions.pkceMethod !== 'S256' && initOptions.pkceMethod !== false) {\n        throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`)\n      }\n\n      this.pkceMethod = initOptions.pkceMethod\n    }\n\n    if (typeof initOptions.enableLogging === 'boolean') {\n      this.enableLogging = initOptions.enableLogging\n    }\n\n    if (initOptions.logoutMethod === 'POST') {\n      this.logoutMethod = 'POST'\n    }\n\n    if (typeof initOptions.scope === 'string') {\n      this.scope = initOptions.scope\n    }\n\n    if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) {\n      this.messageReceiveTimeout = initOptions.messageReceiveTimeout\n    }\n\n    await this.#loadConfig()\n    await this.#check3pCookiesSupported()\n    await this.#processInit(initOptions)\n\n    this.onReady?.(this.authenticated)\n\n    return this.authenticated\n  }\n\n  /**\n   * @param {\"default\" | \"cordova\" | \"cordova-native\"} type\n   * @returns {KeycloakAdapter}\n   */\n  #loadAdapter (type) {\n    if (type === 'default') {\n      return this.#loadDefaultAdapter()\n    }\n\n    if (type === 'cordova') {\n      this.#loginIframe.enable = false\n      return this.#loadCordovaAdapter()\n    }\n\n    if (type === 'cordova-native') {\n      this.#loginIframe.enable = false\n      return this.#loadCordovaNativeAdapter()\n    }\n\n    throw new Error('invalid adapter type: ' + type)\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadDefaultAdapter () {\n    /** @type {KeycloakAdapter['redirectUri']}{} */\n    const redirectUri = (options) => {\n      return options?.redirectUri || this.redirectUri || globalThis.location.href\n    }\n\n    return {\n      login: async (options) => {\n        window.location.assign(await this.createLoginUrl(options))\n        return await new Promise(() => {})\n      },\n\n      logout: async (options) => {\n        const logoutMethod = options?.logoutMethod ?? this.logoutMethod\n\n        if (logoutMethod === 'GET') {\n          window.location.replace(this.createLogoutUrl(options))\n          return\n        }\n\n        // Create form to send POST request.\n        const form = document.createElement('form')\n\n        form.setAttribute('method', 'POST')\n        form.setAttribute('action', this.createLogoutUrl(options))\n        form.style.display = 'none'\n\n        // Add data to form as hidden input fields.\n        const data = {\n          id_token_hint: this.idToken,\n          client_id: this.clientId,\n          post_logout_redirect_uri: redirectUri(options)\n        }\n\n        for (const [name, value] of Object.entries(data)) {\n          const input = document.createElement('input')\n\n          input.setAttribute('type', 'hidden')\n          input.setAttribute('name', name)\n          input.setAttribute('value', /** @type {string} */ (value))\n\n          form.appendChild(input)\n        }\n\n        // Append form to page and submit it to perform logout and redirect.\n        document.body.appendChild(form)\n        form.submit()\n      },\n\n      register: async (options) => {\n        window.location.assign(await this.createRegisterUrl(options))\n        return await new Promise(() => {})\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          window.location.href = accountUrl\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return await new Promise(() => {})\n      },\n\n      redirectUri\n    }\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadCordovaAdapter () {\n    /**\n     * @param {string} loginUrl\n     * @param {string} target\n     * @param {string} options\n     * @returns {WindowProxy | null}\n     */\n    const cordovaOpenWindowWrapper = (loginUrl, target, options) => {\n      if (window.cordova && window.cordova.InAppBrowser) {\n        // Use inappbrowser for IOS and Android if available\n        return window.cordova.InAppBrowser.open(loginUrl, target, options)\n      } else {\n        return window.open(loginUrl, target, options)\n      }\n    }\n\n    const shallowCloneCordovaOptions = (userOptions) => {\n      if (userOptions && userOptions.cordovaOptions) {\n        return Object.keys(userOptions.cordovaOptions).reduce((options, optionName) => {\n          options[optionName] = userOptions.cordovaOptions[optionName]\n          return options\n        }, {})\n      } else {\n        return {}\n      }\n    }\n\n    const formatCordovaOptions = (cordovaOptions) => {\n      return Object.keys(cordovaOptions).reduce((options, optionName) => {\n        options.push(optionName + '=' + cordovaOptions[optionName])\n        return options\n      }, []).join(',')\n    }\n\n    const createCordovaOptions = (userOptions) => {\n      const cordovaOptions = shallowCloneCordovaOptions(userOptions)\n      cordovaOptions.location = 'no'\n      if (userOptions && userOptions.prompt === 'none') {\n        cordovaOptions.hidden = 'yes'\n      }\n      return formatCordovaOptions(cordovaOptions)\n    }\n\n    const getCordovaRedirectUri = () => {\n      return this.redirectUri || 'http://localhost'\n    }\n\n    return {\n      login: async (options) => {\n        const cordovaOptions = createCordovaOptions(options)\n        const loginUrl = await this.createLoginUrl(options)\n        const ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions)\n        let completed = false\n        let closed = false\n\n        function closeBrowser () {\n          closed = true\n          ref.close()\n        };\n\n        return await new Promise((resolve, reject) => {\n          ref.addEventListener('loadstart', async (event) => {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              const callback = this.#parseCallback(event.url)\n\n              try {\n                await this.#processCallback(callback)\n                resolve()\n              } catch (error) {\n                reject(error)\n              }\n              closeBrowser()\n              completed = true\n            }\n          })\n\n          ref.addEventListener('loaderror', async (event) => {\n            if (!completed) {\n              if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n                const callback = this.#parseCallback(event.url)\n                try {\n                  await this.#processCallback(callback)\n                  resolve()\n                } catch (error) {\n                  reject(error)\n                }\n                closeBrowser()\n                completed = true\n              } else {\n                reject(new Error('Unable to process login.'))\n                closeBrowser()\n              }\n            }\n          })\n\n          ref.addEventListener('exit', function (event) {\n            if (!closed) {\n              reject(new Error('User closed the login window.'))\n            }\n          })\n        })\n      },\n\n      logout: async (options) => {\n        const logoutUrl = this.createLogoutUrl(options)\n        const ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes')\n        let error = false\n\n        ref.addEventListener('loadstart', (event) => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close()\n          }\n        })\n\n        ref.addEventListener('loaderror', (event) => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close()\n          } else {\n            error = true\n            ref.close()\n          }\n        })\n\n        await new Promise((resolve, reject) => {\n          ref.addEventListener('exit', () => {\n            if (error) {\n              reject(new Error('User closed the login window.'))\n            } else {\n              this.clearToken()\n              resolve()\n            }\n          })\n        })\n      },\n\n      register: async (options) => {\n        const registerUrl = await this.createRegisterUrl()\n        const cordovaOptions = createCordovaOptions(options)\n        const ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions)\n\n        /** @type {Promise<void>} */\n        const promise = new Promise((resolve, reject) => {\n          ref.addEventListener('loadstart', async (event) => {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              ref.close()\n              const oauth = this.#parseCallback(event.url)\n\n              try {\n                await this.#processCallback(oauth)\n                resolve()\n              } catch (error) {\n                reject(error)\n              }\n            }\n          })\n        })\n\n        await promise\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          const ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no')\n          ref.addEventListener('loadstart', function (event) {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              ref.close()\n            }\n          })\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n      },\n\n      redirectUri: () => {\n        return getCordovaRedirectUri()\n      }\n    }\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadCordovaNativeAdapter () {\n    /* global universalLinks */\n    return {\n      login: async (options) => {\n        const loginUrl = await this.createLoginUrl(options)\n\n        await new Promise((resolve, reject) => {\n          universalLinks.subscribe('keycloak', async (event) => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            const oauth = this.#parseCallback(event.url)\n\n            try {\n              await this.#processCallback(oauth)\n              resolve()\n            } catch (error) {\n              reject(error)\n            }\n          })\n\n          window.cordova.plugins.browsertab.openUrl(loginUrl)\n        })\n      },\n\n      logout: async (options) => {\n        const logoutUrl = this.createLogoutUrl(options)\n\n        await new Promise((resolve) => {\n          universalLinks.subscribe('keycloak', () => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            this.clearToken()\n            resolve()\n          })\n\n          window.cordova.plugins.browsertab.openUrl(logoutUrl)\n        })\n      },\n\n      register: async (options) => {\n        const registerUrl = await this.createRegisterUrl(options)\n\n        await new Promise((resolve, reject) => {\n          universalLinks.subscribe('keycloak', async (event) => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            const oauth = this.#parseCallback(event.url)\n            try {\n              await this.#processCallback(oauth)\n              resolve()\n            } catch (error) {\n              reject(error)\n            }\n          })\n\n          window.cordova.plugins.browsertab.openUrl(registerUrl)\n        })\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          window.cordova.plugins.browsertab.openUrl(accountUrl)\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n      },\n\n      redirectUri: (options) => {\n        if (options && options.redirectUri) {\n          return options.redirectUri\n        } else if (this.redirectUri) {\n          return this.redirectUri\n        } else {\n          return 'http://localhost'\n        }\n      }\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #loadConfig () {\n    if (typeof this.#config === 'string') {\n      const jsonConfig = await fetchJsonConfig(this.#config)\n      this.authServerUrl = jsonConfig['auth-server-url']\n      this.realm = jsonConfig.realm\n      this.clientId = jsonConfig.resource\n      this.#setupEndpoints()\n    } else {\n      this.clientId = this.#config.clientId\n\n      if ('oidcProvider' in this.#config) {\n        await this.#loadOidcConfig(this.#config.oidcProvider)\n      } else {\n        this.authServerUrl = this.#config.url\n        this.realm = this.#config.realm\n        this.#setupEndpoints()\n      }\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  #setupEndpoints () {\n    this.endpoints = {\n      authorize: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/auth'\n      },\n      token: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/token'\n      },\n      logout: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/logout'\n      },\n      checkSessionIframe: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/login-status-iframe.html'\n      },\n      thirdPartyCookiesIframe: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/3p-cookies/step1.html'\n      },\n      register: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/registrations'\n      },\n      userinfo: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/userinfo'\n      }\n    }\n  }\n\n  /**\n   * @param {string | OpenIdProviderMetadata} oidcProvider\n   * @returns {Promise<void>}\n   */\n  async #loadOidcConfig (oidcProvider) {\n    if (typeof oidcProvider === 'string') {\n      const url = `${stripTrailingSlash(oidcProvider)}/.well-known/openid-configuration`\n      const openIdConfig = await fetchOpenIdConfig(url)\n      this.#setupOidcEndpoints(openIdConfig)\n    } else {\n      this.#setupOidcEndpoints(oidcProvider)\n    }\n  }\n\n  /**\n   * @param {OpenIdProviderMetadata} config\n   * @returns {void}\n   */\n  #setupOidcEndpoints (config) {\n    this.endpoints = {\n      authorize () {\n        return config.authorization_endpoint\n      },\n      token () {\n        return config.token_endpoint\n      },\n      logout () {\n        if (!config.end_session_endpoint) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.end_session_endpoint\n      },\n      checkSessionIframe () {\n        if (!config.check_session_iframe) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.check_session_iframe\n      },\n      register () {\n        throw new Error('Redirection to \"Register user\" page not supported in standard OIDC mode')\n      },\n      userinfo () {\n        if (!config.userinfo_endpoint) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.userinfo_endpoint\n      }\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #check3pCookiesSupported () {\n    if ((!this.#loginIframe.enable && !this.silentCheckSsoRedirectUri) || typeof this.endpoints.thirdPartyCookiesIframe !== 'function') {\n      return\n    }\n\n    const iframe = document.createElement('iframe')\n    iframe.setAttribute('src', this.endpoints.thirdPartyCookiesIframe())\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-3p-check-iframe')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    /** @type {Promise<void>} */\n    const promise = new Promise((resolve) => {\n      /**\n       * @param {MessageEvent} event\n       */\n      const messageCallback = (event) => {\n        if (iframe.contentWindow !== event.source) {\n          return\n        }\n\n        if (event.data !== 'supported' && event.data !== 'unsupported') {\n          return\n        } else if (event.data === 'unsupported') {\n          this.#logWarn(\n            '[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n' +\n                        ' - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n' +\n                        ' - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\n' +\n                        'For more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers'\n          )\n\n          this.#loginIframe.enable = false\n          if (this.silentCheckSsoFallback) {\n            this.silentCheckSsoRedirectUri = undefined\n          }\n        }\n\n        document.body.removeChild(iframe)\n        window.removeEventListener('message', messageCallback)\n        resolve()\n      }\n\n      window.addEventListener('message', messageCallback, false)\n    })\n\n    return await applyTimeoutToPromise(promise, this.messageReceiveTimeout, 'Timeout when waiting for 3rd party check iframe message.')\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<void>}\n   */\n  async #processInit (initOptions) {\n    const callback = this.#parseCallback(window.location.href)\n\n    if (callback?.redirectUri) {\n      window.history.replaceState(window.history.state, '', callback.redirectUri)\n    }\n\n    if (callback && callback.valid) {\n      await this.#setupCheckLoginIframe()\n      await this.#processCallback(callback)\n      return\n    }\n\n    /** @param {boolean} prompt */\n    const doLogin = async (prompt) => {\n      /** @type {KeycloakLoginOptions} */\n      const options = {}\n\n      if (!prompt) {\n        options.prompt = 'none'\n      }\n\n      if (initOptions.locale) {\n        options.locale = initOptions.locale\n      }\n\n      await this.login(options)\n    }\n\n    const onLoad = async () => {\n      switch (initOptions.onLoad) {\n        case 'check-sso':\n          if (this.#loginIframe.enable) {\n            await this.#setupCheckLoginIframe()\n            const unchanged = await this.#checkLoginIframe()\n\n            if (!unchanged) {\n              this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false)\n            }\n          } else {\n            this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false)\n          }\n          break\n        case 'login-required':\n          await doLogin(true)\n          break\n        default:\n          throw new Error('Invalid value for onLoad')\n      }\n    }\n\n    if (initOptions.token && initOptions.refreshToken) {\n      this.#setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken)\n\n      if (this.#loginIframe.enable) {\n        await this.#setupCheckLoginIframe()\n        const unchanged = await this.#checkLoginIframe()\n\n        if (unchanged) {\n          this.onAuthSuccess?.()\n          this.#scheduleCheckIframe()\n        }\n      } else {\n        try {\n          await this.updateToken(-1)\n          this.onAuthSuccess?.()\n        } catch (error) {\n          this.onAuthError?.()\n          if (initOptions.onLoad) {\n            await onLoad()\n          } else {\n            throw error\n          }\n        }\n      }\n    } else if (initOptions.onLoad) {\n      await onLoad()\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #setupCheckLoginIframe () {\n    if (!this.#loginIframe.enable || this.#loginIframe.iframe) {\n      return\n    }\n\n    const iframe = document.createElement('iframe')\n    this.#loginIframe.iframe = iframe\n    iframe.setAttribute('src', this.endpoints.checkSessionIframe())\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-session-iframe')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    /**\n     * @param {MessageEvent} event\n     */\n    const messageCallback = (event) => {\n      if (event.origin !== this.#loginIframe.iframeOrigin || this.#loginIframe.iframe?.contentWindow !== event.source) {\n        return\n      }\n\n      if (!(event.data === 'unchanged' || event.data === 'changed' || event.data === 'error')) {\n        return\n      }\n\n      if (event.data !== 'unchanged') {\n        this.clearToken()\n      }\n\n      const callbacks = this.#loginIframe.callbackList\n      this.#loginIframe.callbackList = []\n\n      for (const callback of callbacks.reverse()) {\n        if (event.data === 'error') {\n          callback(new Error('Error while checking login iframe'))\n        } else {\n          callback(null, event.data === 'unchanged')\n        }\n      }\n    }\n\n    window.addEventListener('message', messageCallback, false)\n\n    /** @type {Promise<void>} */\n    const promise = new Promise((resolve) => {\n      iframe.addEventListener('load', () => {\n        const authUrl = this.endpoints.authorize()\n        if (authUrl.startsWith('/')) {\n          this.#loginIframe.iframeOrigin = globalThis.location.origin\n        } else {\n          this.#loginIframe.iframeOrigin = new URL(authUrl).origin\n        }\n        resolve()\n      })\n    })\n\n    await promise\n  }\n\n  /**\n   * @returns {Promise<boolean | undefined>}\n   */\n  async #checkLoginIframe () {\n    if (!this.#loginIframe.iframe || !this.#loginIframe.iframeOrigin) {\n      return\n    }\n\n    const message = `${this.clientId} ${(this.sessionId ? this.sessionId : '')}`\n    const origin = this.#loginIframe.iframeOrigin\n\n    /** @type {Promise<boolean>} */\n    const promise = new Promise((resolve, reject) => {\n      /** @type {(error: Error | null, value?: boolean) => void} */\n      const callback = (error, result) => error ? reject(error) : resolve(/** @type {boolean} */ (result))\n\n      this.#loginIframe.callbackList.push(callback)\n\n      if (this.#loginIframe.callbackList.length === 1) {\n        this.#loginIframe.iframe?.contentWindow?.postMessage(message, origin)\n      }\n    })\n\n    return await promise\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #checkSsoSilently () {\n    const iframe = document.createElement('iframe')\n    const src = await this.createLoginUrl({ prompt: 'none', redirectUri: this.silentCheckSsoRedirectUri })\n    iframe.setAttribute('src', src)\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-silent-check-sso')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    return await new Promise((resolve, reject) => {\n      /**\n       * @param {MessageEvent} event\n       */\n      const messageCallback = async (event) => {\n        if (event.origin !== window.location.origin || iframe.contentWindow !== event.source) {\n          return\n        }\n\n        const oauth = this.#parseCallback(event.data)\n\n        try {\n          await this.#processCallback(oauth)\n          resolve()\n        } catch (error) {\n          reject(error)\n        }\n\n        document.body.removeChild(iframe)\n        window.removeEventListener('message', messageCallback)\n      }\n\n      window.addEventListener('message', messageCallback)\n    })\n  };\n\n  /**\n   * @param {string} url\n   */\n  #parseCallback (url) {\n    const oauth = this.#parseCallbackUrl(url)\n    if (!oauth) {\n      return\n    }\n\n    const oauthState = this.#callbackStorage.get(oauth.state)\n\n    if (oauthState) {\n      oauth.valid = true\n      oauth.redirectUri = oauthState.redirectUri\n      oauth.storedNonce = oauthState.nonce\n      oauth.prompt = oauthState.prompt\n      oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier\n      oauth.loginOptions = oauthState.loginOptions\n    }\n\n    return oauth\n  }\n\n  /**\n   * @param {string} urlString\n   */\n  #parseCallbackUrl (urlString) {\n    let supportedParams = []\n    switch (this.flow) {\n      case 'standard':\n        supportedParams = ['code', 'state', 'session_state', 'kc_action_status', 'kc_action', 'iss']\n        break\n      case 'implicit':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss']\n        break\n      case 'hybrid':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'code', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss']\n        break\n    }\n\n    supportedParams.push('error')\n    supportedParams.push('error_description')\n    supportedParams.push('error_uri')\n\n    const url = new URL(urlString)\n    let redirectUri = ''\n    let parsed\n\n    if (this.responseMode === 'query' && url.searchParams.size > 0) {\n      parsed = this.#parseCallbackParams(url.search, supportedParams)\n      url.search = parsed.paramsString\n      redirectUri = url.toString()\n    } else if (this.responseMode === 'fragment' && url.hash.length > 0) {\n      parsed = this.#parseCallbackParams(url.hash.substring(1), supportedParams)\n      url.hash = ''\n      redirectUri = url.toString()\n    }\n\n    if (parsed?.oauthParams) {\n      if (this.flow === 'standard' || this.flow === 'hybrid') {\n        if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.redirectUri = redirectUri\n          return parsed.oauthParams\n        }\n      } else if (this.flow === 'implicit') {\n        if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.redirectUri = redirectUri\n          return parsed.oauthParams\n        }\n      }\n    }\n  }\n\n  /**\n   * @typedef {Object} ParsedCallbackParams\n   * @property {string} paramsString\n   * @property {Record<string, string | undefined>} oauthParams\n   */\n\n  /**\n   * @param {string} paramsString\n   * @param {string[]} supportedParams\n   * @returns {ParsedCallbackParams}\n   */\n  #parseCallbackParams (paramsString, supportedParams) {\n    const params = new URLSearchParams(paramsString)\n    /** @type {Record<string, string>} */\n    const oauthParams = {}\n\n    for (const [key, value] of Array.from(params.entries())) {\n      if (supportedParams.includes(key)) {\n        oauthParams[key] = value\n        params.delete(key)\n      }\n    }\n\n    return {\n      paramsString: params.toString(),\n      oauthParams\n    }\n  }\n\n  async #processCallback (oauth) {\n    const { code, error, prompt } = oauth\n    let timeLocal = new Date().getTime()\n\n    /**\n     * @param {string} accessToken\n     * @param {string=} refreshToken\n     * @param {string=} idToken\n     */\n    const authSuccess = (accessToken, refreshToken, idToken) => {\n      timeLocal = (timeLocal + new Date().getTime()) / 2\n\n      this.#setToken(accessToken, refreshToken, idToken, timeLocal)\n\n      if (this.#useNonce && (this.idTokenParsed && this.idTokenParsed.nonce !== oauth.storedNonce)) {\n        this.#logInfo('[KEYCLOAK] Invalid nonce, clearing token')\n        this.clearToken()\n        throw new Error('Invalid nonce.')\n      }\n    }\n\n    if (oauth.kc_action_status) {\n      this.onActionUpdate && this.onActionUpdate(oauth.kc_action_status, oauth.kc_action)\n    }\n\n    if (error) {\n      if (prompt !== 'none') {\n        if (oauth.error_description && oauth.error_description === 'authentication_expired') {\n          await this.login(oauth.loginOptions)\n        } else {\n          const errorData = { error, error_description: oauth.error_description }\n          this.onAuthError?.(errorData)\n          throw errorData\n        }\n      }\n      return\n    } else if ((this.flow !== 'standard') && (oauth.access_token || oauth.id_token)) {\n      authSuccess(oauth.access_token, undefined, oauth.id_token)\n      this.onAuthSuccess?.()\n    }\n\n    if ((this.flow !== 'implicit') && code) {\n      try {\n        const response = await fetchAccessToken(this.endpoints.token(), code, /** @type {string} */ (this.clientId), oauth.redirectUri, oauth.pkceCodeVerifier)\n        authSuccess(response.access_token, response.refresh_token, response.id_token)\n\n        if (this.flow === 'standard') {\n          this.onAuthSuccess?.()\n        }\n\n        this.#scheduleCheckIframe()\n      } catch (error) {\n        this.onAuthError?.()\n        throw error\n      }\n    }\n  }\n\n  async #scheduleCheckIframe () {\n    if (this.#loginIframe.enable && this.token) {\n      await waitForTimeout(this.#loginIframe.interval * 1000)\n      const unchanged = await this.#checkLoginIframe()\n\n      if (unchanged) {\n        await this.#scheduleCheckIframe()\n      }\n    }\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<void>}\n   */\n  login (options) {\n    return this.#adapter.login(options)\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<string>}\n   */\n  async createLoginUrl (options) {\n    const state = createUUID()\n    const nonce = createUUID()\n    const redirectUri = this.#adapter.redirectUri(options)\n    /** @type {CallbackState} */\n    const callbackState = {\n      state,\n      nonce,\n      redirectUri,\n      loginOptions: options\n    }\n\n    if (options?.prompt) {\n      callbackState.prompt = options.prompt\n    }\n\n    const url = options?.action === 'register'\n      ? this.endpoints.register()\n      : this.endpoints.authorize()\n\n    let scope = options?.scope || this.scope\n    const scopeValues = scope ? scope.split(' ') : []\n\n    // Ensure the 'openid' scope is always included.\n    if (!scopeValues.includes('openid')) {\n      scopeValues.unshift('openid')\n    }\n\n    scope = scopeValues.join(' ')\n\n    const params = new URLSearchParams([\n      ['client_id', /** @type {string} */ (this.clientId)],\n      // The endpoint URI MUST NOT include a fragment component.\n      // https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2\n      ['redirect_uri', stripHash(redirectUri)],\n      ['state', state],\n      ['response_mode', this.responseMode],\n      ['response_type', this.responseType],\n      ['scope', scope]\n    ])\n\n    if (this.#useNonce) {\n      params.append('nonce', nonce)\n    }\n\n    if (options?.prompt) {\n      params.append('prompt', options.prompt)\n    }\n\n    if (typeof options?.maxAge === 'number') {\n      params.append('max_age', options.maxAge.toString())\n    }\n\n    if (options?.loginHint) {\n      params.append('login_hint', options.loginHint)\n    }\n\n    if (options?.idpHint) {\n      params.append('kc_idp_hint', options.idpHint)\n    }\n\n    if (options?.action && options.action !== 'register') {\n      params.append('kc_action', options.action)\n    }\n\n    if (options?.locale) {\n      params.append('ui_locales', options.locale)\n    }\n\n    if (options?.acr) {\n      params.append('claims', buildClaimsParameter(options.acr))\n    }\n\n    if (options?.acrValues) {\n      params.append('acr_values', options.acrValues)\n    }\n\n    if (this.pkceMethod) {\n      try {\n        const codeVerifier = generateCodeVerifier(96)\n        const pkceChallenge = await generatePkceChallenge(this.pkceMethod, codeVerifier)\n\n        callbackState.pkceCodeVerifier = codeVerifier\n\n        params.append('code_challenge', pkceChallenge)\n        params.append('code_challenge_method', this.pkceMethod)\n      } catch (error) {\n        throw new Error('Failed to generate PKCE challenge.', { cause: error })\n      }\n    }\n\n    this.#callbackStorage.add(callbackState)\n\n    return `${url}?${params.toString()}`\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {Promise<void>}\n   */\n  logout (options) {\n    return this.#adapter.logout(options)\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {string}\n   */\n  createLogoutUrl (options) {\n    const logoutMethod = options?.logoutMethod ?? this.logoutMethod\n    const url = this.endpoints.logout()\n\n    if (logoutMethod === 'POST') {\n      return url\n    }\n\n    const params = new URLSearchParams([\n      ['client_id', /** @type {string} */ (this.clientId)],\n      ['post_logout_redirect_uri', this.#adapter.redirectUri(options)]\n    ])\n\n    if (this.idToken) {\n      params.append('id_token_hint', this.idToken)\n    }\n\n    return `${url}?${params.toString()}`\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<void>}\n   */\n  register (options) {\n    return this.#adapter.register(options)\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<string>}\n   */\n  createRegisterUrl (options) {\n    return this.createLoginUrl({ ...options, action: 'register' })\n  }\n\n  /**\n   * @param {KeycloakAccountOptions} [options]\n   * @returns {string}\n   */\n  createAccountUrl (options) {\n    const url = this.#getRealmUrl()\n\n    if (!url) {\n      throw new Error('Unable to create account URL, make sure the adapter is not configured using a generic OIDC provider.')\n    }\n\n    const params = new URLSearchParams([\n      ['referrer', /** @type {string} */ (this.clientId)],\n      ['referrer_uri', this.#adapter.redirectUri(options)]\n    ])\n\n    return `${url}/account?${params.toString()}`\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  accountManagement () {\n    return this.#adapter.accountManagement()\n  }\n\n  /**\n   * @param {string} role\n   * @returns {boolean}\n   */\n  hasRealmRole (role) {\n    const access = this.realmAccess\n    return !!access && access.roles.indexOf(role) >= 0\n  }\n\n  /**\n   * @param {string} role\n   * @param {string} [resource]\n   * @returns {boolean}\n   */\n  hasResourceRole (role, resource) {\n    if (!this.resourceAccess) {\n      return false\n    }\n\n    const access = this.resourceAccess[resource || /** @type {string} */ (this.clientId)]\n    return !!access && access.roles.indexOf(role) >= 0\n  }\n\n  /**\n   * @returns {Promise<KeycloakProfile>}\n   */\n  async loadUserProfile () {\n    const realmUrl = this.#getRealmUrl()\n\n    if (!realmUrl) {\n      throw new Error('Unable to load user profile, make sure the adapter is not configured using a generic OIDC provider.')\n    }\n\n    const url = `${realmUrl}/account`\n    /** @type {KeycloakProfile} */\n    const profile = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    })\n\n    return (this.profile = profile)\n  }\n\n  /**\n   * @returns {Promise<{}>}\n   */\n  async loadUserInfo () {\n    const url = this.endpoints.userinfo()\n    /** @type {{}} */\n    const userInfo = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    })\n\n    return (this.userInfo = userInfo)\n  }\n\n  /**\n   * @param {number} [minValidity]\n   * @returns {boolean}\n   */\n  isTokenExpired (minValidity) {\n    if (!this.tokenParsed || (!this.refreshToken && this.flow !== 'implicit')) {\n      throw new Error('Not authenticated')\n    }\n\n    if (this.timeSkew == null) {\n      this.#logInfo('[KEYCLOAK] Unable to determine if token is expired as timeskew is not set')\n      return true\n    }\n\n    if (typeof this.tokenParsed.exp !== 'number') {\n      return false\n    }\n\n    let expiresIn = this.tokenParsed.exp - Math.ceil(new Date().getTime() / 1000) + this.timeSkew\n    if (minValidity) {\n      if (isNaN(minValidity)) {\n        throw new Error('Invalid minValidity')\n      }\n      expiresIn -= minValidity\n    }\n    return expiresIn < 0\n  }\n\n  /**\n   * @param {number} minValidity\n   * @returns {Promise<boolean>}\n   */\n  async updateToken (minValidity) {\n    if (!this.refreshToken) {\n      throw new Error('Unable to update token, no refresh token available.')\n    }\n\n    minValidity = minValidity || 5\n\n    if (this.#loginIframe.enable) {\n      await this.#checkLoginIframe()\n    }\n\n    let refreshToken = false\n\n    if (minValidity === -1) {\n      refreshToken = true\n      this.#logInfo('[KEYCLOAK] Refreshing token: forced refresh')\n    } else if (!this.tokenParsed || this.isTokenExpired(minValidity)) {\n      refreshToken = true\n      this.#logInfo('[KEYCLOAK] Refreshing token: token expired')\n    }\n\n    if (!refreshToken) {\n      return false\n    }\n\n    /** @type {PromiseWithResolvers<boolean>} */\n    const { promise, resolve, reject } = Promise.withResolvers()\n\n    this.#refreshQueue.push({ resolve, reject })\n\n    if (this.#refreshQueue.length === 1) {\n      const url = this.endpoints.token()\n      let timeLocal = new Date().getTime()\n\n      try {\n        const response = await fetchRefreshToken(url, this.refreshToken, /** @type {string} */ (this.clientId))\n        this.#logInfo('[KEYCLOAK] Token refreshed')\n\n        timeLocal = (timeLocal + new Date().getTime()) / 2\n\n        this.#setToken(response.access_token, response.refresh_token, response.id_token, timeLocal)\n\n        this.onAuthRefreshSuccess?.()\n        for (let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop()) {\n          p.resolve(true)\n        }\n      } catch (error) {\n        this.#logWarn('[KEYCLOAK] Failed to refresh token')\n\n        if (error instanceof NetworkError && error.response.status === 400) {\n          this.clearToken()\n        }\n\n        this.onAuthRefreshError?.()\n        for (let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop()) {\n          p.reject(error)\n        }\n      }\n    }\n\n    return await promise\n  }\n\n  clearToken () {\n    if (this.token) {\n      this.#setToken()\n      this.onAuthLogout?.()\n      if (this.loginRequired) {\n        this.login()\n      }\n    }\n  }\n\n  /**\n   * @param {string} [token]\n   * @param {string} [refreshToken]\n   * @param {string} [idToken]\n   * @param {number} [timeLocal]\n   */\n  #setToken (token, refreshToken, idToken, timeLocal) {\n    if (this.tokenTimeoutHandle) {\n      clearTimeout(this.tokenTimeoutHandle)\n      this.tokenTimeoutHandle = undefined\n    }\n\n    if (refreshToken) {\n      this.refreshToken = refreshToken\n      this.refreshTokenParsed = decodeToken(refreshToken)\n    } else {\n      delete this.refreshToken\n      delete this.refreshTokenParsed\n    }\n\n    if (idToken) {\n      this.idToken = idToken\n      this.idTokenParsed = decodeToken(idToken)\n    } else {\n      delete this.idToken\n      delete this.idTokenParsed\n    }\n\n    if (token) {\n      this.token = token\n      this.tokenParsed = decodeToken(token)\n      this.sessionId = this.tokenParsed.sid\n      this.authenticated = true\n      this.subject = this.tokenParsed.sub\n      this.realmAccess = this.tokenParsed.realm_access\n      this.resourceAccess = this.tokenParsed.resource_access\n\n      if (timeLocal) {\n        this.timeSkew = Math.floor(timeLocal / 1000) - this.tokenParsed.iat\n      }\n\n      if (this.timeSkew !== null) {\n        this.#logInfo('[KEYCLOAK] Estimated time difference between browser and server is ' + this.timeSkew + ' seconds')\n\n        if (this.onTokenExpired) {\n          const expiresIn = (this.tokenParsed.exp - (new Date().getTime() / 1000) + this.timeSkew) * 1000\n          this.#logInfo('[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s')\n          if (expiresIn <= 0) {\n            this.onTokenExpired()\n          } else {\n            this.tokenTimeoutHandle = window.setTimeout(this.onTokenExpired, expiresIn)\n          }\n        }\n      }\n    } else {\n      delete this.token\n      delete this.tokenParsed\n      delete this.subject\n      delete this.realmAccess\n      delete this.resourceAccess\n\n      this.authenticated = false\n    }\n  }\n\n  /**\n   * @returns {string=}\n   */\n  #getRealmUrl () {\n    if (typeof this.authServerUrl === 'undefined') {\n      return\n    }\n\n    return `${stripTrailingSlash(this.authServerUrl)}/realms/${encodeURIComponent(/** @type {string} */ (this.realm))}`\n  }\n\n  /**\n   * @param {Function} fn\n   * @returns {(message: string) => void}\n   */\n  #createLogger (fn) {\n    return (message) => {\n      if (this.enableLogging) {\n        fn.call(console, message)\n      }\n    }\n  }\n}\n\n/**\n * @returns {string}\n */\nfunction createUUID () {\n  if (typeof crypto === 'undefined' || typeof crypto.randomUUID === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return crypto.randomUUID()\n}\n\n/**\n * @param {Acr} requestedAcr\n * @returns {string}\n */\nfunction buildClaimsParameter (requestedAcr) {\n  return JSON.stringify({\n    id_token: {\n      acr: requestedAcr\n    }\n  })\n}\n\n/**\n * @param {number} len\n * @returns {string}\n */\nfunction generateCodeVerifier (len) {\n  return generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789')\n}\n\n/**\n * @param {string} pkceMethod\n * @param {string} codeVerifier\n * @returns {Promise<string>}\n */\nasync function generatePkceChallenge (pkceMethod, codeVerifier) {\n  if (pkceMethod !== 'S256') {\n    throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`)\n  }\n\n  // hash codeVerifier, then encode as url-safe base64 without padding\n  const hashBytes = new Uint8Array(await sha256Digest(codeVerifier))\n  const encodedHash = bytesToBase64(hashBytes)\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '')\n\n  return encodedHash\n}\n\n/**\n * @param {number} len\n * @param {string} alphabet\n * @returns {string}\n */\nfunction generateRandomString (len, alphabet) {\n  const randomData = generateRandomData(len)\n  const chars = new Array(len)\n  for (let i = 0; i < len; i++) {\n    chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length)\n  }\n  return String.fromCharCode.apply(null, chars)\n}\n\n/**\n * @param {number} len\n * @returns {Uint8Array<ArrayBuffer>}\n */\nfunction generateRandomData (len) {\n  if (typeof crypto === 'undefined' || typeof crypto.getRandomValues === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return crypto.getRandomValues(new Uint8Array(len))\n}\n\n/**\n * Function to extend existing native Promise with timeout\n *\n * @template T\n * @param {Promise<T>} promise\n * @param {number} timeout\n * @param {string} errorMessage\n * @returns {Promise<T>}\n */\nfunction applyTimeoutToPromise (promise, timeout, errorMessage) {\n  /** @type {number} */\n  let timeoutHandle\n  const timeoutPromise = new Promise(function (resolve, reject) {\n    timeoutHandle = window.setTimeout(function () {\n      reject(new Error(errorMessage || 'Promise is not settled within timeout of ' + timeout + 'ms'))\n    }, timeout)\n  })\n\n  return Promise.race([promise, timeoutPromise]).finally(function () {\n    clearTimeout(timeoutHandle)\n  })\n}\n\n/**\n * @returns {CallbackStorage}\n */\nfunction createCallbackStorage () {\n  try {\n    return new LocalStorage()\n  } catch (err) {\n    return new CookieStorage()\n  }\n}\n\nconst STORAGE_KEY_PREFIX = 'kc-callback-'\n\n/**\n * @typedef {Object} CallbackState\n * @property {string} state\n * @property {string} nonce\n * @property {string} redirectUri\n * @property {KeycloakLoginOptions} [loginOptions]\n * @property {KeycloakLoginOptions['prompt']} [prompt]\n * @property {string} [pkceCodeVerifier]\n */\n\n/**\n * @typedef {Object} CallbackStorage\n * @property {(state?: string) => CallbackState | null} get\n * @property {(state: CallbackState) => void} add\n */\n\n/**\n * @implements {CallbackStorage}\n */\nclass LocalStorage {\n  constructor () {\n    globalThis.localStorage.setItem('kc-test', 'test')\n    globalThis.localStorage.removeItem('kc-test')\n  }\n\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get (state) {\n    if (!state) {\n      return null\n    }\n\n    this.#clearInvalidValues()\n\n    const key = STORAGE_KEY_PREFIX + state\n    const value = globalThis.localStorage.getItem(key)\n\n    if (value) {\n      globalThis.localStorage.removeItem(key)\n      return JSON.parse(value)\n    }\n\n    return null\n  };\n\n  /**\n   * @param {CallbackState} state\n   */\n  add (state) {\n    this.#clearInvalidValues()\n\n    const key = STORAGE_KEY_PREFIX + state.state\n    const value = JSON.stringify({\n      ...state,\n      // Set the expiry time to 1 hour from now.\n      expires: Date.now() + (60 * 60 * 1000)\n    })\n\n    try {\n      globalThis.localStorage.setItem(key, value)\n    } catch (error) {\n      // If the storage is full, clear all known values and try again.\n      this.#clearAllValues()\n      globalThis.localStorage.setItem(key, value)\n    }\n  };\n\n  /**\n   * Clears all values from local storage that are no longer valid.\n   */\n  #clearInvalidValues () {\n    const currentTime = Date.now()\n\n    for (const [key, value] of this.#getStoredEntries()) {\n      // Attempt to parse the expiry time from the value.\n      const expiry = this.#parseExpiry(value)\n\n      // Discard the value if it is malformed or expired.\n      if (expiry === null || expiry < currentTime) {\n        globalThis.localStorage.removeItem(key)\n      }\n    }\n  }\n\n  /**\n   * Clears all known values from local storage.\n   */\n  #clearAllValues () {\n    for (const [key] of this.#getStoredEntries()) {\n      globalThis.localStorage.removeItem(key)\n    }\n  }\n\n  /**\n   * Gets all entries stored in local storage that are known to be managed by this class.\n   * @returns {[string, string][]} An array of key-value pairs.\n   */\n  #getStoredEntries () {\n    return Object.entries(globalThis.localStorage).filter(([key]) => key.startsWith(STORAGE_KEY_PREFIX))\n  }\n\n  /**\n   * Parses the expiry time from a value stored in local storage.\n   * @param {string} value\n   * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n   */\n  #parseExpiry (value) {\n    let parsedValue\n\n    // Attempt to parse the value as JSON.\n    try {\n      parsedValue = JSON.parse(value)\n    } catch (error) {\n      return null\n    }\n\n    // Attempt to extract the 'expires' property.\n    if (isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') {\n      return parsedValue.expires\n    }\n\n    return null\n  }\n}\n\n/**\n * @implements {CallbackStorage}\n */\nclass CookieStorage {\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get (state) {\n    if (!state) {\n      return null\n    }\n\n    const value = this.#getCookie(STORAGE_KEY_PREFIX + state)\n    this.#setCookie(STORAGE_KEY_PREFIX + state, '', this.#cookieExpiration(-100))\n    if (value) {\n      return JSON.parse(value)\n    }\n\n    return null\n  }\n\n  /**\n   * @param {CallbackState} state\n   */\n  add (state) {\n    this.#setCookie(STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), this.#cookieExpiration(60))\n  }\n\n  /**\n   * @param {string} key\n   * @returns\n   */\n  #getCookie (key) {\n    const name = key + '='\n    const ca = document.cookie.split(';')\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i]\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1)\n      }\n      if (c.indexOf(name) === 0) {\n        return c.substring(name.length, c.length)\n      }\n    }\n    return ''\n  }\n\n  /**\n   * @param {string} key\n   * @param {string} value\n   * @param {Date} expirationDate\n   */\n  #setCookie (key, value, expirationDate) {\n    const cookie = key + '=' + value + '; ' +\n            'expires=' + expirationDate.toUTCString() + '; '\n    document.cookie = cookie\n  }\n\n  /**\n   * @param {number} minutes\n   * @returns {Date}\n   */\n  #cookieExpiration (minutes) {\n    const exp = new Date()\n    exp.setTime(exp.getTime() + (minutes * 60 * 1000))\n    return exp\n  }\n}\n\n/**\n * @param {Uint8Array<ArrayBuffer>} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */\nfunction bytesToBase64 (bytes) {\n  const binString = String.fromCodePoint(...bytes)\n  return btoa(binString)\n}\n\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */\nasync function sha256Digest (message) {\n  const encoder = new TextEncoder()\n  const data = encoder.encode(message)\n\n  if (typeof crypto === 'undefined' || typeof crypto.subtle === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return await crypto.subtle.digest('SHA-256', data)\n}\n\n/**\n * @param {string} token\n * @returns {KeycloakTokenParsed}\n */\nfunction decodeToken (token) {\n  const [, payload] = token.split('.')\n\n  if (typeof payload !== 'string') {\n    throw new Error('Unable to decode token, payload not found.')\n  }\n\n  let decoded\n\n  try {\n    decoded = base64UrlDecode(payload)\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid Base64URL value.', { cause: error })\n  }\n\n  try {\n    return JSON.parse(decoded)\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid JSON value.', { cause: error })\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction base64UrlDecode (input) {\n  let output = input\n    .replaceAll('-', '+')\n    .replaceAll('_', '/')\n\n  switch (output.length % 4) {\n    case 0:\n      break\n    case 2:\n      output += '=='\n      break\n    case 3:\n      output += '='\n      break\n    default:\n      throw new Error('Input is not of the correct length.')\n  }\n\n  try {\n    return b64DecodeUnicode(output)\n  } catch (error) {\n    return atob(output)\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction b64DecodeUnicode (input) {\n  return decodeURIComponent(atob(input).replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase()\n\n    if (code.length < 2) {\n      code = '0' + code\n    }\n\n    return '%' + code\n  }))\n}\n\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */\nfunction isObject (input) {\n  return typeof input === 'object' && input !== null\n}\n\n/**\n * @typedef {Object} JsonConfig The JSON version of the adapter configuration.\n * @property {string} auth-server-url The URL of the authentication server.\n * @property {string} realm The name of the realm.\n * @property {string} resource The name of the resource, usually the client ID.\n */\n\n/**\n * Fetch the adapter configuration from the given URL.\n * @param {string} url\n * @returns {Promise<JsonConfig>}\n */\nasync function fetchJsonConfig (url) {\n  return await fetchJSON(url)\n}\n\n/**\n * Fetch the OpenID configuration from the given URL.\n * @param {string} url\n * @returns {Promise<OpenIdProviderMetadata>}\n */\nasync function fetchOpenIdConfig (url) {\n  return await fetchJSON(url)\n}\n\n/**\n * @typedef {Object} AccessTokenResponse The successful token response from the authorization server, based on the {@link https://datatracker.ietf.org/doc/html/rfc6749#section-5.1 OAuth 2.0 Authorization Framework specification}.\n * @property {string} access_token The access token issued by the authorization server.\n * @property {string} token_type The type of the token issued by the authorization server.\n * @property {number} [expires_in] The lifetime in seconds of the access token.\n * @property {string} [refresh_token] The refresh token issued by the authorization server.\n * @property {string} [id_token] The ID token issued by the authorization server, if requested.\n * @property {string} [scope] The scope of the access token.\n */\n\n/**\n * Fetch the access token from the given URL.\n * @param {string} url\n * @param {string} code\n * @param {string} clientId\n * @param {string} redirectUri\n * @param {string} [pkceCodeVerifier]\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchAccessToken (url, code, clientId, redirectUri, pkceCodeVerifier) {\n  const body = new URLSearchParams([\n    ['code', code],\n    ['grant_type', 'authorization_code'],\n    ['client_id', clientId],\n    ['redirect_uri', stripHash(redirectUri)]\n  ])\n\n  if (pkceCodeVerifier) {\n    body.append('code_verifier', pkceCodeVerifier)\n  }\n\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  })\n}\n\n/**\n * Fetch the refresh token from the given URL.\n * @param {string} url\n * @param {string} refreshToken\n * @param {string} clientId\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchRefreshToken (url, refreshToken, clientId) {\n  const body = new URLSearchParams([\n    ['grant_type', 'refresh_token'],\n    ['refresh_token', refreshToken],\n    ['client_id', clientId]\n  ])\n\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  })\n}\n\n/**\n * @template [T=unknown]\n * @param {string} url\n * @param {RequestInit} init\n * @returns {Promise<T>}\n */\nasync function fetchJSON (url, init = {}) {\n  const headers = new Headers(init.headers)\n  headers.set('Accept', CONTENT_TYPE_JSON)\n\n  const response = await fetchWithErrorHandling(url, {\n    ...init,\n    headers\n  })\n\n  return await response.json()\n}\n\n/**\n * @param {string} url\n * @param {RequestInit} [init]\n * @returns {Promise<Response>}\n */\nasync function fetchWithErrorHandling (url, init) {\n  const response = await fetch(url, init)\n\n  if (!response.ok) {\n    throw new NetworkError('Server responded with an invalid status.', { response })\n  }\n\n  return response\n}\n\n/**\n * @param {string} [token]\n * @returns {[string, string]}\n */\nfunction buildAuthorizationHeader (token) {\n  if (!token) {\n    throw new Error('Unable to build authorization header, token is not set, make sure the user is authenticated.')\n  }\n\n  return ['Authorization', `bearer ${token}`]\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripTrailingSlash (url) {\n  return url.endsWith('/') ? url.slice(0, -1) : url\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripHash (url) {\n  const parsedUrl = new URL(url)\n  parsedUrl.hash = ''\n  return parsedUrl.toString()\n}\n\n/**\n * @typedef {Object} NetworkErrorOptionsProperties\n * @property {Response} response\n * @typedef {ErrorOptions & NetworkErrorOptionsProperties} NetworkErrorOptions\n */\n\nexport class NetworkError extends Error {\n  /** @type {Response} */\n  response\n\n  /**\n   * @param {string} message\n   * @param {NetworkErrorOptions} options\n   */\n  constructor (message, options) {\n    super(message, options)\n    this.response = options.response\n  }\n}\n\n/**\n * @param {number} delay\n * @returns {Promise<void>}\n */\nconst waitForTimeout = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}