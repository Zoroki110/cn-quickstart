module AMM.SwapRequest where

import qualified Token.Token as T
import qualified AMM.Pool as P
import DA.Action (void)
import DA.Time (RelTime, subTime, addRelTime, hours)

-- Proposition de swap créée par le trader
-- Pattern Proposal-Accept pour éviter les nested choices
template SwapRequest
  with
    trader : Party
    poolCid : ContractId P.Pool
    poolParty : Party
    poolOperator : Party
    issuerA : Party
    issuerB : Party
    symbolA : Text
    symbolB : Text
    feeBps : Int
    maxTTL : RelTime
    inputTokenCid : ContractId T.Token
    inputSymbol : Text
    inputAmount : Numeric 10
    outputSymbol : Text
    minOutput : Numeric 10
    deadline : Time
    maxPriceImpactBps : Int
  where
    signatory trader
    observer poolParty

    -- Annuler la demande si le trader change d'avis
    choice CancelSwapRequest : ()
      controller trader
      do
        return ()

    -- Le trader "prépare" le swap en transférant son token au pool
    -- controller trader ONLY because Transfer has controller owner
    choice PrepareSwap : ContractId SwapReady
      controller trader
      do
        -- Transfer has controller owner (trader)
        -- Only trader authorizes, poolParty just receives
        _ <- exercise inputTokenCid T.Transfer with
          recipient = poolParty
          qty = inputAmount

        -- Créer SwapReady pour que le pool puisse compléter
        create SwapReady with
          trader = trader
          poolCid = poolCid
          poolParty = poolParty
          issuerA = issuerA
          issuerB = issuerB
          symbolA = symbolA
          symbolB = symbolB
          feeBps = feeBps
          maxTTL = maxTTL
          inputSymbol = inputSymbol
          inputAmount = inputAmount
          outputSymbol = outputSymbol
          minOutput = minOutput
          deadline = deadline
          maxPriceImpactBps = maxPriceImpactBps

-- Swap prêt à être exécuté par le pool
template SwapReady
  with
    trader : Party
    poolCid : ContractId P.Pool
    poolParty : Party
    issuerA : Party
    issuerB : Party
    symbolA : Text
    symbolB : Text
    feeBps : Int
    maxTTL : RelTime
    inputSymbol : Text
    inputAmount : Numeric 10
    outputSymbol : Text
    minOutput : Numeric 10
    deadline : Time
    maxPriceImpactBps : Int
  where
    signatory trader
    observer poolParty

    -- Le pool exécute le swap (calcul x*y=k + transfer output)
    -- CRITICAL-5 & CRITICAL-6 FIX: Use actual pool reserves and update them
    choice ExecuteSwap : (ContractId T.Token, ContractId P.Pool)
      with
        poolTokenACid : ContractId T.Token
        poolTokenBCid : ContractId T.Token
      controller poolParty  -- ONLY poolParty, trader just receives
      do
        -- CRITICAL-5 FIX: Fetch pool to get ACTUAL current reserves (not parameters)
        pool <- fetch poolCid

        -- Use ACTUAL pool reserves directly
        let poolAmountA = pool.reserveA
        let poolAmountB = pool.reserveB

        -- Validations
        now <- getTime
        assertMsg "Swap expired" (now <= deadline)
        let timeDiff = deadline `subTime` now
        assertMsg "TTL exceeded" (timeDiff <= maxTTL)

        -- MEDIUM-1 FIX: Prevent far-future deadlines (max 1 hour from now)
        let maxAllowedDeadline = addRelTime now (hours 1)
        assertMsg "Deadline too far in future (max 1 hour allowed)"
          (deadline <= maxAllowedDeadline)

        assertMsg "Valid input symbol" (inputSymbol == symbolA || inputSymbol == symbolB)
        assertMsg "Different symbols" (inputSymbol /= outputSymbol)
        assertMsg "Valid output symbol" (outputSymbol == symbolA || outputSymbol == symbolB)

        -- Calcul AMM x*y=k
        let (rin, rout, poolOutCid) =
              if inputSymbol == symbolA
              then (poolAmountA, poolAmountB, poolTokenBCid)
              else (poolAmountB, poolAmountA, poolTokenACid)

        -- CRITICAL-1 FIX: Validate ALL values before any division operations
        assertMsg "Input reserve must be positive" (rin > 0.0)
        assertMsg "Output reserve must be positive" (rout > 0.0)
        assertMsg "Input amount must be positive" (inputAmount > 0.0)
        assertMsg "Fee basis points must be valid" (feeBps >= 0 && feeBps <= 10000)

        -- HIGH-2 FIX: Flash loan protection - limit swap to 10% of output reserve
        let maxOutputAmount = rout * 0.1
        assertMsg "Swap too large (max 10% of pool reserve per transaction)"
          (inputAmount <= rin * 0.15)  -- Allow slightly more input since fees reduce impact

        -- Formule Uniswap v2: amountOut = (amountIn * feeMultiplier * reserveOut) / (reserveIn + amountIn * feeMultiplier)
        let feeMul = (10000.0 - intToDecimal feeBps) / 10000.0
        let ainFee = inputAmount * feeMul
        let denom = rin + ainFee

        -- Denominator guaranteed > 0 because: rin > 0 AND ainFee >= 0
        let aout = (ainFee * rout) / denom

        assertMsg "Min output not met" (aout >= minOutput)
        assertMsg "Liquidity exhausted" (aout < rout)

        -- Verify output doesn't exceed flash loan protection limit
        assertMsg "Output exceeds 10% pool reserve limit (flash loan protection)"
          (aout <= maxOutputAmount)

        -- MEDIUM-3 FIX: Enforce reasonable price impact limits
        assertMsg "Price impact tolerance too high (max 50% allowed)"
          (maxPriceImpactBps <= 5000)

        -- Price impact check (safe because rin, rout, pBefore all > 0)
        let pBefore = rout / rin
        let pAfter = (rout - aout) / (rin + inputAmount)
        let impBps = abs(pAfter - pBefore) / pBefore * 10000.0
        assertMsg "Price impact too high" (impBps <= intToDecimal maxPriceImpactBps)

        -- Le POOL (seul controller) transfère son token au trader
        -- Transfer a controller owner (poolParty), donc pas de conflit
        outCid <- exercise poolOutCid T.Transfer with
          recipient = trader
          qty = aout

        -- CRITICAL-6 FIX: Update pool reserves after swap
        -- Input token was already transferred in PrepareSwap
        -- Output token was just transferred above
        -- Now update the pool state to reflect new reserves
        let newReserveA = if inputSymbol == symbolA
                         then poolAmountA + inputAmount  -- Input was A, so A increases
                         else poolAmountA - aout         -- Output was A, so A decreases
        let newReserveB = if inputSymbol == symbolB
                         then poolAmountB + inputAmount  -- Input was B, so B increases
                         else poolAmountB - aout         -- Output was B, so B decreases

        -- Verify new reserves are still positive (should never fail due to earlier checks)
        assertMsg "New reserve A must be positive" (newReserveA > 0.0)
        assertMsg "New reserve B must be positive" (newReserveB > 0.0)

        -- Archive old pool and create new one with updated reserves
        newPool <- exercise poolCid P.ArchiveAndUpdateReserves with
          updatedReserveA = newReserveA
          updatedReserveB = newReserveB

        return (outCid, newPool)
