module TestLiquidity where

import qualified Token.Token as T
import qualified LPToken.LPToken as LP
import qualified AMM.Pool as P
import DA.Time (seconds, addRelTime)
import DA.List (head)
import Daml.Script
import Test.TestHelpers (createPoolWithLiquidity)

{-
  LIQUIDITY PROVISION TESTS (Phase 1)

  Tests:
  1. testFirstLP - First liquidity provider (sqrt formula)
  2. testSubsequentLP - Second LP (proportional formula)
  3. testRemoveLiquidity - Withdraw liquidity
  4. testSlippageProtectionAddLP - Reject if LP tokens below minimum
  5. testSlippageProtectionRemoveLP - Reject if tokens out below minimum
  6. testDeadlineEnforcementAddLP - Reject expired add liquidity
  7. testDeadlineEnforcementRemoveLP - Reject expired remove liquidity
  8. testLPTokenTransfer - Transfer LP tokens between parties
-}

-- Test 1: First liquidity provider (uses sqrt formula)
testFirstLP : Script ()
testFirstLP = script do
  -- Setup parties
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  -- Create empty pool
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 0.0  -- EMPTY pool
    reserveA = 0.0
    reserveB = 0.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  -- Alice has tokens to provide liquidity
  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 10.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 20000.0

  now <- getTime
  let deadline = addRelTime now (seconds 60)

  -- Alice adds liquidity (FIRST LP)
  -- Expected LP tokens = sqrt(10 * 20000) = sqrt(200000) ≈ 447.2136
  (lpToken, newPool) <- submitMulti [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.AddLiquidity with
    provider = alice
    tokenACid = aliceETH
    tokenBCid = aliceUSDC
    amountA = 10.0
    amountB = 20000.0
    minLPTokens = 400.0  -- Safety margin
    deadline = deadline

  -- Verify LP token amount
  Some token <- queryContractId lpIssuer lpToken
  let expectedLP = 447.2135955  -- sqrt(200000)
  let tolerance = 0.0000001
  assertMsg "First LP gets sqrt(A*B) tokens"
    (abs(token.amount - expectedLP) < tolerance)

  -- Verify pool state
  Some p <- queryContractId poolOperator newPool
  assertMsg "Pool reserves updated" (p.reserveA == 10.0)
  assertMsg "Pool reserves updated" (p.reserveB == 20000.0)
  assertMsg "Total LP supply updated" (abs(p.totalLPSupply - expectedLP) < tolerance)

  debug $ "✅ First LP successful: " <> show token.amount <> " LP tokens"

  return ()


-- Test 2: Subsequent LP (uses proportional formula)
testSubsequentLP : Script ()
testSubsequentLP = script do
  -- Setup parties
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  -- Create pool with EXISTING liquidity (after Alice added)
  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 447.2135955  -- Alice's LP tokens
    reserveA = 10.0  -- 10 ETH
    reserveB = 20000.0  -- 20,000 USDC
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  -- Bob has tokens to provide liquidity (same ratio: 2000 USDC per ETH)
  bobETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = bob
    symbol = "ETH"
    amount = 5.0

  bobUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = bob
    symbol = "USDC"
    amount = 10000.0

  now <- getTime
  let deadline = addRelTime now (seconds 60)

  -- Bob adds liquidity (SUBSEQUENT LP)
  -- Expected LP tokens = min(5 * 447.21 / 10, 10000 * 447.21 / 20000)
  --                   = min(223.6, 223.6) = 223.6
  (lpToken, newPool) <- submitMulti [bob, poolParty, lpIssuer] [] $ exerciseCmd pool P.AddLiquidity with
    provider = bob
    tokenACid = bobETH
    tokenBCid = bobUSDC
    amountA = 5.0
    amountB = 10000.0
    minLPTokens = 200.0  -- Safety margin
    deadline = deadline

  -- Verify LP token amount (should be half of Alice's)
  Some token <- queryContractId lpIssuer lpToken
  let expectedLP = 223.6067978  -- Half of 447.21
  let tolerance = 0.0000001
  assertMsg "Subsequent LP gets proportional tokens"
    (abs(token.amount - expectedLP) < tolerance)

  -- Verify pool state
  Some p <- queryContractId poolOperator newPool
  assertMsg "Pool reserves updated" (p.reserveA == 15.0)  -- 10 + 5
  assertMsg "Pool reserves updated" (p.reserveB == 30000.0)  -- 20000 + 10000
  let totalSupply = 447.2135955 + 223.6067978
  assertMsg "Total LP supply updated" (abs(p.totalLPSupply - totalSupply) < tolerance)

  debug $ "✅ Subsequent LP successful: " <> show token.amount <> " LP tokens"

  return ()


-- Test 3: Remove liquidity
testRemoveLiquidity : Script ()
testRemoveLiquidity = script do
  -- Setup parties
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  -- Create pool with actual liquidity using helper (this creates pool + tokens + LP token)
  pool <- createPoolWithLiquidity poolOperator poolParty lpIssuer issuerETH issuerUSDC alice clearportx "ETH" "USDC" 10.0 20000.0

  -- Query for Alice's LP token (created by createPoolWithLiquidity)
  lpTokens <- query @LP.LPToken alice
  let (aliceLP, _) = head lpTokens

  now <- getTime
  let deadline = addRelTime now (seconds 60)

  -- Alice removes 100% of liquidity (burns all her LP tokens)
  let lpBurn = 447.2135955  -- All tokens
  (tokenA, tokenB, newPool) <- submitMulti [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.RemoveLiquidity with
    provider = alice
    lpTokenCid = aliceLP
    lpTokenAmount = lpBurn
    minAmountA = 9.5  -- Expect 10 ETH, with safety margin
    minAmountB = 19500.0  -- Expect 20000 USDC, with safety margin
    deadline = deadline

  debug $ "✅ Remove liquidity successful"

  return ()

-- Test 4: Slippage protection on AddLiquidity
testSlippageProtectionAddLP : Script ()
testSlippageProtectionAddLP = script do
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 10.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 20000.0

  now <- getTime
  let deadline = addRelTime now (seconds 60)

  -- Set minLPTokens TOO HIGH (expected ~447, demand 1000)
  submitMultiMustFail [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.AddLiquidity with
    provider = alice
    tokenACid = aliceETH
    tokenBCid = aliceUSDC
    amountA = 10.0
    amountB = 20000.0
    minLPTokens = 1000.0  -- UNREALISTIC!
    deadline = deadline

  debug "✅ Slippage protection works on AddLiquidity"
  return ()


-- Test 5: Slippage protection on RemoveLiquidity
testSlippageProtectionRemoveLP : Script ()
testSlippageProtectionRemoveLP = script do
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 447.2135955
    reserveA = 10.0
    reserveB = 20000.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  aliceLP <- submit lpIssuer $ createCmd LP.LPToken with
    issuer = lpIssuer
    owner = alice
    poolId = "ETH-USDC"
    amount = 447.2135955

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 10.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 20000.0

  now <- getTime
  let deadline = addRelTime now (seconds 60)

  -- Expect 5 ETH but demand 10 ETH (TOO HIGH)
  submitMultiMustFail [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.RemoveLiquidity with
    provider = alice
    lpTokenCid = aliceLP
    lpTokenAmount = 223.6067978  -- Burn 50%
    minAmountA = 10.0  -- UNREALISTIC! Should get ~5
    minAmountB = 5000.0
    deadline = deadline

  debug "✅ Slippage protection works on RemoveLiquidity"
  return ()


-- Test 6: Deadline enforcement on AddLiquidity
testDeadlineEnforcementAddLP : Script ()
testDeadlineEnforcementAddLP = script do
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 10.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 20000.0

  now <- getTime
  let deadline = addRelTime now (seconds (-10))  -- PAST deadline

  submitMultiMustFail [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.AddLiquidity with
    provider = alice
    tokenACid = aliceETH
    tokenBCid = aliceUSDC
    amountA = 10.0
    amountB = 20000.0
    minLPTokens = 400.0
    deadline = deadline  -- EXPIRED

  debug "✅ Deadline enforcement works on AddLiquidity"
  return ()


-- Test 7: Deadline enforcement on RemoveLiquidity
testDeadlineEnforcementRemoveLP : Script ()
testDeadlineEnforcementRemoveLP = script do
  alice <- allocateParty "Alice"
  poolParty <- allocateParty "PoolParty"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  pool <- submit poolOperator $ createCmd P.Pool with
    poolOperator = poolOperator
    poolParty = poolParty
    lpIssuer = lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = seconds 120
    totalLPSupply = 447.2135955
    reserveA = 10.0
    reserveB = 20000.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  aliceLP <- submit lpIssuer $ createCmd LP.LPToken with
    issuer = lpIssuer
    owner = alice
    poolId = "ETH-USDC"
    amount = 447.2135955

  poolETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = poolParty
    symbol = "ETH"
    amount = 10.0

  poolUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = poolParty
    symbol = "USDC"
    amount = 20000.0

  now <- getTime
  let deadline = addRelTime now (seconds (-10))  -- PAST deadline

  submitMultiMustFail [alice, poolParty, lpIssuer] [] $ exerciseCmd pool P.RemoveLiquidity with
    provider = alice
    lpTokenCid = aliceLP
    lpTokenAmount = 223.6067978
    minAmountA = 4.5
    minAmountB = 9500.0
    deadline = deadline  -- EXPIRED

  debug "✅ Deadline enforcement works on RemoveLiquidity"
  return ()


-- Test 8: LP Token Transfer
testLPTokenTransfer : Script ()
testLPTokenTransfer = script do
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  lpIssuer <- allocateParty "LPIssuer"

  -- Alice has LP tokens
  aliceLP <- submit lpIssuer $ createCmd LP.LPToken with
    issuer = lpIssuer
    owner = alice
    poolId = "ETH-USDC"
    amount = 100.0

  -- Alice transfers 60 LP tokens to Bob
  bobLP <- submit alice $ exerciseCmd aliceLP LP.Transfer with
    recipient = bob
    qty = 60.0

  -- Verify Bob received tokens
  Some bobToken <- queryContractId bob bobLP
  assertMsg "Bob received 60 LP tokens" (bobToken.amount == 60.0)
  assertMsg "Bob is owner" (bobToken.owner == bob)

  -- Verify Alice's remainder was created
  aliceRemainders <- query @LP.LPToken alice
  let aliceRemaining = filter (\(_, t) -> t.owner == alice && t.amount == 40.0) aliceRemainders
  assertMsg "Alice has 40 LP tokens remaining" (length aliceRemaining == 1)

  debug "✅ LP token transfer successful"
  return ()
