module TestReserveSimple where

import Daml.Script
import DA.Time

import qualified Token.Token as T
import qualified LPToken.LPToken as LP
import qualified AMM.Pool as P
import qualified AMM.SwapRequest as SR

-- Simple test: Verify reserves update after a single swap
testSingleSwapReserveUpdate : Script ()
testSingleSwapReserveUpdate = script do
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  poolOperator <- allocateParty "PoolOperator"
  clearportx <- allocateParty "ClearportX"
  poolParty <- allocateParty "PoolParty"
  lpIssuer <- allocateParty "LPIssuer"
  issuerETH <- allocateParty "IssuerETH"
  issuerUSDC <- allocateParty "IssuerUSDC"

  now <- getTime
  let deadline = addRelTime now (hours 1)

  -- Create empty pool
  pool0 <- submit poolOperator $ createCmd P.Pool with
    poolOperator
    poolParty
    lpIssuer
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    poolId = "ETH-USDC"
    maxTTL = hours 2
    totalLPSupply = 0.0
    reserveA = 0.0
    reserveB = 0.0
    tokenACid = None
    tokenBCid = None
    protocolFeeReceiver = clearportx
    maxInBps = 10000
    maxOutBps = 5000

  -- Alice adds liquidity: 100 ETH, 200k USDC
  aliceETH <- submit issuerETH $ createCmd T.Token with
    issuer = issuerETH
    owner = alice
    symbol = "ETH"
    amount = 100.0

  aliceUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = alice
    symbol = "USDC"
    amount = 200000.0

  (aliceLP, pool1) <- submitMulti [alice, poolParty, lpIssuer] [] $ exerciseCmd pool0 P.AddLiquidity with
    provider = alice
    tokenACid = aliceETH
    tokenBCid = aliceUSDC
    amountA = 100.0
    amountB = 200000.0
    minLPTokens = 0.0
    deadline

  -- Check initial pool state
  pool1Data <- queryContractId poolOperator pool1
  let Some pool1State = pool1Data
  let k_initial = pool1State.reserveA * pool1State.reserveB

  debug $ "Initial reserves: " <> show pool1State.reserveA <> " ETH, " <> show pool1State.reserveB <> " USDC"
  debug $ "Initial k: " <> show k_initial

  -- Bob swaps 1000 USDC for ETH
  bobUSDC <- submit issuerUSDC $ createCmd T.Token with
    issuer = issuerUSDC
    owner = bob
    symbol = "USDC"
    amount = 1000.0

  swapReq <- submit bob $ createCmd SR.SwapRequest with
    trader = bob
    poolCid = pool1
    poolParty
    poolOperator
    issuerA = issuerETH
    issuerB = issuerUSDC
    symbolA = "ETH"
    symbolB = "USDC"
    feeBps = 30
    maxTTL = hours 2
    inputTokenCid = bobUSDC
    inputSymbol = "USDC"
    inputAmount = 1000.0
    outputSymbol = "ETH"
    minOutput = 0.0
    deadline
    maxPriceImpactBps = 1000

  (swapReady, _) <- submit bob $ exerciseCmd swapReq SR.PrepareSwap with protocolFeeReceiver = clearportx

  -- Get pool tokens after AddLiquidity (they should still be the original ones)
  poolTokens <- query @T.Token poolParty
  let poolETHs = filter (\(_, t) -> t.symbol == "ETH" && t.owner == poolParty) poolTokens
  let poolUSDCs = filter (\(_, t) -> t.symbol == "USDC" && t.owner == poolParty) poolTokens

  debug $ "Pool has " <> show (length poolETHs) <> " ETH tokens"
  debug $ "Pool has " <> show (length poolUSDCs) <> " USDC tokens"

  -- For now, just verify we have tokens
  assertMsg "Pool should have at least 1 ETH token" (length poolETHs >= 1)
  assertMsg "Pool should have at least 1 USDC token" (length poolUSDCs >= 1)

  return ()
