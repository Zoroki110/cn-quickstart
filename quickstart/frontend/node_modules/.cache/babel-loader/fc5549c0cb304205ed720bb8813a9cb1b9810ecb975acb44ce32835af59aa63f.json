{"ast":null,"code":"// ClearportX Backend API Service\n// Connects to Spring Boot backend at http://localhost:8080\nimport axios from 'axios';\nimport { getAccessToken, getPartyId } from './auth';\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_API_URL || 'http://localhost:8080';\n\n/**\n * Map frontend party names to Canton ledger party IDs\n * This allows using friendly names like \"alice\" in the frontend\n * while using the real Canton party IDs in backend calls\n */\nconst PARTY_MAPPING = {\n  'alice@clearportx': 'app-provider::1220414f85e74ed69ca162b9874f3cf9dfa94fb4968823bd8ac9755544fcb5d72388',\n  'alice': 'app-provider::1220414f85e74ed69ca162b9874f3cf9dfa94fb4968823bd8ac9755544fcb5d72388',\n  'bob': 'app-provider::1220414f85e74ed69ca162b9874f3cf9dfa94fb4968823bd8ac9755544fcb5d72388',\n  'AppProvider': 'app-provider::1220414f85e74ed69ca162b9874f3cf9dfa94fb4968823bd8ac9755544fcb5d72388',\n  'app-provider': 'app-provider::1220414f85e74ed69ca162b9874f3cf9dfa94fb4968823bd8ac9755544fcb5d72388'\n  // Add other parties here as needed\n};\n\n/**\n * Map frontend party name to Canton party ID\n */\nfunction mapPartyToBackend(frontendParty) {\n  return PARTY_MAPPING[frontendParty] || frontendParty;\n}\nexport class BackendApiService {\n  constructor() {\n    this.client = void 0;\n    this.client = axios.create({\n      baseURL: BACKEND_URL,\n      timeout: 30000,\n      headers: {\n        'Content-Type': 'application/json',\n        'ngrok-skip-browser-warning': 'true' // Skip ngrok warning page\n      }\n    });\n\n    // JWT and X-Party interceptor\n    this.client.interceptors.request.use(config => {\n      // Get token from Keycloak auth service\n      const token = getAccessToken();\n\n      // Get party ID from token or fallback\n      const party = getPartyId();\n\n      // Public endpoints that don't need JWT authentication\n      const publicEndpoints = ['/api/pools', '/api/health', '/api/tokens/'];\n      const isPublicEndpoint = publicEndpoints.some(endpoint => {\n        var _config$url;\n        return (_config$url = config.url) === null || _config$url === void 0 ? void 0 : _config$url.includes(endpoint);\n      });\n\n      // Add Authorization header for all protected endpoints (swap, liquidity)\n      if (token && !isPublicEndpoint) {\n        config.headers.Authorization = `Bearer ${token}`;\n        console.log('ðŸ” Adding JWT to request:', config.url);\n      } else if (!token && !isPublicEndpoint) {\n        console.warn('âš ï¸ No JWT token found for protected endpoint:', config.url);\n      }\n\n      // Always inject X-Party header (backend uses this for party context)\n      if (party) {\n        config.headers['X-Party'] = party;\n        console.log('ðŸ‘¤ Adding X-Party header:', party.substring(0, 30) + '...');\n      }\n      return config;\n    });\n\n    // Retry on 429 (rate limit)\n    this.client.interceptors.response.use(response => response, async error => {\n      var _error$response;\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 429) {\n        const retryAfter = parseInt(error.response.headers['retry-after'] || '3');\n        console.log(`âš ï¸  Rate limited, retrying after ${retryAfter}s...`);\n        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));\n        // Retry the original request\n        return this.client.request(error.config);\n      }\n      throw error;\n    });\n  }\n\n  /**\n   * Health check - verify backend is running and synced\n   */\n  async healthCheck() {\n    try {\n      const res = await this.client.get('/api/health/ledger');\n      return res.data;\n    } catch (error) {\n      console.error('Health check failed:', error);\n      // Return a default response indicating the backend is down\n      return {\n        status: 'DOWN',\n        env: 'unknown',\n        darVersion: 'unknown',\n        atomicSwapAvailable: false,\n        poolsActive: 0,\n        synced: false\n      };\n    }\n  }\n\n  /**\n   * Get all active pools with liquidity\n   * Filters to show only top 3 unique pools by TVL (Total Value Locked)\n   */\n  async getPools() {\n    try {\n      const res = await this.client.get('/api/pools');\n\n      // Ensure res.data is an array\n      const poolData = Array.isArray(res.data) ? res.data : [];\n      const allPools = poolData.map(data => this.mapPool(data));\n\n      // Filter pools with significant liquidity (reserveA > 0 and reserveB > 0)\n      const activePools = allPools.filter(pool => pool.reserveA > 0 && pool.reserveB > 0);\n\n      // Remove duplicates based on token pair (keep first occurrence of each pair)\n      const uniquePools = [];\n      const seenPairs = new Set();\n      for (const pool of activePools) {\n        // Create a normalized pair key (alphabetically sorted)\n        const pairKey = [pool.tokenA.symbol, pool.tokenB.symbol].sort().join('/');\n        if (!seenPairs.has(pairKey)) {\n          seenPairs.add(pairKey);\n          uniquePools.push(pool);\n        }\n      }\n\n      // Sort by TVL (Total Value Locked) - using reserveA * reserveB as proxy\n      const sortedPools = uniquePools.sort((a, b) => {\n        const tvlA = a.reserveA * a.reserveB;\n        const tvlB = b.reserveA * b.reserveB;\n        return tvlB - tvlA; // Descending order\n      });\n\n      // Return all unique pools (sorted by TVL)\n      return sortedPools;\n    } catch (error) {\n      console.error('Error loading pools:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get tokens owned by a party\n   * Maps frontend party names (like 'alice') to Canton party IDs\n   */\n  async getTokens(party) {\n    const cantonParty = mapPartyToBackend(party);\n    console.log(`Getting tokens for ${party} (mapped to ${cantonParty})`);\n    try {\n      const res = await this.client.get(`/api/tokens/${cantonParty}`);\n\n      // Ensure res.data is an array\n      const tokenData = Array.isArray(res.data) ? res.data : [];\n\n      // Map all tokens\n      const allTokens = tokenData.map(data => this.mapToken(data));\n\n      // Aggregate tokens by symbol (sum balances of same token)\n      const tokenMap = new Map();\n      for (const token of allTokens) {\n        const existing = tokenMap.get(token.symbol);\n        if (existing) {\n          // Sum the balances\n          existing.balance = (existing.balance || 0) + (token.balance || 0);\n        } else {\n          // First occurrence of this symbol\n          tokenMap.set(token.symbol, {\n            ...token\n          });\n        }\n      }\n\n      // Convert map to array and filter out tokens with 0 balance\n      const aggregatedTokens = Array.from(tokenMap.values()).filter(token => (token.balance || 0) > 0).sort((a, b) => (b.balance || 0) - (a.balance || 0)); // Sort by balance descending\n\n      console.log(`Aggregated ${allTokens.length} tokens into ${aggregatedTokens.length} unique tokens`);\n      return aggregatedTokens;\n    } catch (error) {\n      console.error('Error loading tokens:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Execute atomic swap (PrepareSwap + ExecuteSwap in 1 transaction)\n   * This is the recommended endpoint for production use\n   */\n  async executeAtomicSwap(params) {\n    const idempotencyKey = this.generateIdempotencyKey();\n    const res = await this.client.post('/api/swap/atomic', params, {\n      headers: {\n        'X-Idempotency-Key': idempotencyKey\n      }\n    });\n    return res.data;\n  }\n\n  /**\n   * Add liquidity to a pool\n   */\n  async addLiquidity(params) {\n    const res = await this.client.post('/api/liquidity/add', params);\n    return res.data;\n  }\n\n  /**\n   * Remove liquidity from a pool\n   */\n  async removeLiquidity(params) {\n    const res = await this.client.post('/api/liquidity/remove', params);\n    return res.data;\n  }\n\n  /**\n   * Calculate swap quote (off-chain estimation)\n   * Use this to show estimated output before executing swap\n   */\n  async calculateSwapQuote(params) {\n    // For now, we calculate client-side using pool reserves\n    // Backend doesn't have a quote endpoint yet\n    const pools = await this.getPools();\n    const pool = pools.find(p => p.tokenA.symbol === params.inputSymbol && p.tokenB.symbol === params.outputSymbol || p.tokenA.symbol === params.outputSymbol && p.tokenB.symbol === params.inputSymbol);\n    if (!pool) {\n      throw new Error('Pool not found');\n    }\n    const inputAmount = parseFloat(params.inputAmount);\n    const isAtoB = pool.tokenA.symbol === params.inputSymbol;\n    const reserveIn = isAtoB ? pool.reserveA : pool.reserveB;\n    const reserveOut = isAtoB ? pool.reserveB : pool.reserveA;\n\n    // Constant product formula: k = x * y\n    // outputAmount = (inputAfterFee * reserveOut) / (reserveIn + inputAfterFee)\n    const feeBps = pool.feeRate * 10000; // 0.003 â†’ 30 bps\n    const feeAmount = inputAmount * feeBps / 10000;\n    const inputAfterFee = inputAmount - feeAmount;\n    const outputAmount = inputAfterFee * reserveOut / (reserveIn + inputAfterFee);\n\n    // Price impact\n    const priceBefore = reserveOut / reserveIn;\n    const priceAfter = (reserveOut - outputAmount) / (reserveIn + inputAmount);\n    const priceImpact = Math.abs((priceAfter - priceBefore) / priceBefore) * 100;\n    return {\n      inputAmount: inputAmount,\n      // number (parsed above)\n      outputAmount: outputAmount,\n      // number (calculated)\n      priceImpact: priceImpact,\n      // number (percentage)\n      fee: feeAmount,\n      // number\n      route: [params.inputSymbol, params.outputSymbol],\n      // string[]\n      slippage: 0.5 // default 0.5%\n    };\n  }\n\n  // Helper: Generate idempotency key for swap\n  generateIdempotencyKey() {\n    return `swap-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  // Helper: Map backend pool DTO to frontend PoolInfo\n  mapPool(data) {\n    // Use new tokenA/tokenB objects if available, fallback to deprecated symbolA/symbolB\n    const tokenA = data.tokenA || {\n      symbol: data.symbolA,\n      name: data.symbolA,\n      decimals: 10\n    };\n    const tokenB = data.tokenB || {\n      symbol: data.symbolB,\n      name: data.symbolB,\n      decimals: 10\n    };\n    return {\n      contractId: data.poolId || '',\n      tokenA: {\n        symbol: tokenA.symbol,\n        name: tokenA.name,\n        decimals: tokenA.decimals,\n        balance: 0,\n        contractId: '',\n        logoUrl: this.getTokenLogo(tokenA.symbol)\n      },\n      tokenB: {\n        symbol: tokenB.symbol,\n        name: tokenB.name,\n        decimals: tokenB.decimals,\n        balance: 0,\n        contractId: '',\n        logoUrl: this.getTokenLogo(tokenB.symbol)\n      },\n      reserveA: parseFloat(data.reserveA),\n      reserveB: parseFloat(data.reserveB),\n      totalLiquidity: parseFloat(data.totalLPSupply || 0),\n      feeRate: data.feeRate || 0.003,\n      apr: 0,\n      // TODO: Calculate from volume/liquidity metrics\n      volume24h: parseFloat(data.volume24h || 0) // Real 24h volume from backend\n    };\n  }\n\n  // Helper: Map backend token DTO to frontend TokenInfo\n  mapToken(data) {\n    return {\n      symbol: data.symbol,\n      name: data.name || data.symbol,\n      decimals: data.decimals || 10,\n      balance: parseFloat(data.amount || data.quantity || '0'),\n      contractId: data.contractId || '',\n      logoUrl: this.getTokenLogo(data.symbol)\n    };\n  }\n\n  // Helper: Get token logo URL\n  getTokenLogo(symbol) {\n    const logos = {\n      ETH: 'https://cryptologos.cc/logos/ethereum-eth-logo.png',\n      USDC: 'https://cryptologos.cc/logos/usd-coin-usdc-logo.png',\n      BTC: 'https://cryptologos.cc/logos/bitcoin-btc-logo.png',\n      USDT: 'https://cryptologos.cc/logos/tether-usdt-logo.png'\n    };\n    return logos[symbol] || '';\n  }\n}\n\n// Export singleton instance\nexport const backendApi = new BackendApiService();","map":{"version":3,"names":["axios","getAccessToken","getPartyId","BACKEND_URL","process","env","REACT_APP_BACKEND_API_URL","PARTY_MAPPING","mapPartyToBackend","frontendParty","BackendApiService","constructor","client","create","baseURL","timeout","headers","interceptors","request","use","config","token","party","publicEndpoints","isPublicEndpoint","some","endpoint","_config$url","url","includes","Authorization","console","log","warn","substring","response","error","_error$response","status","retryAfter","parseInt","Promise","resolve","setTimeout","healthCheck","res","get","data","darVersion","atomicSwapAvailable","poolsActive","synced","getPools","poolData","Array","isArray","allPools","map","mapPool","activePools","filter","pool","reserveA","reserveB","uniquePools","seenPairs","Set","pairKey","tokenA","symbol","tokenB","sort","join","has","add","push","sortedPools","a","b","tvlA","tvlB","getTokens","cantonParty","tokenData","allTokens","mapToken","tokenMap","Map","existing","balance","set","aggregatedTokens","from","values","length","executeAtomicSwap","params","idempotencyKey","generateIdempotencyKey","post","addLiquidity","removeLiquidity","calculateSwapQuote","pools","find","p","inputSymbol","outputSymbol","Error","inputAmount","parseFloat","isAtoB","reserveIn","reserveOut","feeBps","feeRate","feeAmount","inputAfterFee","outputAmount","priceBefore","priceAfter","priceImpact","Math","abs","fee","route","slippage","Date","now","random","toString","substr","symbolA","name","decimals","symbolB","contractId","poolId","logoUrl","getTokenLogo","totalLiquidity","totalLPSupply","apr","volume24h","amount","quantity","logos","ETH","USDC","BTC","USDT","backendApi"],"sources":["/root/canton-website/app/src/services/backendApi.ts"],"sourcesContent":["// ClearportX Backend API Service\n// Connects to Spring Boot backend at http://localhost:8080\nimport axios, { AxiosInstance, AxiosError } from 'axios';\nimport { TokenInfo, PoolInfo, SwapQuote } from '../types/canton';\nimport { getAccessToken, getPartyId } from './auth';\n\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_API_URL || 'http://localhost:8080';\n\n/**\n * Map frontend party names to Canton ledger party IDs\n * This allows using friendly names like \"alice\" in the frontend\n * while using the real Canton party IDs in backend calls\n */\nconst PARTY_MAPPING: Record<string, string> = {\n  'alice@clearportx': 'app-provider::1220414f85e74ed69ca162b9874f3cf9dfa94fb4968823bd8ac9755544fcb5d72388',\n  'alice': 'app-provider::1220414f85e74ed69ca162b9874f3cf9dfa94fb4968823bd8ac9755544fcb5d72388',\n  'bob': 'app-provider::1220414f85e74ed69ca162b9874f3cf9dfa94fb4968823bd8ac9755544fcb5d72388',\n  'AppProvider': 'app-provider::1220414f85e74ed69ca162b9874f3cf9dfa94fb4968823bd8ac9755544fcb5d72388',\n  'app-provider': 'app-provider::1220414f85e74ed69ca162b9874f3cf9dfa94fb4968823bd8ac9755544fcb5d72388',\n  // Add other parties here as needed\n};\n\n/**\n * Map frontend party name to Canton party ID\n */\nfunction mapPartyToBackend(frontendParty: string): string {\n  return PARTY_MAPPING[frontendParty] || frontendParty;\n}\n\nexport interface SwapParams {\n  poolId?: string; // Optional - backend auto-discovers by token pair\n  inputSymbol: string;\n  outputSymbol: string;\n  inputAmount: string; // BigDecimal string \"0.1000000000\"\n  minOutput: string;\n  maxPriceImpactBps: number; // e.g., 200 for 2%\n}\n\nexport interface AtomicSwapResponse {\n  receiptCid: string;\n  trader: string;\n  inputSymbol: string;\n  outputSymbol: string;\n  amountIn: string;\n  amountOut: string;\n  timestamp: string;\n}\n\nexport interface AddLiquidityParams {\n  poolId: string;\n  amountA: string;\n  amountB: string;\n  minLPTokens: string;\n}\n\nexport interface RemoveLiquidityParams {\n  poolId: string;\n  lpTokenAmount: string;\n  minAmountA: string;\n  minAmountB: string;\n}\n\nexport interface HealthResponse {\n  status: string;\n  env: string;\n  darVersion: string;\n  atomicSwapAvailable: boolean;\n  poolsActive: number;\n  synced: boolean;\n  pqsOffset?: number;\n  clearportxContractCount?: number;\n}\n\nexport class BackendApiService {\n  private client: AxiosInstance;\n\n  constructor() {\n    this.client = axios.create({\n      baseURL: BACKEND_URL,\n      timeout: 30000,\n      headers: {\n        'Content-Type': 'application/json',\n        'ngrok-skip-browser-warning': 'true', // Skip ngrok warning page\n      },\n    });\n\n    // JWT and X-Party interceptor\n    this.client.interceptors.request.use((config) => {\n      // Get token from Keycloak auth service\n      const token = getAccessToken();\n\n      // Get party ID from token or fallback\n      const party = getPartyId();\n\n      // Public endpoints that don't need JWT authentication\n      const publicEndpoints = ['/api/pools', '/api/health', '/api/tokens/'];\n      const isPublicEndpoint = publicEndpoints.some(endpoint => config.url?.includes(endpoint));\n\n      // Add Authorization header for all protected endpoints (swap, liquidity)\n      if (token && !isPublicEndpoint) {\n        config.headers.Authorization = `Bearer ${token}`;\n        console.log('ðŸ” Adding JWT to request:', config.url);\n      } else if (!token && !isPublicEndpoint) {\n        console.warn('âš ï¸ No JWT token found for protected endpoint:', config.url);\n      }\n\n      // Always inject X-Party header (backend uses this for party context)\n      if (party) {\n        config.headers['X-Party'] = party;\n        console.log('ðŸ‘¤ Adding X-Party header:', party.substring(0, 30) + '...');\n      }\n\n      return config;\n    });\n\n    // Retry on 429 (rate limit)\n    this.client.interceptors.response.use(\n      (response) => response,\n      async (error: AxiosError) => {\n        if (error.response?.status === 429) {\n          const retryAfter = parseInt(error.response.headers['retry-after'] || '3');\n          console.log(`âš ï¸  Rate limited, retrying after ${retryAfter}s...`);\n          await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));\n          // Retry the original request\n          return this.client.request(error.config!);\n        }\n        throw error;\n      }\n    );\n  }\n\n  /**\n   * Health check - verify backend is running and synced\n   */\n  async healthCheck(): Promise<HealthResponse> {\n    try {\n      const res = await this.client.get('/api/health/ledger');\n      return res.data;\n    } catch (error) {\n      console.error('Health check failed:', error);\n      // Return a default response indicating the backend is down\n      return {\n        status: 'DOWN',\n        env: 'unknown',\n        darVersion: 'unknown',\n        atomicSwapAvailable: false,\n        poolsActive: 0,\n        synced: false\n      };\n    }\n  }\n\n  /**\n   * Get all active pools with liquidity\n   * Filters to show only top 3 unique pools by TVL (Total Value Locked)\n   */\n  async getPools(): Promise<PoolInfo[]> {\n    try {\n      const res = await this.client.get('/api/pools');\n      \n      // Ensure res.data is an array\n      const poolData = Array.isArray(res.data) ? res.data : [];\n      \n      const allPools = poolData.map((data: any) => this.mapPool(data));\n\n    // Filter pools with significant liquidity (reserveA > 0 and reserveB > 0)\n    const activePools = allPools.filter((pool: PoolInfo) =>\n      pool.reserveA > 0 && pool.reserveB > 0\n    );\n\n    // Remove duplicates based on token pair (keep first occurrence of each pair)\n    const uniquePools: PoolInfo[] = [];\n    const seenPairs = new Set<string>();\n\n    for (const pool of activePools) {\n      // Create a normalized pair key (alphabetically sorted)\n      const pairKey = [pool.tokenA.symbol, pool.tokenB.symbol].sort().join('/');\n\n      if (!seenPairs.has(pairKey)) {\n        seenPairs.add(pairKey);\n        uniquePools.push(pool);\n      }\n    }\n\n    // Sort by TVL (Total Value Locked) - using reserveA * reserveB as proxy\n    const sortedPools = uniquePools.sort((a: PoolInfo, b: PoolInfo) => {\n      const tvlA = a.reserveA * a.reserveB;\n      const tvlB = b.reserveA * b.reserveB;\n      return tvlB - tvlA; // Descending order\n    });\n\n    // Return all unique pools (sorted by TVL)\n    return sortedPools;\n    } catch (error) {\n      console.error('Error loading pools:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get tokens owned by a party\n   * Maps frontend party names (like 'alice') to Canton party IDs\n   */\n  async getTokens(party: string): Promise<TokenInfo[]> {\n    const cantonParty = mapPartyToBackend(party);\n    console.log(`Getting tokens for ${party} (mapped to ${cantonParty})`);\n    \n    try {\n      const res = await this.client.get(`/api/tokens/${cantonParty}`);\n      \n      // Ensure res.data is an array\n      const tokenData = Array.isArray(res.data) ? res.data : [];\n      \n      // Map all tokens\n      const allTokens = tokenData.map((data: any) => this.mapToken(data));\n\n    // Aggregate tokens by symbol (sum balances of same token)\n    const tokenMap = new Map<string, TokenInfo>();\n\n    for (const token of allTokens) {\n      const existing = tokenMap.get(token.symbol);\n      if (existing) {\n        // Sum the balances\n        existing.balance = (existing.balance || 0) + (token.balance || 0);\n      } else {\n        // First occurrence of this symbol\n        tokenMap.set(token.symbol, { ...token });\n      }\n    }\n\n    // Convert map to array and filter out tokens with 0 balance\n    const aggregatedTokens = Array.from(tokenMap.values())\n      .filter(token => (token.balance || 0) > 0)\n      .sort((a, b) => (b.balance || 0) - (a.balance || 0)); // Sort by balance descending\n\n    console.log(`Aggregated ${allTokens.length} tokens into ${aggregatedTokens.length} unique tokens`);\n\n    return aggregatedTokens;\n    } catch (error) {\n      console.error('Error loading tokens:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Execute atomic swap (PrepareSwap + ExecuteSwap in 1 transaction)\n   * This is the recommended endpoint for production use\n   */\n  async executeAtomicSwap(params: SwapParams): Promise<AtomicSwapResponse> {\n    const idempotencyKey = this.generateIdempotencyKey();\n    const res = await this.client.post('/api/swap/atomic', params, {\n      headers: {\n        'X-Idempotency-Key': idempotencyKey\n      },\n    });\n    return res.data;\n  }\n\n  /**\n   * Add liquidity to a pool\n   */\n  async addLiquidity(params: AddLiquidityParams): Promise<{ lpTokenCid: string; lpAmount: string }> {\n    const res = await this.client.post('/api/liquidity/add', params);\n    return res.data;\n  }\n\n  /**\n   * Remove liquidity from a pool\n   */\n  async removeLiquidity(params: RemoveLiquidityParams): Promise<{\n    tokenACid: string;\n    tokenBCid: string;\n    amountA: string;\n    amountB: string\n  }> {\n    const res = await this.client.post('/api/liquidity/remove', params);\n    return res.data;\n  }\n\n  /**\n   * Calculate swap quote (off-chain estimation)\n   * Use this to show estimated output before executing swap\n   */\n  async calculateSwapQuote(params: {\n    poolId: string;\n    inputSymbol: string;\n    outputSymbol: string;\n    inputAmount: string;\n  }): Promise<SwapQuote> {\n    // For now, we calculate client-side using pool reserves\n    // Backend doesn't have a quote endpoint yet\n    const pools = await this.getPools();\n    const pool = pools.find(p =>\n      (p.tokenA.symbol === params.inputSymbol && p.tokenB.symbol === params.outputSymbol) ||\n      (p.tokenA.symbol === params.outputSymbol && p.tokenB.symbol === params.inputSymbol)\n    );\n\n    if (!pool) {\n      throw new Error('Pool not found');\n    }\n\n    const inputAmount = parseFloat(params.inputAmount);\n    const isAtoB = pool.tokenA.symbol === params.inputSymbol;\n    const reserveIn = isAtoB ? pool.reserveA : pool.reserveB;\n    const reserveOut = isAtoB ? pool.reserveB : pool.reserveA;\n\n    // Constant product formula: k = x * y\n    // outputAmount = (inputAfterFee * reserveOut) / (reserveIn + inputAfterFee)\n    const feeBps = pool.feeRate * 10000; // 0.003 â†’ 30 bps\n    const feeAmount = (inputAmount * feeBps) / 10000;\n    const inputAfterFee = inputAmount - feeAmount;\n    const outputAmount = (inputAfterFee * reserveOut) / (reserveIn + inputAfterFee);\n\n    // Price impact\n    const priceBefore = reserveOut / reserveIn;\n    const priceAfter = (reserveOut - outputAmount) / (reserveIn + inputAmount);\n    const priceImpact = Math.abs((priceAfter - priceBefore) / priceBefore) * 100;\n\n    return {\n      inputAmount: inputAmount,        // number (parsed above)\n      outputAmount: outputAmount,       // number (calculated)\n      priceImpact: priceImpact,         // number (percentage)\n      fee: feeAmount,                   // number\n      route: [params.inputSymbol, params.outputSymbol],  // string[]\n      slippage: 0.5,                    // default 0.5%\n    };\n  }\n\n  // Helper: Generate idempotency key for swap\n  private generateIdempotencyKey(): string {\n    return `swap-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  // Helper: Map backend pool DTO to frontend PoolInfo\n  private mapPool(data: any): PoolInfo {\n    // Use new tokenA/tokenB objects if available, fallback to deprecated symbolA/symbolB\n    const tokenA = data.tokenA || { symbol: data.symbolA, name: data.symbolA, decimals: 10 };\n    const tokenB = data.tokenB || { symbol: data.symbolB, name: data.symbolB, decimals: 10 };\n\n    return {\n      contractId: data.poolId || '',\n      tokenA: {\n        symbol: tokenA.symbol,\n        name: tokenA.name,\n        decimals: tokenA.decimals,\n        balance: 0,\n        contractId: '',\n        logoUrl: this.getTokenLogo(tokenA.symbol),\n      },\n      tokenB: {\n        symbol: tokenB.symbol,\n        name: tokenB.name,\n        decimals: tokenB.decimals,\n        balance: 0,\n        contractId: '',\n        logoUrl: this.getTokenLogo(tokenB.symbol),\n      },\n      reserveA: parseFloat(data.reserveA),\n      reserveB: parseFloat(data.reserveB),\n      totalLiquidity: parseFloat(data.totalLPSupply || 0),\n      feeRate: data.feeRate || 0.003,\n      apr: 0, // TODO: Calculate from volume/liquidity metrics\n      volume24h: parseFloat(data.volume24h || 0), // Real 24h volume from backend\n    };\n  }\n\n  // Helper: Map backend token DTO to frontend TokenInfo\n  private mapToken(data: any): TokenInfo {\n    return {\n      symbol: data.symbol,\n      name: data.name || data.symbol,\n      decimals: data.decimals || 10,\n      balance: parseFloat(data.amount || data.quantity || '0'),\n      contractId: data.contractId || '',\n      logoUrl: this.getTokenLogo(data.symbol),\n    };\n  }\n\n  // Helper: Get token logo URL\n  private getTokenLogo(symbol: string): string {\n    const logos: Record<string, string> = {\n      ETH: 'https://cryptologos.cc/logos/ethereum-eth-logo.png',\n      USDC: 'https://cryptologos.cc/logos/usd-coin-usdc-logo.png',\n      BTC: 'https://cryptologos.cc/logos/bitcoin-btc-logo.png',\n      USDT: 'https://cryptologos.cc/logos/tether-usdt-logo.png',\n    };\n    return logos[symbol] || '';\n  }\n}\n\n// Export singleton instance\nexport const backendApi = new BackendApiService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}